{"pages":[{"title":"all-categories","text":"","link":"/all-categories/"},{"title":"all-archives","text":"","link":"/all-archives/"},{"title":"all-tags","text":"","link":"/all-tags/"}],"posts":[{"title":"OSI 7 Layer","text":"1. OSI 7 Layer 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약 OSI 7 Layer란? 물리 계층 : 디지털 신호를 전기 신호로 변환 데이터링크 계층 : Ethernet, Frame, 물리 계층과 데이터 계층의 연결을 담당, 헤더에 Source/Destination MAC Address 네트워크 계층 : IP, ARP 패킷, 방대한 네트워크 망에서 논리적인 연결을 할 수 있게 해줌, Source/Destination IP, 패킷 트레이서 전송 계층 : TCP, Segment, 데이터 전송을 담당, 어떤 응용프로그램에 전달해야하는지 port를 통해 식별 세션 계층 : 세션과 Dialogue 연결 및 관리, FTP를 통해 여러 파일을 받을 때, 각 다운로드는 Session으로 구분하고 연결 및 관리 표현 계층 : 응용 계층으로부터 전달받거나, 전달하는 데이터를 암호화 응용 계층 : HTTP, 네트워크 응용프로그램을 위한 인터페이스를 제공 1-1. 전송 계층 프로토콜 중 TCP와 UDP의 차이점 TCP 연결형 프로토콜, 데이터의 전송순서 및 신뢰성 보장 Path를 만들어놓고, 송수신이 끝나면 끊는다. UDP 비연결형 프로토콜, TCP보다 빠른 전송 속도 스트리밍, 브로드캐스팅 서비스에 사용된다. 데이터 단위 : 데이터 그램 1-2. 일반적으로 상대방의 MAC 주소를 알기 어려운데 어떻게 데이터를 보내는 지상대의 IP는 알아도 MAC은 모르는데 ARP를 통해 IP에서 MAC주소를 받아온다 1-3. Layer를 구분한 이유?어느 부분이 잘못되었는지 파악 및 처리를 하기 위하여 계층을 구분했다.","link":"/11/11/0-interview-newtork1/"},{"title":"메모리 할당 알고리즘, 페이지 폴트, 단편화","text":"5. 메모리 할당 알고리즘 (First fit, Next fit, Best fit) 결과에 대해 설명해보세요 메모리의 처음부터 탐색하기 시작해서, 크기가 충분한 첫 번째 메모리에 할당하는 First fit,마지막으로 참조한 메모리 공간부터 탐색을 시작해서 메모리를 할당하는 Next fit,모든 메모리 공간을 검사해서 내부 단편화를 최소화 하는 공간에 할당하는 Best fit이 있습니다. 5-1. 메모리 할당 알고리즘의 필요성 (가변 배치 전략)OS가 제공하는 다중 프로그래밍 환경 내에서 / 다양한 프로그램들이 메모리 공간을 불규칙적으로 사용, 반환합니다.이러한 불규칙적인 공간 중 프로세스에게 할당해 줄 메모리 공간을 선택하기 위해 메모리 할당 알고리즘이 필요합니다. 5-2. 각 알고리즘의 장단점이 있다면?First-fit : 가장 간단하고 빠르지만, 공간 활용률이 떨어질 수 있습니다.Next-fit : first-fit에 보다는 느리지만, 빠른 속도가 장점이다, 일반적으로 메모리 공간의 끝에 있는 가장 큰 크기의 메모리를 짧은 시간내에 작은 크기로 조각내서 메모리 집약작업이 추가적으로 필요하다.Best-fit : 공간 활용률이 높아진다는 장점이지만, 가용 메모리가 크기 순으로 정렬되어있지 않으면 메모리 검색 시간이 늘어난다. 6. 페이지 폴트에 따른 페이지 교체 알고리즘에 대해 설명해주세요OPT(Optimization) : 가장 오랫동안 사용하지 않을 페이지를 예측하여 교체하는, 최적화 방식FIFO(First In First Out) : 메모리가 할당된 순서대로 페이지를 교체하는 방식LRU(Least Recently Used) : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체LFU(Least Frequently Used) : 사용 빈도가 가장 적은 페이지를 교체NUR(Not Used Recently) : 최근에 가장 사용하지 않은 페이지를 교체 6-1. 페이지 폴트란 무엇인가?운영체제의 스와퍼(Swapper)는 메모리에 동작하고 있는 프로세스 중에서 실제로 필요한 프로세스만 로드하고, 페이저(Pager)는 프로세스의 필요한 페이지만 로드합니다.따라서 필요한 페이지가 물리 메모리에 부재할 수 있는 시점이 있는 데, 이 때를 페이지 폴트라 합니다. 6-2. 페이지 폴트의 해결과정필요한 페이지가 없는 것을 해결하기위해 요구를 합니다. 이를 Demand Paging이라하는데,페이지 폴트가 발생하면 CPU에서 trap을 발생시켜 OS에 알립니다.OS에서는 interrupt를 발생시키고 주소 값과 Valid bit가 있는 Page Table을 통해필요한 페이지가 있는 지 확인합니다. 없으면 프로세스를 종료하고, 있으면 물리 메모리에 비어있는 프레임을 찾습니다. 이 때 비어있는 프레임이 없으면 페이지 교체 알고리즘을 통해 페이지를 교체하고,페이지가 있으면 그 공간에 로드합니다. 7. 단편화란 무엇인가? RAM에서 메모리의 공간이 조각으로 나뉘어져, 사용 가능한 메모리가 충분히 존재하지만 할당할 수 없는 상태 7-1. 내부 단편화 프로세스가 필요한 양보다 더 큰 메모리가 할당되어, 할당된 메모리 내의 공간이 낭비되는 상황 7-2. 외부 단편화 총 사용 가능 메모리 공간은 충분하지만, 비연속적으로 존재하여 프로세스에 대한 할당이 불가능한 상황","link":"/10/28/0-interview-os1/"},{"title":"프로세스, 스레드, 교착상태, 메모리 계층","text":"1. 프로세스와 스레드 차이 프로세스는 프로그램이 OS로부터 메모리를 할당받은 동적인 상태의 프로그램 (OS 입장에서 최소 작업단위) 스레드는 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 (CPU 입장에서 최소 작업단위) 프로세스 별로 최소 1개의 스레드를 보유하며, PCB라는 별도의 독립적인 주소 공간을 할당 받는다 프로세스 내의 스레드는 stack 영역을 독립적으로 갖으며, 나머지 영역은 서로 공유하게 됩니다. 1-1. PCB 영역에 대한 설명PCB : stack, heap, data, code OS가 프로세스를 제어하기 위해 프로세스의 상태 정보를 저장하는 곳 PID, state, 포인터, 레지스터 관련 정보, priority, account(CPU 관련), 입출력 상태 정보 프로세스 생성 시 만들어지며 주 기억장치에 저장된다. interrupt시 context switching 에 사용 1-2. Data 영역에는 무엇이 저장되는가 전역 변수(정적 변수, 배열, 구조체 등), 프로그램 종료 시 시스템에 반환한다. 초기화된 변수를 저장하는 data와, 초기화 되지 않은 변수를 저장하는 bss로 나뉜다. 1-3. 프로세스 안의 4가지 영역 중 메모리가 끝날때까지 남는 영역 코드와 데이터 영역 코드 : 실행할 프로그램 코드가 저장되는 영역, 프로그램이 시작되고 끝날 때까지 메모리에 유지된다. 데이터 : 전역 변수와 스태틱 변수가 저장되며 프로그램 시작때 할당되고 종료될 때 해제된다. 1-4. 스레드가 생겨난 배경 프로그램이 복잡해지면서 단일 프로세스를 이용하여 프로그램을 실행해지기 힘들어짐 안정성때문에 여러 프로세스를 사용하지않고 더 작은 실행 단위 개념인 스레드를 만들었다. 2. 멀티 프로세스로 처리 가능한 것을 멀티 스레드로 처리하는 이유 프로세스는 생성할 때마다 자원을 할당하는 system call을 호출하게 되고, IPC를 통해 interrupt를 발생시키며 통신하게 됩니다. 멀티 스레드로 처리할 시 system call이 감소하고, IPC보다 스레드간의 통신비용이 더 적기 때문에 자원의 효율성을 위해 멀티스레드로 처리합니다. 하지만 스레드들은 PCB 중 stack 영역을 제외한 자원을 공유하기 때문에, 이를 해결하기 위해 동기화에 신경써야합니다. 2-1. 스택을 스레드마다 독립적으로 할당하는 이유스택은 함수 호출시 전달되는 인자, 되돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하기 위해 사용하는 메모리 공간이다. 스택이 독립적이라는 것은 독립적인 함수의 호출이 가능하고, 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당하는 것이다. 2-2. PC(Program Counter) Register를 스레드마다 독립적으로 할당하는 이유PC는 명령어의 어디까지 수행하였는가를 가리킨다. Interrupt가 발생하면서 명령어는 연속적으로 수행되지 못하기 때문에, 어느 부분까지 수행했는지를 기억하고 있어야한다. 그러므로 PC 레지스터가 독립적으로 할당될 필요가 있다. 2-3. 프로세스를 생성할 때 어떤 system call을 필요로 하는가 fork() : 부모와 완전히 독립된, 새로운 pid를 갖는 자식 프로세스 생성 exec() : 프로세스의 메모리 영역을 덮어씌워 다른 프로세스로 변환 -&gt; 프로세스 유지를 위해 fork를 하여 자식에서 주로 사용된다. 3. 교착 상태 (Dead Lock) 교착 상태는 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생하며, 프로세스가 자원을 얻지 못해 작업을 수행하지 못하는 상태입니다. 3-1. 교착 상태의 4가지 조건 조건에는 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구하는 상호배제, 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다리는 점유대기, 자원의 사용이 끝날 때까지 자원을 가져올 수 없는 비선점, 순환적으로 다음 프로세스가 요구하는 자원을 갖는 순환대기가 있습니다. 해결 방법으로는 예방, 회피, 무시, 발견이 있습니다. 4. 메모리 계층 피라미드 구조로 위에서부터 레지스터 - 캐시 - 메모리 - 하드디스크의 구조를 가지고있습니다.이 구조는 CS 관점과, 경제성 관점에서 확립될 수 있습니다. 레지스터와 캐시는 CPU 내부에 존재하여 빠르게 접근이 가능하고, 메모리는 CPU 외부에 존재하여 비교적 느리게 접근합니다. 하드 디스크에는 CPU가 직접적으로 접근할 수 없습니다. 접근하기 위해서는 하드 디스크의 데이터를 메모리로 이동시켜서 접근가능한데 속도가 느립니다. 4-1. 메모리 계층왜 이렇게 구조화되어 있는가? 컴퓨터 과학계에서 증명된 ‘참조의 지역성’의 관점에서 자주 쓰일 거 같은 데이터를 하드디스크에서 메모리로, 메모리에서 캐시로 읽어 오는데, 이 크기는 점진적으로 작아진다. 비용적인 측면에서도 비싼 레지스터, 캐시는 필요한만큼의 크기만 사용하고, 저렴한 하드디스크는 넉넉하게 사용하여 피라미드 형태로 나타난다. 4-2. 캐시가 존재하는 이유메인메모리와 프로세서 간의 시간적, 공간적 차이가 나기 때문에, 캐시를 사용하여 자주 쓰고 인접한 데이터를 빠르게 처리한다.","link":"/10/14/0-interview-os/"},{"title":"가상 메모리, 페이징, 세그멘테이션, 뮤텍스, 세마포어","text":"8. 가상 메모리란? 메모리에 로드되어 실행 중인 프로세스가 사용하고 있지 않은 페이지를추상화된 가상 메모리 공간에 저장하고, 필요할 때 참조함으로써,메모리의 효율성을 높여주는 OS의 메모리 관리 기법 8-1. 가상 메모리의 주요 기능주기억장치를 하드디스크에 대한 캐시로 설정하고, 필요한 페이지만 유지하여 효율적으로 관리하고, 프로세스 별로 통일된 가상 메모리 주소 공간을 할당해줘서 메모리 관리가 단순해지고, 거의 무한에 가까운 가상 메모리 공간을 배정하여 프로세스들끼리의 메모리 침범 발생률을 크게 줄인다. 8-2. 가상 메모리와 관련된 하드웨어에 대해 말씀해주세요.MMU(Memory Management Unit)과 TLB(Translation Lookaside Buffer) MMU(메모리 관리 장치) 가상 메모리 주소를 물리 메모리 주소로 변환해주는 하드웨어 (CPU가 메모리에 접근하는 것을 관리)TLB(변환 참조 버퍼) 변환 작업의 속도를 높이기 위해 사용되는 Cache (보조 기억장치) 9. 페이징과 세그멘테이션이란? 페이징 메모리 공간 일정한 크기의 블록인 페이지로 나누어 관리하는 기법 페이징을 사용하기 위해 주소의 동적 재배치를 허용하고, 메모리 주소 변환을 위한 MMU가 필요하다 외부 단편화를 줄일 수 있지만, 페이지가 커질 수록 내부 단편화가 발생한다. 세그멘테이션 사용자 관점에서의 메모리 관리 기법 페이징은 일정한 크기의 블록으로 미리 공간을 나눠놓지만,세그멘테이션은 메모리를 사용하는 시점에 논리적 내용 단위인 세그먼트로 나눈다. 동적으로 할당하는 방식이므로 외부 단편화가 발생할 수 있다. 9-1. 페이지나 세그먼트가 메모리에 할당되는 방법페이지, 세그먼트 테이블에 접근하여 필요한 가상 메모리주소를 MMU가 가상 주소를 물리주소로 변환시켜줍니다. 9-2. 단편화를 해결할 수 있는 방법세그먼트를 페이징하는 방법을 취하면 해결할 수 있지만, 두 가지 테이블을 모두 거쳐야 하므로 속도가 떨어진다는 단점이 있다. 10. 뮤텍스와 세마포어란? 차이점은? 뮤텍스 (상호배제) Critical Section에 단 하나의 스레드만 접근할 수 있고, 이 스레드가 빠져나올 때 까지 해당 section에 대한 다른 스레드의 접근을 막고 대기시키는 것 세마포어 사전에 허용치를 설정하여, 이 허용치만큼만 동시에 접근이 가능한 방식 스레드가 접근할 때마다 count가 하나씩 줄어들게 되고, 0이 되면 접근을 대기 시킨다. 차이점 세마포어를 허용치를 1로 설정하면 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다. 세마포어는 소유가 불가능하지만, 뮤텍스는 소유가 가능하다. 뮤텍스는 프로세스 범위, 세마포어는 파일시스템 상 파일로 존재 뮤텍스는 소유하고 있는 쓰레드만 해제 가능, 세마포어는 다른 스레드가 해제 가능 10-1. 뮤텍스의 소유권뮤텍스는 신호, 비신호 상태를 가지는데, 이 뮤텍스를 소유하게 되면 비신호 상태가 됩니다.뮤텍스를 생성할 때 어떤 스레드가 소유할 것인지 결정하고, 아무도 소유하지 않으면 신호상태로 기다리게 됩니다.","link":"/10/28/0-interview-os2/"},{"title":"Class 클래스","text":"Class 클래스 사용하기 자바의 모든 클래스와 인터페이스는 컴파일 후 class파일이 생성된다. 클래스 내의 메서드, 생성자 배열 등 모든 정보가 들어있다. 컴파일 된 class 파일을 로드하여 객체를 동적으로 로드하고, 정보를 가져오는 메서드가 제공된다. 클래스 동적 로딩Class.forName(“클래스 이름”) Class c = Class.forName(&quot;java.lang.String&quot;) 동적 로딩 일반적으로 Class가 Local에 있는지 살펴보고 binding되어 type으로 정의하여 변수가 사용된다. Compile 할 때가 아닌, 실질적으로 실행할 때 필요한 클래스를 binding하는 방법 ex) JDBC 드라이버에서 실행 전까지 DB의 라이브러리가 어떤 것인지 모르고, property파일 등을 읽을 때 변수로 갖고 있다가 Oracle 드라이버 이름을 String변수에 넣어준다. 장점 : 동적으로 원하는 클래스를 로딩할 수 있다. 단점 : 로딩할 때 Local에 class나 라이브러리가 없는 등 오류가 발생하면 시스템이 다운될 수 있다. 사용 방법 주로 remote에 있는 class를 호출할 때 사용한다. Local에 클래스가 없을 때 아래 코드를 reflection 프로그래밍이라고 한다. 예제 코드 확인하기 1234567891011121314151617181920212223package ch04;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class StringTest { public static void main(String[] args) throws ClassNotFoundException { Class c = Class.forName(&quot;java.lang.String&quot;); // Constructor의 목록을 배열로 가져온다. Constructor[] cons = c.getConstructors(); for (Constructor co : cons) { System.out.println(co); } // 메소드의 목록을 가져온다. Method[] m = c.getMethods(); for (Method mth : m) { System.out.println(mth); } }} 인스턴스 생성 reflection 프로그래밍 Class 클래스를 사용하여 클래스의 정보 등을 알 수 있고, 인스턴스를 생성, 메서드를 호출하는 방식의 프로그래밍 로컬 메모리에 객체가 없는 경우 원격 프로그래밍 (서로 다른 프로세스) 객체의 타입을 알 수 없는 경우 java.lang.reflect 패키지의 클래스를 활용하여 사용 자료형을 알고 있는 경우에는 사용하지 않음 예제 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536package ch04;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public class ClassTest { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { // 1. Class 이름으로 invoke(호출)하기 Class c1 = Class.forName(&quot;ch04.Person&quot;); // Person 타입으로 Casting Person person = (Person)c1.newInstance(); person.setName(&quot;Lee&quot;); System.out.println(person); // 2. 이미 생성된 객체로 invoke Class c2 = person.getClass(); // 2-1. 인스턴스화, Person타입으로 Casting Person person2 = (Person)c2.newInstance(); person2.setName(&quot;Kim&quot;); System.out.println(person2); // 3. 생성자를 호출하여 객체 생성 Class[] classArray = {String.class}; Constructor cons = c2.getConstructor(classArray); // 3-1. Object 배열 형태 Object[] initargs = {&quot;Jeong&quot;}; // Line23에서 불러온 생성자로 객체 생성 Person person3 = (Person)cons.newInstance(initargs); System.out.println(person3); }}","link":"/08/19/Class/"},{"title":"Race Condition, System call, Sub-routine","text":"14. Race Condition이란? 두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 자원에 대한 접근 순서에 따라 결과가 달라지는 상황입니다. Race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없습니다. Mutax나 Critical section을 설정함으로 해결할 수 있다. 14-1. Dead Lock(교착 상태)과 Race Condition(경쟁 상태)의 차이 Dead Lock은 시스템적으로 한정된 자원을 여러 곳에서 사용하려 할 때, 프로세스가 자원을 얻지 못하여 작업을 수행하지 못하는 상태이고, Race condition은 공통 자원을 병행적으로 읽고 쓸 때, 접근 순서에 따라 결과가 달라지는 상황입니다. 14-2. Race Condition에서 발생하는 직면하는 문제 상황 교착상태 : 시스템적으로 한정된 자원을 여러 곳에서 사용하려 할 때, 프로세스가 자원을 얻지 못하여 작업을 수행하지 못하는 상태 Mutex, Semaphore 등을 통해 해결할 수 있다.기아상태 : 스레드들에게 우선 순위를 부여하여 공유 자원에 접근할 때, 우선순위가 낮은 스레드가 소외되어 아무일도 하지 못하는 상태 Bounded waiting을 통해 해결 15. 시스템 콜과 서브 루틴의 차이 서브 루틴은 개발자가 사용하는 대부분의 API이고, 이를 통해 OS와 통신할 수 있는 API인 시스템 콜을 호출합니다. 시스템 콜 호출 시에 커널이 호출되고, 커널이 수행한 결과를 역순으로 보냅니다. 커널 : 하드웨어를 제어하기 위한 일종의 API 서브루틴 : 프로그래밍 시 사용하는 대부분의 API 15-1. 시스템 콜의 유형에 대한 설명 프로세스 제어 프로세스를 생성하여 CPU에 프로세스를 적재하거나, 중지시키고, 메모리 할당 및 해제 등 파일 조작 open, close, read, write, create, delete 등 장치 관리 I/O 작업, 논리적 부착 및 분리 등 정보 유지 시간, 날짜, 시스템 데이터의 설정, 획득 등 통신 상태 정보 전달, 메세지의 송수신 등","link":"/11/11/0-interview-os5/"},{"title":"자바 배열 구현","text":"Array 구현 jdk 클래스 : ArrayList, Vector구현 함수 배열은 크기를 미리 정해주어야 한다. ARRAY_SIZE = 배열의 크기 count = 배열 내 요소 개수 addElement = 요소 추가 함수 insertElement = 요소 삽입 함수 removeElement = 요소 제거 함수 getSize = 배열의 크기 getElement = 검색 함수 printAll = 모든 요소 출력 removeAll = 모든 요소 삭제 예제코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class Test { int[] intArr; int count; public int ARRAY_SIZE; public static final int ERROR_NUM = -999999999; public Test() { count = 0; ARRAY_SIZE = 10; intArr = new int[ARRAY_SIZE]; } public Test(int size) { count = 0; ARRAY_SIZE = size; intArr = new int[ARRAY_SIZE]; } public void addElement(int num) { if (count &gt;= ARRAY_SIZE) { System.out.println(&quot;Not enough Memory&quot;); return; } intArr[count++] = num; } public void insertElement(int index, int num) { int i = count - 1; if (count &gt;= ARRAY_SIZE) { System.out.println(&quot;Not enough Memory&quot;); return; } if (index &lt; 0 || index &gt; count) { System.out.println(&quot;Insert Error&quot;); return; } while (i &gt; index) { intArr[i + 1] = intArr[i]; i--; } intArr[index] = num; count++; } public int removeElement(int index) { int ret = ERROR_NUM; if (isEmpty()) { System.out.println(&quot;There is no element&quot;); return ret; } if (index &lt; 0 || index &gt;= count){ System.out.println(&quot;index Error&quot;); return ret; } ret = intArr[index]; for (int i = index; i&lt;count-1; i++){ intArr[i] = intArr[i+1]; } count--; return ret; } private boolean isEmpty() { if (count == 0) { return true; } else return false; } public int getSize(){ return count; } public int getElement(int index){ if (index &lt; 0 || index &gt; count-1){ System.out.println(&quot;검색 위치 오류입니다. 현재 리스트의 개수는 &quot; + count + &quot;입니다.&quot;); return ERROR_NUM; } return intArr[index]; } public void printAll(){ if (count == 0) { System.out.println(&quot;출력할 값이 없습니다.&quot;); return; } for (int i = 0 ; i &lt; count; i++){ System.out.println(intArr[i]); } } public void removeAll(){ for (int i = 0; i &lt; count; i++){ intArr[i] = 0; } count = 0; }}","link":"/08/20/JavaArray/"},{"title":"자바의 클래스","text":"Java의 유용한 클래스들Object Class 모든 클래스의 최상위 클래스 모든 class는 Object클래스를 상속받는다. 메서드 중 일부는 필요에 의해 재정의 할 수 있다. java.lang 패키지 안에 포함되어 있다. java.lang 프로그래밍 시 자동으로 import된다 많이 사용하는 기본 클래스들이 속한 패키지 String, Integer, System 등 toString() 메서드 객체의 정보를 String으로 바꾸어서 사용할 때 쓰인다. 재정의하여 참조변수가 멤버 변수 값을 return하게 할 수 있다. 예제 코드 확인하기 1234567891011121314151617181920212223class Book{ private String title; private String author; public Book(String title, String author){ this.title = title; this.author = author; } @Override public String toString() { return title + &quot;,&quot; + author; }}public class BookTest {public static void main(String[] args){Book book = new Book(&quot;데미안&quot;, &quot;헤르만 헤세&quot;);System.out.println(book);}} equals(), hashCode() 메서드 equals() 메서드와 hashCode() 메서드는 짝을 이룬다. equals()를 overriding하면 객체가 반환하는 hash값도 overriding해줘야 한다. equals에서 사용한 멤버 변수를 hashCode 값으로 반환해주면 된다. equals() 메서드 두 인스턴스의 주소 값을 비교하여 true/false를 반환 인스턴스가 다르더라도 논리적으로 동일한 경우 true를 반환하도록 재정의 할 수 있다. 두 객체가 논리적으로 같다라고 하면 반환하는 Hash Code 값이 같아야한다. Java에서 주소 값은 Hash Code(해쉬 값)이라고 한다. heap 메모리를 관리하는 방식이 Hash방식이다. hashCode() 메서드 인스턴스의 저장 주소를 반환한다. hash : 정보를 저장, 검색하는 자료 구조 자료의 특정 값(key)에 대한 저장 위치를 반환해주는 hash함수를 사용한다. index(저장위치) = hash(key) Overriding 코드 확인하기 12345678910111213141516171819202122232425262728293031323334package ch02;public class Student {private int studentNum;private String studentName; public Student(int StudentNum, String studentName){ this.studentNum = studentNum; this.studentName = studentName; } @Override public String toString(){ return studentNum + &quot;,&quot; + studentName; } @Override public boolean equals(Object obj) { if (obj instanceof Student) { // 다운캐스팅 Student std = (Student)obj; if (this.studentNum == std.studentNum){ return true; } } return false; } @Override public int hashCode() { return studentNum; }} 예제 코드 확인하기 1234567891011121314151617181920package ch02;public class EqualsTest {public static void main(String[] args){ Student std1 = new Student(200, &quot;Lee&quot;); Student std2 = new Student(200, &quot;Lee&quot;); System.out.println(std1==std2); //false System.out.println(std1.equals(std2)); //true // hashCode() 가 studentNum을 return하도록 overriding하였음. System.out.println(std1.hashCode()); System.out.println(std2.hashCode()); // 원래 hashCode값 출력하는 방법 System.out.println(System.identityHashCode(std1)); System.out.println(System.identityHashCode(std2)); }} clone() 메서드 객체를 생성자를 통해 생성할 때, clone()을 사용하면 원본 객체와 원본을 복제하는데 사용한다. 생성자 : 초기값을 가지고 생성이 된다. clone() : 중간에 멤버변수가 변하면 변한 값을 그대로 복제한다. private까지 모두 복제가 되어 객체 보호의 관점에서 위배할 수 있다. 명시적으로 clone() 메서드의 사용을 허용한다는 의미로 Cloneable interface를 명시해준다. public class A implements Cloneable {~} A 클래스 내에서 clone() 메서드를 Override한다.1234@Overrideprotected Object clone() throws CloneNotSupportedException {return super.clone();} 클론 코드 Student copyStd = (Student)std1.clone();","link":"/08/19/JavaClasses/"},{"title":"내부 클래스","text":"내부 클래스종류인스턴스(instance) 내부 클래스 인스턴스 변수와 생성 위치, 방법, Scope가 동일하다. 내부적으로 사용할 클래스를 선언 (private으로 선언하는 것을 권장) 외부 클래스가 생성된 후 생성됨 private이 아닌 내부 클래스는 다른 외부 클래스에서 생성할 수 있다. 문법적으로는 가능하지만 잘 사용하지 않는다. 예제 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839package ch01;class OutClass{ private int num = 10; private static int sNum = 20; private InClass inClass; public OutClass(){ inClass = new InClass(); } class InClass{ int iNum = 100; void inTest() { System.out.println(&quot;OutClass num = &quot; +num + &quot;(외부 클래스의 인스턴스 변수)&quot;); System.out.println(&quot;OutClass sNum = &quot; + sNum + &quot;(외부 클래스의 스태틱 변수)&quot;); System.out.println(&quot;InClass inNum = &quot; + iNum + &quot;(내부 클래스의 인스턴스 변수)&quot;); } } public void usingClass(){ inClass.inTest(); }}public class InnerTest { public static void main(String[] args) { OutClass outClass = new OutClass(); outClass.usingClass(); System.out.println(&quot;=========&quot;); OutClass.InClass inner = outClass.new InClass(); inner.inTest(); }} 정적(static) 내부 클래스 정적 변수와 정적 메서드를 사용한다. 내부 클래스의 인스턴스, 스태틱 변수, 외부 클래스의 스태틱 변수를 사용할 수 있다. 외부 클래스 생성과 무관하게 사용할 수 있다. 외부 클래스가 생성되지 않아도 사용할 수 있기 때문에 정적 내부 클래스에서 외부 클래스의 인스턴스 변수를 사용할 수 없다. 정적 내부 클래스의 정적 메서드는 스태틱 변수만 사용할 수 있다. 예제 코드 확인하기 123456789101112131415static class InStaticClass{ int iNum = 100; static int sInNum = 200; void inTest() { System.out.println(&quot;inClass num = &quot; +iNum + &quot;(외부 클래스의 인스턴스 변수)&quot;); System.out.println(&quot;OutClass sNum = &quot; + sNum + &quot;(외부 클래스의 스태틱 변수)&quot;); System.out.println(&quot;InClass inNum = &quot; + sInNum + &quot;(내부 클래스의 인스턴스 변수)&quot;); } static void sTest(){ System.out.println(&quot;OutClass sNum = &quot; + sNum + &quot;(외부 클래스의 스태틱 변수)&quot;); System.out.println(&quot;InClass inNum = &quot; + sInNum + &quot;(내부 클래스의 인스턴스 변수)&quot;); } } 지역(local) 내부 클래스 지역 변수와 같이 메서드 내부에서 정의하여 사용한다. 메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라짐 메서드 호출 이후 반환이 되어도 메서드의 지역 변수를 클래스를 통해 사용할 수 있으므로 final로 처리한다. 예제 코드 확인하기 1234567891011121314151617181920212223242526272829303132333435363738class Outer2{ int outNum = 100; static int sNum = 200; // 메서드 Runnable getRunnable(final int i){ final int num = 10; // 지역 내부 클래스 class MyRunnable implements Runnable{ int localNum = 1000; // 재정의 @Override public void run() { System.out.println(&quot;i =&quot; + i); System.out.println(&quot;num = &quot; +num); System.out.println(&quot;localNum = &quot; +localNum); System.out.println(&quot;outNum = &quot; + outNum + &quot;(외부 클래스 인스턴스 변수)&quot;); System.out.println(&quot;Outter.sNum = &quot; + Outer2.sNum + &quot;(외부 클래스 정적 변수)&quot;); } } return new MyRunnable(); }}public class AnonymousInnerTest { public static void main(String[] args) { Outer2 out = new Outer2(); // 메서드가 Runnable한 값을 runner에 return해주고 해제되었다. Runnable runner = out.getRunnable(100); // 해제된 이후 지역 내부 클래스의 메서드 사용 // final로 선언해주었기 때문에 runner.run(); }} 익명(Anonymous) 내부 클래스 이름이 없는 클래스 지역 내부 클래스의 예시코드에서 클래스 이름 MyRunnable은 실제로 호출되지 않으므로 이를 생략한다. 하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환한다. 예제 코드 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package ch01;class Outer2{ int outNum = 100; static int sNum = 200; // 메서드 Runnable getRunnable(final int i){ final int num = 10; // 익명 내부 클래스 (바로 return값을 입력) return new Runnable(){ int localNum = 1000; // 재정의 @Override public void run() { System.out.println(&quot;i =&quot; + i); System.out.println(&quot;num = &quot; +num); System.out.println(&quot;localNum = &quot; +localNum); System.out.println(&quot;outNum = &quot; + outNum + &quot;(외부 클래스 인스턴스 변수)&quot;); System.out.println(&quot;Outter.sNum = &quot; + Outer2.sNum + &quot;(외부 클래스 정적 변수)&quot;); } }; } // runnable을 생성해서 바로 구현 Runnable runnable = new Runnable() { @Override public void run() { System.out.println(&quot;Runnable class&quot;); } };}public class AnonymousInnerTest { public static void main(String[] args) { Outer2 out = new Outer2(); Runnable runner = out.getRunnable(100); runner.run(); out.runnable.run(); }}","link":"/08/24/InnerClass/"},{"title":"예외처리","text":"예외처리 (Exception)특징 Java에서 발생하는 문제는 오류(Error)와 예외(Exception)로 구분할 수 있다. 오류 (Error) 시스템 오류(Error) : 가상머신에서 발생하고, 개발자가 처리할 수 없는 오류 동적 메모리가 없는 경우, 스택 오버플로우 등 컴파일 오류 (Compile Error) 프로그램 코드 작성 중 발생하는 문법적인 오류 IDE에서 컴파일 오류를 detection할 수 있다. 실행 오류 (Runtime Error) 실행 중인 프로그램이 중단되거나 의도하지 않은 동작(bug)을 하는 오류 예외 (Exception) 프로그램에서 제어할 수 있는 오류 DB, Network Connection 등 중요성 프로그램의 비정상적인 종료를 피할 수 있다. log를 적절하게 남기고, 분석을 통해 원인을 파악하고 bug를 수정하여야 한다. 상세하게 level별로 남겨야한다. 예외 클래스 https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html 예외 처리try-catch문12345try{ 예외가 발생할 수 있는 코드} catch (처리할 예외 타입) { try 블록 안에서 예외가 발생했을 때 예외처리 코드} 예제코드 확인하기 12345678910111213141516171819package ch08;public class ArrayindexExceptionTest { public static void main(String[] args) { int[] arr = {1,2,3,4,5}; try{ for (int i = 0 ; i &lt;=5 ; i++){ System.out.println(arr[i]); } } catch(ArrayIndexOutOfBoundsException e){ System.out.println(e.getMessage()); System.out.println(e.toString()); } }} try-catch-finally문 try()블럭이 수행되면 finally() 블럭은 항상 수행된다. return이 포함되어 있어도 수행된다. 예제 코드 확인하기 123456789101112131415161718192021222324252627282930package ch08;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileExceptionHandling { public static void main(String[] args) { FileInputStream fis = null ; try { fis = new FileInputStream(&quot;a.txt&quot;); System.out.println(&quot;read&quot;); } catch (FileNotFoundException e) { System.out.println(e); return; } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } System.out.println(&quot;finally&quot;); } System.out.println(&quot;end&quot;); }} try-with-resource문 java7 이후로 FileInputStream클래스가 AutoCloseable 인터페이스를 implement하여 close를 하지 않아도 자동으로 해제된다. java9부터 리소스는 try() 외부에서 선언하고 try(var)와 같이 사용할 수 있다.1234FileInputStream fis = new FileInputStream(&quot;a.text&quot;);try(fis){...} 예제 코드 확인하기 12345678910111213141516171819202122package ch08;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileExceptionHandling { public static void main(String[] args) { // 자동으로 close가 된다. try (FileInputStream fis = new FileInputStream(&quot;a.txt&quot;)){ System.out.println(&quot;read&quot;); // file을 불러올 때 생길 수 있는 에러 } catch (FileNotFoundException e) { e.printStackTrace(); // file을 close할 때 생길 수 있는 에러 } catch (IOException e) { e.printStackTrace(); } System.out.println(&quot;end&quot;); }} 예외처리 미루기 main함수에서 throws를 하게되면 VM으로 넘어가서 abort된다. throws를 이용하여 예외를 발생시키는 문장에서 예외를 처리하게 미룰 수 있다. catch(Exception e) 구문을 통하여 default 처리를 할 수 있다. catch 구문 중 가장 아랫줄에 작성해야 다른 exception을 개별 처리할 수 있다. 예제 코드 확인하기 12345678910111213141516171819202122232425262728293031package ch08;import java.io.FileInputStream;import java.io.FileNotFoundException;public class ThrowsException { // throws하여 메서드를 사용할 때 Exception을 처리하도록 한다. public Class loadClass(String fileName, String className) throws ClassNotFoundException, FileNotFoundException { FileInputStream fis = new FileInputStream(fileName); Class c = Class.forName(className); return c; } public static void main(String[] args) { ThrowsException test = new ThrowsException(); try { test.loadClass(&quot;a.txt&quot;, &quot;abc&quot;); } catch (ClassNotFoundException e) { System.out.println(e); } catch (FileNotFoundException e) { System.out.println(e); } catch (Exception e) { System.out.println(&quot;default Exception&quot;); } System.out.println(&quot;end&quot;); }} 사용자 정의 예외클래스 자바에서 제공되는 exception 외 필요한 exception을 생성할 수 있다. 기존 클래스 중 가장 유사한 클래스를 상속을 받거나, Exception 클래스를 상속받는다. Exception을 정의하고, 필요한 순간에 어떠한 exception이 어느 순간에 불려야하는지 구현한다. throws 예외를 호출하는 메서드에게 전가하는 것 메서드에서 상위 메서드로 예외를 던진다. throw exception을 실제로 던지는 것 메서드 내에서 상위 블럭으로 예외를 던진다. Exception 정의하기 12345678package ch10;public class PassWordException extends Exception{ public PassWordException(String message){ super(message); }} 사용자 정의 Exception 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package ch10;public class PassWordTest { private String password; public String getPassword() { return password; } public void setPassword(String password) throws PassWordException { if(password == null) { throw new PassWordException(&quot;비밀번호는 null이 될 수 없습니다.&quot;); } else if (password.length() &lt; 5 ) { throw new PassWordException(&quot;비밀번호는 5자 이상이어야 합니다..&quot;); } else if (password.matches(&quot;[a-zA-Z]+&quot;)){ throw new PassWordException(&quot;비밀번호는 숫자나 특수문자를 포함해야 합니다.&quot;); } this.password = password; } public static void main(String[] args) { PassWordTest test = new PassWordTest(); String password = null; try { test.setPassword(password); System.out.println(&quot;오류없음1&quot;); } catch (PassWordException e) { System.out.println(e.getMessage()); } password = &quot;abc&quot;; try { test.setPassword(password); System.out.println(&quot;오류없음2&quot;); } catch (PassWordException e) { System.out.println(e.getMessage()); } password = &quot;abcde&quot;; try { test.setPassword(password); System.out.println(&quot;오류없음3&quot;); } catch (PassWordException e) { System.out.println(e.getMessage()); } password = &quot;abcde1#&quot;; try { test.setPassword(password); System.out.println(&quot;오류없음4&quot;); } catch (PassWordException e) { System.out.println(e.getMessage()); } }}","link":"/08/25/Exception/"},{"title":"String 관련 Class","text":"String 관련 ClassString 클래스선언 String str = new String(“abc”); 힙 메모리에 생성된다. String str2 = “abc”; 상수 pool의 abc라는 String에 address가 생성된다. 두 개의 인스턴스는 다르다. 힙 메모리는 생성될 때마다 다른 주소값을 가지지만, 상수 pool의 문자열은 모두 같은 주소를 가진다. 메모리 한번 생성된 String은 immutable(불변)이다. String을 연결하면 기존의 String에 연결되는 것이 아닌 새로운 문자열을 위한 메모리가 생성된다. 예제 코드 확인하기 12345678String java = new String(“java”); String android = new String(“android”); java = java.concat(android) // 위 2가지 문자열을 합해주고 java가 가리키게 한다.// 문자열 java, android, javaandroid을 위한 메모리가 계속해서 할당되어 있고, java는 “java”가 아닌 “javaandroid”를 가리킨다.// 기존 메모리에 덮어쓰는 것이 아닌 새로운 메모리를 할당한다. StringBuilder, StringBuffer 위 메모리 낭비를 해결하기 위해 StringBuilder, StringBuffer를 활용한다. 내부적으로 가변적인 char[]를 멤버 변수를 가진다. 새로운 인스턴스를 생성하지 않고, char[]를 변경한다. 문자열을 연결, 변경할 때 유용하게 사용할 수 있다.차이점 StringBuilder : 단일 쓰레드에서 사용한다. StringBuffer : 멀티 쓰레드 프로그래밍에서 동기화를 보장한다. 두 개 이상의 쓰레드가 같은 메모리에 접근할 때 순서를 가지게 된다. 예제 코드 확인하기 12345678910111213141516171819package ch03;public class StringBuilderTest {public static void main(String[] args) {String java = new String(&quot;java&quot;);String android = new String(&quot;android&quot;); // 매개변수로 String을 받는다. StringBuilder buffer = new StringBuilder(java); System.out.println(System.identityHashCode(buffer)); // 문자열을 추가, 변경해도 메모리값은 변하지 않는다. buffer.append(android); System.out.println(System.identityHashCode(buffer)); System.out.println(buffer.toString()); }} Text Block 사용하기 Java 13 이상부터 제공한다. 하나의 string을 연결해서 사용할 때 사용한다. 서블릿 등 서버사이드에서 클라이언트 쪽으로 데이터를 html, json 프로토콜로 요청할 때 유용하다. “”” “”” 안에 string을 넣어 사용한다. 예제 코드 확인하기 1234567891011121314package ch03;public class TextBlockTest {public static void main(String[] args) { String textBlocks = &quot;&quot;&quot; Hello, hi, how r u &quot;&quot;&quot;; System.out.println(textBlocks); }}","link":"/08/19/String/"},{"title":"스트림","text":"스트림 (Stream)특징 배열, collection 자료가 모여있을 때 연산의 처리를 일관성 있게 한다. 자료 처리에 대한 추상화가 구현되었다고 한다. 일관성 있는 연산으로 자료의 처리를 쉽고 간단하게 한다. 한번 생성하고 사용한 스트림은 재사용 할 수 없다. 다른 연산을 수행하기 위해서는 스트림을 다시 생성해야 한다. 123456789101112131415161718192021222324package ch06;import java.util.Arrays;import java.util.stream.IntStream;public class IntArrayStreamTest { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; for (int num : arr) { System.out.println(num); } System.out.println(&quot;========&quot;); // 모든 Array는 Arrays 클래스를 활용할 수 있다. IntStream is = Arrays.stream(arr); is.forEach(n -&gt; System.out.println(n)); //is는 한번 소모하였으니 다시 사용할 수 없다. // 재사용하고 싶을 때 재생성 int sum = Arrays.stream(arr).sum(); System.out.println(sum); }} 연산 스트림의 연산은 중간 연산과 최종 연산으로 구분된다. 중간 연산은 여러 개의 연산이 적용될 수 있지만 최종 연산은 마지마게 한 번만 적용된다. 지연 연산 최종 연산이 호출되어야 중간 연산에 대한 수행이 이루어지고 결과가 만들어진다. 중간연산 filter() : 조건에 맞는 요소를 추출 map() : 조건에 맞는 요소를 변환 sorted() : 정렬 최종연산 forEach() : 요소를 하나씩 꺼내옴 count() : 요소의 개수 반환 sum() : 요소들의 합 예제 코드 확인하기 1234567891011121314151617181920212223242526272829303132package ch06;import java.util.ArrayList;import java.util.List;import java.util.stream.Stream;public class ArrayListStreamTest { public static void main(String[] args) { List&lt;String&gt; sList = new ArrayList&lt;String&gt;(); sList.add(&quot;Thomas&quot;); sList.add(&quot;Edward&quot;); sList.add(&quot;Jack&quot;); Stream&lt;String&gt; stream = sList.stream(); stream.forEach(s-&gt;System.out.println(s)); sList.stream().sorted().forEach(s-&gt;System.out.print(s + &quot;\\t&quot;)); System.out.println(); sList.stream().map(s-&gt;s.length()).forEach(n-&gt;System.out.print(n + &quot;\\t&quot;)); System.out.println(); sList.stream().filter(s-&gt;s.length()&gt;=5).forEach(s-&gt;System.out.print(s + &quot;\\t&quot;)); }}// 결과//Thomas//Edward//Jack//Edward Jack Thomas//6 6 4//Thomas Edward","link":"/08/25/Stream/"},{"title":"reduce 메서드","text":"reduce 메서드reduce() 연산 기존에 정의된 연산이 아닌 직접 구현한 연산을 적용한다.1T reduce(T identify, BinaryOperator&lt;T&gt; accumulator) 최종 연산으로 스트림을 요소를 소모하여 연산을 수행한다. 예시123456789101112131415161718192021222324252627282930313233343536package ch06;import java.util.Arrays;import java.util.function.BinaryOperator;// parameter BinaryOperator&lt;T&gt;를 구현하여 사용class CompareString implements BinaryOperator&lt;String&gt;{ @Override public String apply(String s1, String s2) { if (s1.getBytes().length &gt;= s2.getBytes().length) return s1; else return s2; }}public class ReduceTest { public static void main(String[] args) { String greetings[] = {&quot;안녕히계세요~~~&quot;, &quot;hello&quot;, &quot;Goood morning&quot;, &quot;반갑습니다&quot;}; // 1. 직접 작성 System.out.println(Arrays.stream(greetings).reduce(&quot;&quot;, (s1,s2)-&gt; {if (s1.getBytes().length &gt;= s2.getBytes().length) return s1; else return s2;} )); // 2. BinaryOperator&lt;T&gt;의 메서드 implement // 새로운 클래스로 생성하여 사용한다. String str = Arrays.stream(greetings).reduce(new CompareString()).get(); System.out.println(str); }}","link":"/08/25/reduce/"},{"title":"로그 (Log)","text":"Log (로그)Logging 시스템 운영에 대한 기록 오류가 발생했을 때 오류에 대한 기록을 남겨 디버깅을 용이하게 할 수 있다. java.util.logging.Logger 활용 Exception을 handling할 때 로그를 남겨주어야 한다. Log가 너무 많으면 빈번한 file 입출력의 오버헤드 및 백업 문제 등이 발생할 수 있다. 레벨 severe warning info config fine finer finest 사용 처음 System을 오픈할 때는 모든 level을 찍고, 안정화된 후에 info level부터 찍는 등 다양한 방법이 있다. logger의 level을 ALL로 설정하면 다른 FileHandler는 모든 범위 내에서 설정이 가능하다. 같은 패키지 내에 로그 파일이 저장된다. 예제코드1 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package Online;import java.io.IOException;import java.util.logging.FileHandler;import java.util.logging.Level;import java.util.logging.Logger;import java.util.logging.SimpleFormatter;public class MyLog { // 1. Singleton과 유사하게 인스턴스 생성 Logger logger = Logger.getLogger(&quot;mylogger&quot;); private static MyLog instance = new MyLog(); // 2. 파일 이름 설정 public static final String errorLog = &quot;log.txt&quot;; public static final String warningLog = &quot;warning.txt&quot;; public static final String fineLog = &quot;fine.txt&quot;; // 3. 위 파일별 log를 설정할 FileHandler 객체 생성 // 객체명은 오류 레벨과 맞춰서 설정하였음 private FileHandler logFile = null; private FileHandler warningFile = null; private FileHandler fineFile = null; // 4. 생성자 구현 private MyLog(){ try { // 4-1. 인스턴스 생성 (파일이름, append 여부) logFile = new FileHandler(errorLog, true); warningFile = new FileHandler(warningLog, true); fineFile = new FileHandler(fineLog, true); } catch (IOException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } // 4-2. Log기록의 형식 지정 (SimpleFormatter : 기본 형식) logFile.setFormatter(new SimpleFormatter()); warningFile.setFormatter(new SimpleFormatter()); fineFile.setFormatter(new SimpleFormatter()); // 4-3. 로그 레벨 설정 // 모든 로그 레벨 기록 logger.setLevel(Level.ALL); // FileHandler마다 레벨을 다르게 설정할 수 있다. warningFile.setLevel(Level.WARNING); fineFile.setLevel(Level.FINE);; // 4-4. 4-1에서 생성한 Handler 추가 logger.addHandler(logFile); logger.addHandler(warningFile); logger.addHandler(fineFile); } // 4-5. getter 생성 public static MyLog getLog() { return instance; } // 5. 로그 기록 남기는 함수 // logger에 설정한 레벨에 해당하는 log만 사용가능 public void log(String msg){ // logger가 finest level을 handle 할 수 있도록 addHandler를 해주었으므로 가능하다. logger.finest(msg); logger.finer(msg); logger.fine(msg); logger.config(msg); logger.info(msg); logger.warning(msg); logger.severe(msg); } // 5-1. fine level 메세지 출력함수 public void fine(String msg){ logger.fine(msg); } // 5-2. warning level 메시지 출력함수 public void warning(String msg){ logger.warning(msg); }} logger의 level을 INFO로 설정하면 다른 FileHandler는 INFO 내에서 설정이 가능하다. FileHandler 중 fineFile은 범위를 fine부터 설정하였지만 INFO 범위 내에 포함되지 않으므로 INFO 레벨부터 로그가 기록된다. 예제코드2 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package Online;import java.io.IOException;import java.util.logging.FileHandler;import java.util.logging.Level;import java.util.logging.Logger;import java.util.logging.SimpleFormatter;public class MyLog { // 1. Singleton과 유사하게 인스턴스 생성 Logger logger = Logger.getLogger(&quot;mylogger&quot;); private static MyLog instance = new MyLog(); // 2. 파일 이름 설정 public static final String errorLog = &quot;log.txt&quot;; public static final String warningLog = &quot;warning.txt&quot;; public static final String fineLog = &quot;fine.txt&quot;; // 3. 위 파일별 log를 설정할 FileHandler 객체 생성 // 객체명은 오류 레벨과 맞춰서 설정하였음 private FileHandler logFile = null; private FileHandler warningFile = null; private FileHandler fineFile = null; // 4. 생성자 구현 private MyLog(){ try { // 4-1. 인스턴스 생성 (파일이름, append 여부) logFile = new FileHandler(errorLog, true); warningFile = new FileHandler(warningLog, true); fineFile = new FileHandler(fineLog, true); } catch (IOException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } // 4-2. Log기록의 형식 지정 (SimpleFormatter : 기본 형식) logFile.setFormatter(new SimpleFormatter()); warningFile.setFormatter(new SimpleFormatter()); fineFile.setFormatter(new SimpleFormatter()); // 4-3. 로그 레벨 설정 // 모든 로그 레벨 기록 logger.setLevel(Level.INFO); // FileHandler마다 레벨을 다르게 설정할 수 있다. warningFile.setLevel(Level.WARNING); fineFile.setLevel(Level.FINE);; // 4-4. 4-1에서 생성한 Handler 추가 logger.addHandler(logFile); logger.addHandler(warningFile); logger.addHandler(fineFile); } // 4-5. getter 생성 public static MyLog getLog() { return instance; } // 5. 로그 기록 남기는 함수 // logger에 설정한 레벨에 해당하는 log만 사용가능 public void log(String msg){ // logger가 finest level을 handle 할 수 있도록 addHandler를 해주었으므로 가능하다. logger.finest(msg); logger.finer(msg); logger.fine(msg); logger.config(msg); logger.info(msg); logger.warning(msg); logger.severe(msg); } // 5-1. fine level 메세지 출력함수 public void fine(String msg){ logger.fine(msg); } // 5-2. warning level 메시지 출력함수 public void warning(String msg){ logger.warning(msg); }} 테스트 코드 12345678910package Online;public class LogTest { public static void main(String[] args) { // Singleton으로 구현하였으므로 getLog를 통해서 호출 MyLog logger = MyLog.getLog(); logger.log(&quot;Log Test&quot;); }} 콘솔 파일은 Mac OS 기준으로 jre 내의 conf 폴더에 properties파일이 저장된다. 파일 내에서 정보 date, Thread Name 등을 설정할 수 있다. 콘솔 파일 내용 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364############################################################# Default Logging Configuration File## You can use a different file by specifying a filename# with the java.util.logging.config.file system property. # For example java -Djava.util.logging.config.file=myfile######################################################################################################################### Global properties############################################################# &quot;handlers&quot; specifies a comma separated list of log Handler # classes. These handlers will be installed during VM startup.# Note that these classes must be on the system classpath.# By default we only configure a ConsoleHandler, which will only# show messages at the INFO and above levels.handlers= java.util.logging.ConsoleHandler# To also add the FileHandler, use the following line instead.#handlers= java.util.logging.FileHandler, java.util.logging.ConsoleHandler# Default global logging level.# This specifies which kinds of events are logged across# all loggers. For any given facility this global level# can be overriden by a facility specific level# Note that the ConsoleHandler also has a separate level# setting to limit messages printed to the console..level= INFO############################################################# Handler specific properties.# Describes specific configuration info for Handlers.############################################################# default file output is in user's home directory.java.util.logging.FileHandler.pattern = %h/java%u.logjava.util.logging.FileHandler.limit = 50000java.util.logging.FileHandler.count = 1# Default number of locks FileHandler can obtain synchronously.# This specifies maximum number of attempts to obtain lock file by FileHandler# implemented by incrementing the unique field %u as per FileHandler API documentation.java.util.logging.FileHandler.maxLocks = 100java.util.logging.FileHandler.formatter = java.util.logging.XMLFormatter# Limit the message that are printed on the console to INFO and above.java.util.logging.ConsoleHandler.level = INFOjava.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter# Example to customize the SimpleFormatter output format # to print one-line log message like this:# &lt;level&gt;: &lt;log message&gt; [&lt;date/time&gt;]## java.util.logging.SimpleFormatter.format=%4$s: %5$s [%1$tc]%n############################################################# Facility specific properties.# Provides extra control for each logger.############################################################# For example, set the com.xyz.foo logger to only log SEVERE# messages:# com.xyz.foo.level = SEVERE Exception과 함께 사용 Exception 상황에서는 항상 적절한 level의 log를 남겨야한다. Custom Exception 코드 12345678package Online;public class StudentNameFormatException extends IllegalArgumentException{ public StudentNameFormatException(String message){ super(message); }} 예제 클래스 1234567891011121314151617181920212223package Online;public class Student { private String studentName; MyLog myLog = MyLog.getLog(); public Student(String studentName){ if (studentName == null){ throw new StudentNameFormatException(&quot;Name must not be null&quot;); } if (studentName.split(&quot; &quot;).length &gt; 3) { throw new StudentNameFormatException(&quot;너무 긴 이름입니다.&quot;); } this.studentName = studentName; } public String getStudentName(){ myLog.fine(&quot;begin getStudentName&quot;); return studentName; }} 생성자에는 Exception을 throws하지 않는다. Custom Exception의 extends에 Exception이 아닌 IllegalArgumentException을 extends하여 핸들링할 수 있다. 테스트 코드 확인하기 123456789101112131415161718192021222324package Online;public class StudentTest { public static void main(String[] args) { MyLog myLog = MyLog.getLog(); String name = null; // 1. 예외상황1 테스트 try { Student student = new Student(name); } catch (StudentNameFormatException e) { myLog.warning(e.getMessage()); } // 2. 예외상황2 테스트 try { Student student = new Student(&quot;Edward John Kim Test&quot;); } catch (StudentNameFormatException e) { myLog.warning(e.getMessage()); } Student student = new Student(&quot;James&quot;); }} 결과 확인하기 12348월 31, 2021 3:24:58 오후 Online.MyLog warningWARNING: Name must not be null8월 31, 2021 3:24:58 오후 Online.MyLog warningWARNING: 너무 긴 이름입니다.","link":"/08/31/Log/"},{"title":"클래스 프레임워크","text":"컬렉션 프레임워크특징 프로그램 구현에 필요한 자료구조를 구현해 놓은 JDK 라이브러리 java.util 패키지에 구현되어 있다. 종류Collection 인터페이스 하나의 요소를 관리할 때 사용한다. 하위에 List와 Set 인터페이스가 있다.Iterator 컬렉션 프레임워크에 저장된 요소를 하나씩 차례로 참조한다. List 인터페이스 : 순서가 정해져 있으므로 get(I)를 사용하여 참조 또한 가능하다. Set 인터페이스 : get(I) 메서드가 제공되지 않으므로 Iterator를 활용하여 객체를 순회한다. Iterator 함수를 호출하면 iterator가 반환이 된다. hasNext() : 이후에 요소가 더 있는지를 체크하는 메서드 E.next() : 다음에 있는 요소를 반환 구현 코드 확인하기 1234567891011Iterator&lt;Member&gt; ir = arrayList.iterator();while (ir.hasNext()){ Member member = ir.next(); int tempId = member.getMemberId(); if (tempId == memberId){ arrayList.remove(member); return true; }}System.out.println(memberId + &quot;가 존재하지 않습니다.&quot;);return false; List 객체를 순서에 따라 저장 및 관리할 때 필요한 메서드가 선언된 인터페이스 리스트 자료구조의 구현을 위한 인터페이스 객체의 중복을 허용한다. ArrayList, Vector, Queue, Stack, LinkedList 등 ArrayList 구현 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445package ch10;import java.util.ArrayList;public class MemberArrayList { private ArrayList&lt;Member&gt; arrayList; public MemberArrayList(){ arrayList = new ArrayList&lt;&gt;(); } public MemberArrayList(int size){ arrayList = new ArrayList&lt;&gt;(size); } public void addMember(Member member){ arrayList.add(member); } public boolean removeMember(int memberId){ // 중복이 가능하므로 어떤 요소를 삭제할 것인지 먼저 retrieve for (int i = 0; i &lt; arrayList.size(); i++){ Member member = arrayList.get(i); int tempId = member.getMemberId(); if (tempId == memberId){ arrayList.remove(i); return true; } } System.out.println(memberId + &quot;가 존재하지 않습니다.&quot;); return false; } public void showAllMember(){ for (Member i :arrayList){ System.out.println(i); } System.out.println(); }} Set 아이디, 주민번호, 사번 등 유일한 값들의 집합을 관리할 때 사용한다. 저정된 순서와 출력 순서가 달라질 수 있다. HashSet 검색을 위한 알고리즘인 Hash 방식으로 구성되어 있고, key 순서와 관계가 없다. 멤버의 중복 여부를 체크하기 위해 인스턴스의 동일성을 확인해야 한다. 동일성 구현을 위해 필요에 따라 equals()와 hashCode() 메서드를 재정의함 hashCode는 객체를 구분하기 위한 unique한 값을 return하게 해준다. Override 코드 확인하기 1234567891011121314151617@Override public int hashCode() { return memberId; } @Override public boolean equals(Object obj) { if (obj instanceof Member) { Member member = (Member)obj; if (this.memberId == member.memberId) { return true; } else return false; } return false; } TreeSet 객체의 정렬에 사용하는 클래스 (중복을 허용하지 않는다.) 내부적으로 Binary Search Tree가 구현이 되어있다. (In-order traversal) Java에서는 balance를 위해 레드-블랙 트리를 사용한다. 비교하기 위한 요소를 구현하여야한다. 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 정렬하기 위해 element를 추가할 때마다 어떻게 비교할 지 comparable, comparator인터페이스를 구현하여야한다. Comparable 코드 확인하기 123456789101112// Comparable 인터페이스를 implement하여 compareTo 메서드를 오버라이딩 public class Member implements Comparable&lt;Member&gt; { ... @Override public int compareTo(Member member) { // this = 삽입되는 값 // this가 크면 양수를 반환하여 오른쪽으로 이동하게 구현되어 있다. // 값이 같으면 (중복되면) 0을 반환하여 삽입되지 않는다. // 내림 차순은 양수, 음수를 바꿔주면 된다. return (this.memberId - member.memberId); }} Comparator 코드 확인하기 123456789101112131415161718192021// 1. Comparator 인터페이스를 implement하여 compare 메서드 오버라이딩.public class Member implements Comparator&lt;Member&gt; { ... @Override public int compare(Member o1, Member o2) { return (o1.memberId - o2.memberId); }}// 2. Comparator를 사용할 때// TreeSet의 constructor(생성자)에 comparator를 구현한 객체를 지정해주어야한다.public MemberTreeSet(){ treeSet = new TreeSet&lt;Member&gt;(new Member());}// 3. 객체에 default constructor가 있어야 사용할 수 있다.public Member(){} Comparator 활용하기 이미 Comparable이 구현된 경우 Comparator로 비교 로직을 다시 구현할 수 있음 String이 제공하는 compare 메서드는 오름차순으로 정렬이 된다. return값에 -1을 곱하여 내림차순으로 수정한다. 기존 코드 12345678TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;(); set.add(&quot;Park&quot;); set.add(&quot;Kim&quot;); set.add(&quot;Lee&quot;); System.out.println(set); // 결과 : [Kim, Lee, Park] Comparator 활용 코드 1234567891011121314151617// 기존 String 클래스의 class MyCompare implements Comparator&lt;String&gt;{ @Override public int compare(String o1, String o2) { return o1.compareTo(o2)*-1; }}// TreeSet을 생성할 때 매개변수로 Comparator를 정의한 클래스를 넣어준다.TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;(new MyCompare()); set.add(&quot;Park&quot;); set.add(&quot;Kim&quot;); set.add(&quot;Lee&quot;); System.out.println(set); Map Key와 value의 pair를 관리할 때 사용한다. Key값은 유일하여, 중복이 허용되지 않는다. HashMap Key를 이용하여 값을 저장하고, 값을 꺼내온다. key가 되는 객체는 중복될 수 없고, 객체의 유일성을 비교하기 위해 equals(), hashCode() 메서드를 구현하여야 한다. Key는 중복이 될 수 없으므로 Set과 같은 개념 Value는 중복이 될 수 있으므로 Collection과 같은 개념으로 보면 된다. 다른 키값이라도 hash함수를 통해 같은 index가 도출될 수 있다. Collision이 발생하며 오버헤드가 발생할 수 있다. Java에서는 hash table의 Load Balance를 약 75%로 산정하여, 이를 방지한다. 100개가 들어갈 수 있는 테이블에 약 75개의 데이터를 수용함 예제 코드 확인하기 1234567HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(1001, &quot;Kim&quot;); hashMap.put(1002, &quot;Lee&quot;); hashMap.put(1003, &quot;Park&quot;); hashMap.put(1004, &quot;Hong&quot;); System.out.println(hashMap); 새로운 객체 HashMap 생성 12345678910111213141516171819202122232425262728293031323334353637import java.util.HashMap;import java.util.Iterator;public class MemberHashMap { private HashMap&lt;Integer, Member&gt; hashMap; public MemberHashMap(){ hashMap = new HashMap&lt;&gt;(); } public void addMember(Member member){ hashMap.put(member.getMemberId(), member); } public boolean removeMember(int memberId){ if (hashMap.containsKey(memberId)){ hashMap.remove(memberId); } System.out.println(&quot;no element&quot;); return false; } public void showAll(){ Iterator&lt;Integer&gt; ir = hashMap.keySet().iterator(); while (ir.hasNext()){ int key = ir.next(); Member member = hashMap.get(key); System.out.println(member); } }} TreeMap 키로 정렬이 되고, tree를 사용한다. TreeSet과 HashMap의 개념을 합한 클래스 key, value 페어 key값을 기준으로 정렬 key에 해당되는 class에 comparable, comparator 정렬 key가 Integer, String이면 기존 메서드 활용하고, 아니면 오버라이딩하여 사용한다.","link":"/08/24/ClassFramework/"},{"title":"람다식 (Lambda Expression)","text":"람다식 (Lambda Expression)특징 java8부터 함수형 프로그래밍 방식을 지원하고, 이를 람다식이라고 한다. 함수형 프로그래밍 매개 변수만을 사용하여 만드는 함수인 순수 함수를 구현 외부 자료를 사용하지 않으므로 side effect가 없다 여러 자료를 동시에 처리하는 병렬처리가 가능하다. 함수의 기능이 자료에 독립적이다. 문법 익명 함수 만들기 매개변수와 매개변수를 이용한 실행문으로 구현된다. java는 OOP언어이기 때문에 람다식, 함수로만 클래스를 구성할 수 없다. interface의 메소드를 구현하는 방식으로 한다. 1234567package ch02;@FunctionalInterfacepublic interface Add { int add(int x, int y);} 123456789package ch02;public class AddTest { public static void main(String[] args) { Add add = (x, y) -&gt; {return x+y;}; System.out.println(add.add(2, 3)); }} 람다식과 OOP 방식 비교 람다식에서는 FunctionalInterface 익명 내부 클래스가 생성된다. OOP 방식에서는 Interface를 implement하여 구현하고, 메서드를 호출한다. 123456789101112131415161718192021222324package ch04;public class StringConcatTest { public static void main(String[] args) { String s1 = &quot;Hello&quot;; String s2 = &quot;World&quot;; // OOP 방식 StringConcatImp strImp = new StringConcatImp(); strImp.makeString(s1, s2); // 1. 람다식 구현 방식 StringConcat concat = (s,v)-&gt; System.out.println(s+&quot;,&quot;+v); concat.makeString(s1,s2); // 2. 람다식 구현 방식 StringConcat concat2 = new StringConcat() { @Override public void makeString(String s1, String s2) { System.out.println(s1+&quot;,&quot;+s2); } }; }}","link":"/08/25/Lambda/"},{"title":"데코레이터 패턴 (Decorator Pattern)","text":"데코레이터 패턴이란? 특징 여러 decorator들을 활용하여 다양한 기능을 제공한다. 상속보다 유연한 방식을 갖는다. 지속적인 기능의 추가 제거가 용이하다. 다른 데코레이터나 컴포넌트를 포함하여야한다. 기반 스트림 클래스 : 직접 읽고 쓸 수 있다. (Component) 보조 스트림 : 추가 기능 제공 (Decorator) 구성 최상위 컴포넌트 (예시 : Coffee) 하위 컴포넌트 (예시 : EtiopiaAmericano) 데코레이터 (예시 : Decorator) 하위 데코레이터 (예시 : Moch, Latte) 하위 컴포넌트와 데코레이터는 최상위 컴포넌트를 상속받는다. 데코레이터는 혼자 쓰이지않고, 상속용(abstract)으로 구현한다. @Decorator 최상위 컴포넌트의 default Constructor가 없으므로, 생성자를 명시해준다. @하위 Decorator 상위 클래스 Decorator의 default 생성자가 없으므로 매개변수가 있는 super를 명시적으로 호출해야한다. 하위 데코레이터는 데코레이터는 상속받아 각 기능을 구현한다. 하위 컴포넌트 생성시 하위 데코레이터를 wrapper 형식을 통해 원하는 기능을 추가한다. 최상위 컴포넌트 예제코드 1234public abstract class Coffee { public abstract void brewing();} 하위 컴포넌트 예제 코드 123456public class EtiopiaAmericano extends Coffee{ @Override public void brewing() { System.out.println(&quot;Etiopia Americano&quot;); }} 데코레이터 예제코드 1234567891011121314// 데코레이터는 혼자 쓰이지 않는다. (상속용으로 쓰인다.)public abstract class Decorator extends Coffee{ // component를 멤버 변수, 생성자 parameter로 갖는다. Coffee coffee; public Decorator(Coffee coffee){ this.coffee = coffee; } @Override public void brewing() { coffee.brewing(); }} 하위 데코레이터 예제코드 1234567891011public class Moch extends Decorator{ public Moch(Coffee coffee) { super(coffee); } @Override public void brewing() { super.brewing(); System.out.println(&quot;Adding Moch syrup&quot;); }} 123456789101112public class Latte extends Decorator{ // 상위 클래스 Decorator의 default 생성자가 없으므로 매개변수가 있는 super를 명시적으로 호출해야한다. public Latte(Coffee coffee) { super(coffee); } @Override public void brewing() { super.brewing(); System.out.print(&quot;Adding Milk&quot;); }} 테스트 코드 1234567891011public class CoffeeTest { public static void main(String[] args) { // 하위(상세) 컴포넌트 생성 Coffee etio = new EtiopiaAmericano(); etio.brewing(); // 하위(상세) Decorator로 기능을 추가한 컴포넌트 Coffee mochEtio = new Moch(new EtiopiaAmericano()); mochEtio.brewing(); }}","link":"/09/06/DecoratorPattern/"},{"title":"직렬화 (Serialization)","text":"직렬화 (Serialization)정의 인스턴스의 상태를 그대로 저장(파일), 전송(네트워크), 복원하는 방식 바이트 스트림의 연속으로 객체 정보를 저장하고, 복원한다. 보조 스트림을 활용한다. 인터페이스 직렬화는 인스턴스의 정보가 외부로 유출되는 것이다. 직렬화를 하려면 명시해줘야한다. (Marker interface) implements Serializable 구현코드가 없는 interface 클래스 내에서 직렬화하고 싶지 않은 변수, 불가능한 변수는 transient로 명시한다. default 값으로 출력된다. (String = null) 예제코드 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package ch17;import java.io.*;class Person implements Serializable{ String name; transient String job; public Person(){} public Person(String name, String job){ this.name = name; this.job = job; } public String toString(){ return name + &quot;,&quot; + job; }}public class SerializationTest { public static void main(String[] args) { Person personLee = new Person(&quot;이순신&quot;, &quot;대표&quot;); Person personKim = new Person(&quot;김유신&quot;, &quot;상무이사&quot;); try (FileOutputStream fos = new FileOutputStream(&quot;serial.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos)) { // Serialization oos.writeObject(personLee); oos.writeObject(personKim); } catch (IOException e) { e.printStackTrace(); } try (FileInputStream fis = new FileInputStream(&quot;serial.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis)) { Person pLee = (Person)ois.readObject(); Person pKim = (Person)ois.readObject(); System.out.println(pLee); System.out.println(pKim); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } }} implements Externalizable 읽고 쓰는 메서드를 구현해주어야 한다. 예제 코드 확인하기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package ch17;import java.io.*;class People implements Externalizable { String name; String job; public People(){} public People(String name, String job){ this.name = name; this.job = job; } public String toString(){ return name + &quot;, &quot; + job; } @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeUTF(name); out.writeUTF(job); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { name = in.readUTF(); job = in.readUTF(); }}public class ExternalizableTest { public static void main(String[] args) { People peopleLee = new People(&quot;이순신&quot;, &quot;대표&quot;); People peopleKim = new People(&quot;김유신&quot;, &quot;상무이사&quot;); try (FileOutputStream fos = new FileOutputStream(&quot;external.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos)) { oos.writeObject(peopleLee); oos.writeObject(peopleKim); } catch (IOException e) { e.printStackTrace(); } try (FileInputStream fis = new FileInputStream(&quot;external.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis)){ People peopleL = (People)ois.readObject(); People peopleK = (People)ois.readObject(); System.out.println(peopleL); System.out.println(peopleK); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } }}","link":"/09/06/Serial/"},{"title":"IOStream","text":"IO 스트림IO Stream (입출력 스트림) 스트림 : 네트워크에서 자료의 흐름이 물의 흐름과 같다는 비유에서 유래 java의 입출력을 위한 스트림 입출력 매개체에 독립적으로 일관성있는 입출력을 제공한다. 키보드, 마우스, 네트워크, 메모리 등 구분대상 기준 입력과 출력 스트림은 독립적으로 구분된다. 대상 기준에 따른 스트림 입력 스트림(입력용) FileInputStream FileReader BufferedInputStream BufferedReader … 출력 스트림(출력용) FileOutputStream FileWriter BufferedOutputStream BufferedWriter … 자료의 종류 자료의 종류에 따른 스트림 바이트 스트림 동영상, 음악 파일, 실행 파일 등을 읽고 쓸 때 사용 FileInputStream FileOutputStream BufferedInputStream BufferedOutputStream … 문자 스트림 바이트 단위로 자료를 처리하면 문자는 깨진다. 인코딩에 맞게 2바이트 이상으로 처리할 때 사용 FileReader FileWriter BufferedReader BufferedWriter … 기능 기능에 따른 스트림 기반 스트림 대상에 직접 자료를 읽고 쓰는 기능의 스트림 FileInputStream FileOutputStream FileReader FileWriter 보조 스트림 실제로 읽고 쓰는 기능은 없으나, 다른 스트림을 감싸서(wrap), 다른 스트림이 하는 일을 보조해준다. 다른 기반 스트림이나, 보조 스트림을 생성자의 매개변수로 갖는다. InputStreamReader OutputStreamWriter BufferedInputStream BufferedOutputStream 표준 입출력 스트림 System.out 표준 출력(모니터) 스트림 System.out.println(&quot;출력 메세지&quot;); System.in 표준 입력(키보드) 스트림 int d = System.in.read() // 한 바이트 읽기 한 바이트로 읽으면 한글과 같은 2바이트 이상은 불러올 수 없기 때문에 보조스트림으로 감싸주어야한다. System.err 표준 에러 출력(모니터) 스트림 System.err.println(&quot;에러 메세지&quot;); 한 바이트 읽기 1234567891011121314151617181920212223package ch13;import java.io.IOException;import java.io.InputStreamReader;public class SystemInTest { public static void main(String[] args) { System.out.println(&quot;알파벳 여러 개를 쓰고 [Enter]를 누르세요&quot;); int i; try { InputStreamReader irs = new InputStreamReader(System.in); while ((i = irs.read()) != '\\n') { System.out.print((char)i); } } catch (IOException e) { e.printStackTrace(); } }} 보조 스트림으로 감싸기 1234567891011121314151617181920212223package ch13;import java.io.IOException;import java.io.InputStreamReader;public class SystemInTest { public static void main(String[] args) { System.out.println(&quot;알파벳 여러 개를 쓰고 [Enter]를 누르세요&quot;); int i; try { InputStreamReader irs = new InputStreamReader(System.in); while ((i = irs.read()) != '\\n') { System.out.println((char)i); } } catch (IOException e) { e.printStackTrace(); } }} 바이트 단위 입출력 스트림InputStream 바이트 단위 입력 스트림의 최상위 추상 클래스 다양한 추상 메서드들이 선언되어 있고, 하위 스트림 클래스가 상속받아서 구현한다. 하위 클래스 FileInputStream 파일에서 바이트 단위로 자료를 읽는다. ByteArrayInputStream 바이트 배열 메모리에서 바이트 단위로 자료를 읽는다. FilterInputStream 기반 스트림에서 자료를 읽을 때 추가 기능을 제공하는 보조 스트림의 상위 클래스 주요 메서드 int read() 입력 스트림으로부터 한 바이트의 자료를 읽고, 바이트 수를 반환 int read(byte b[]) b 크기의 자료를 읽고, 바이트 수를 반환 int read(byte b[], int off, int len) b 크기 자료에서의 인덱스 0으로부터 Off만큼 떨어진 곳부터 len까지 자료를 읽고, 바이트 수를 반환 void close() 파일, 스트림을 불러왔을 때는 항상 close를 해주어야한다. int read() 하나씩 출력하기 1234567891011121314151617181920212223242526272829303132333435package ch14;import java.io.FileInputStream;import java.io.IOException;public class FileInputStreamTest { public static void main(String[] args) { FileInputStream fis = null; try { fis = new FileInputStream(&quot;input.txt&quot;); System.out.println((char)fis.read()); System.out.println((char)fis.read()); System.out.println((char)fis.read()); } catch (IOException e) { System.out.println(e); try { fis.close(); } catch (IOException ioException) { System.out.println(ioException); } catch (Exception e2) { System.out.println(e2); } } finally { try { fis.close(); } catch (IOException e) { System.out.println(e); } catch (Exception e2) { System.out.println(e2); } } System.out.println(&quot;end&quot;); }} 파일 내 데이터 모두 불러오기 1234567891011121314151617181920package ch14;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileTest { public static void main(String[] args) { // try의 resource에 파일을 넣어주면 AutoClosable이 되어 close를 하지 않아도 된다. int i ; try(FileInputStream fis = new FileInputStream(&quot;input.txt&quot;)){ // read()메서드는 파일의 끝에서 -1을 반환해준다. while ( (i = fis.read()) != -1 ){ System.out.print((char)i); } } catch (IOException e) { System.out.println(e); } }} int read(바이트 배열) 출력하기 123456789101112131415161718192021222324package ch14;import java.io.FileInputStream;import java.io.IOException;public class FileTest2 { public static void main(String[] args) { int i; try(FileInputStream fis = new FileInputStream(&quot;input2.txt&quot;);){ byte[] bs = new byte[10]; while ((i = fis.read(bs)) != -1) { for (int j = 0 ; j &lt; i ; j++) { System.out.print((char)bs[j]); } System.out.println(&quot; : &quot; + i + &quot;바이트 읽음&quot;); } } catch (IOException e) { System.out.println(e); } }} OutputStream 바이트 단위 출력 스트림의 최상위 클래스 InputStream과 같이 하위 스트림이 상속받아 구현한다. 하위 클래스 FileOutputStream 파일에서 바이트 단위로 자료를 쓴다. 파일을 불러올 때 해당 이름의 파일이 없으면 생성한다. default : Overwrite(덮어쓰기, 기존 데이터는 무시한다.) append를 true로 설정하여 이어서 작성할 수 있다. new FileOutputStrem(&quot;a.txt&quot;, true); ByteArrayOutputStream byte배열에서 바이트 단위로 자료를 쓴다. FilterOutputStream 기반 스트림에서 자료를 쓸 때 추가 기능을 제공하는 보조 스트림의 상위 클래스 주요 메서드 int write() 한 바이트를 출력한다. int write(byte b[]) b[] 크기의 자료를 출력한다. int write(byte b[], int off, int len) b 크기 자료에서의 인덱스 0으로부터 Off만큼 떨어진 곳부터 len까지 자료를 출력 int flush() 네트워크에서 socket을 쓰면 socket의 출력용 버퍼테 일정 크기의 데이터가 쌓이면 전송이된다. 강제적으로 버퍼를 비워 자료를 출력하게한다. void close() 리소스를 닫으면서 flush()를 수행한다. Byte별로 write하기 123456789101112131415161718package ch14;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputTest { public static void main(String[] args) { try (FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;)){ fos.write(65); fos.write(66); fos.write(67); } catch (IOException e){ System.out.println(e); } System.out.println(&quot;end&quot;); }} Byte 배열 write하기 1234567891011121314151617181920212223242526package ch14;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputTest2 { public static void main(String[] args) throws FileNotFoundException { FileOutputStream fos = new FileOutputStream(&quot;output2.txt&quot;); try(fos){ //java9 이후로 제공 byte[] bs = new byte[26]; byte data = 65; // ASCII 'A'값 for (int j = 0 ; j &lt; bs.length ; j++){ bs[j] = data; data++; } fos.write(bs); }catch(IOException e) { System.out.println(e); } System.out.println(&quot;완료되었습니다.&quot;); }} 문자단위 입출력 스트림Reader 문자 단위 입력 스트림의 최상위 추상 클래스 추상 메서드를 하위 스트림이 상속받아 구현한다. 하위 클래스 FileReader 파일에서 문자 단위로 읽는 스트림 클래스 InputStreamReader 보조 스트림 바이트 단위로 읽은 자료(스트림)를 문자로 변환 BufferedReader 보조 스트림 배열을 제공하여 한꺼번에 읽을 수 있는 기능을 제공 주요 메서드 문자, 문자열을 읽어 온다. int read() int read(char[] buf) int read(char[] buf, int off, int len) void close() 예제 코드 확인하기 12345678910111213141516171819package Online;import java.io.FileReader;import java.io.IOException;public class IOTest { public static void main(String[] args) { try(FileReader fr = new FileReader(&quot;reader.txt&quot;)){ int i; while ((i = fr.read()) != -1) { System.out.print((char) i); } } catch (IOException e) { } }} Writer 문자 단위 출력 스트림의 최상위 클래스 추상 메서드를 하위 스트림이 상속받아 구현한다. 하위 클래스 FileWriter OutputStreamWriter Buffered Writer 주요 메서드 int write(int c) int write(char[] buf) int write(char[] buf, int off, int len) int write(String str) int write(String str, int off, int len) int flush() void close() 예제 코드 확인하기 12345678910111213141516171819202122package Online;import java.io.FileWriter;import java.io.IOException;public class WriterTest { public static void main(String[] args) { try (FileWriter fw = new FileWriter(&quot;writer.txt&quot;)) { fw.write('A'); char buf[] = {'B', 'C', 'D', 'E', 'F'}; fw.write(buf); fw.write(&quot;안녕하세요.&quot;); fw.write(buf, 1, 2); fw.write(&quot;65&quot;); }catch (IOException e) { } }} 보조 스트림 실제 읽고 쓰는 스트림이 아닌 보조 기능을 제공하는 스트림이다. FileInputStream과 FileOutputStream의 하위 클래스 여러 기능을 조합하여 사용할 수 있는 Decorator Pattern으로 구현된다. 생성자의 매개 변수로 파일 이름이 아닌 기반 스트림, 보조 스트림을 갖는다. InputStreamReader, OutputStreamReader 예제코드 확인하기 1234567891011121314151617181920package Online;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class InputStreamReaderTest { public static void main(String[] args) { try (InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;reader.txt&quot;))) { int i; while( (i = isr.read()) != -1) { System.out.print((char)i); } } catch(IOException e) { } }} BufferedInputStream, BufferedOutputStream 예제코드 확인하기 123456789101112131415161718192021222324252627package Online;import java.io.*;public class CopyTest { public static void main(String[] args) { long millisecond = 0; try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;reader.txt&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.txt&quot;))) { millisecond = System.currentTimeMillis(); int i; while ((i = bis.read()) != -1) { bos.write(i); } millisecond = System.currentTimeMillis() - millisecond; } catch (IOException e) { e.printStackTrace(); } System.out.println(millisecond + &quot;소요되었습니다.&quot;); }} DataInputStream, DataOutputStream 자료가 메모리에 저장된 상태 그대로 읽거나 쓰는 스트림 자료형, 크기를 유지하여 읽고 쓴다. 기록한 자료형 그대로 불러와야한다. 1234567891011121314151617181920212223242526272829303132package Online;import java.io.*;public class DataIOTest { public static void main(String[] args) { try (FileOutputStream fos = new FileOutputStream(&quot;data.txt&quot;); DataOutputStream dos = new DataOutputStream(fos)) { dos.writeByte(100); dos.writeChar('A'); dos.writeInt(10); dos.writeFloat(3.14f); dos.writeUTF(&quot;Test&quot;); } catch (IOException e) { e.printStackTrace(); } try (FileInputStream fis = new FileInputStream(&quot;data.txt&quot;); DataInputStream dis = new DataInputStream(fis)) { System.out.println(dis.readByte()); System.out.println(dis.readChar()); System.out.println(dis.readInt()); System.out.println(dis.readFloat()); System.out.println(dis.readUTF()); } catch (IOException e) { e.printStackTrace(); } }}","link":"/09/02/IOStream/"},{"title":"쓰레드 (Thread)","text":"쓰레드개념프로세스 (Process) 실행 중인 프로그램이 실행되면 OS로부터 메모리를 할당받아 프로세스 상태가 된다. 프로그램이 메모리에 올라간 상태 프로세스는 하나 이상의 쓰레드를 가지게 된다. 쓰레드 (Thread) 프로세스가 메모리를 점유하고 CPU에서 수행이 된다. 쓰레드 : CPU에서 프로세스가 실행되는 단위 스케줄러 : 쓰레드의 배분 웹서버에 멀티쓰레드가 구현되어 있기 때문에 웹프로그래밍에서는 멀티쓰레드를 구현할 일이 없다. 쓰레드는 자신만의 작업 공간인 context(변수 정보 등)를 가지고 있다. 쓰레드 상태 (Thread Status) Runnable 쓰레드가 start 되면 쓰레드 풀에서 대기하게 된다. 언제든지 CPU가 배분되면 실행될 수 있는 상태 Not Runnable CPU를 절대 점유할 수 없는 상태 자바에서 메서드를 통해 Not Runnable로 만들 수 있다. sleep(millisecond) millisecond후에 Runnable로 변경 wait() 자원이 한정되어 있을 때, 유효한 thread가 생길 때 까지 대기상태 유효한 상태가 되면 notify, notifyAll을 통해 쓰레드를 불러온다. join() 한 개의 쓰레드가 다른 쓰레드를 참조할 때 join()을 하면 참조하는 쓰레드가 끝날 때 까지 자기 자신을 Not Runnable 상태로 만든다. Dead 쓰레드가 다 수행된 상태, 종료된 상태 wait() / notify() 리소스가 유효하지 않은 경우 유효할 때 까지 Thread는 wait상태가 된다. 유효한 리소스가 생기면 notify()/notifyAll()를 통해 Thread가 호출된다. notify() : 무작위 쓰레드 호출 notifyAll() : wait상태의 Thread 모두 호출 유효한 리소스만큼 호출되며, 자원을 갖지 못하면 다시 wait상태가 된다. 예제 도서관(공유 자원)에서 책을 빌리려하는 학생(Thread)이 있다. 책(자원)은 한정되어 있고, 학생(쓰레드)들이 책(자원)을 빌리려 할 때 책이 없으면 wait() 책(자원)이 반납되면 다른 학생(쓰레드)가 빌림 notify 예제 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package ch17;import java.util.ArrayList;import java.util.InputMismatchException;class Library { public ArrayList&lt;String&gt; shelf = new ArrayList&lt;&gt;(); public Library() { shelf.add(&quot;태백산맥1&quot;); shelf.add(&quot;태백산맥2&quot;); shelf.add(&quot;태백산맥3&quot;); } public synchronized String lendBook() throws InterruptedException { Thread t = Thread.currentThread(); if (shelf.size() == 0) { System.out.println(t.getName() + &quot; : waiting start&quot;); wait(); System.out.println(t.getName() + &quot; : waiting end&quot;); } if (shelf.size() &gt; 0 ){ String book = shelf.remove(0); System.out.println(t.getName() + &quot; : &quot; + book + &quot; lend&quot;); return book; } else return null; } public synchronized void returnBook(String book) { Thread t = Thread.currentThread(); shelf.add(book); System.out.println(t.getName() + &quot; : &quot; + book + &quot; return&quot;); notify(); }}class Student extends Thread{ public Student(String name) { super(name); } @Override public void run() { try{ String title = LibraryMain.library.lendBook(); if (title == null) { System.out.println(getName() + &quot; : 빌리지 못했음&quot;); return; } sleep(5000); LibraryMain.library.returnBook(title); } catch (InterruptedException e) { System.out.println(e); } }}public class LibraryMain { public static Library library = new Library(); public static void main(String[] args) { Student std1 = new Student(&quot;std1&quot;); Student std2 = new Student(&quot;std2&quot;); Student std3 = new Student(&quot;std3&quot;); Student std4 = new Student(&quot;std4&quot;); Student std5 = new Student(&quot;std5&quot;); Student std6 = new Student(&quot;std6&quot;); std1.start(); std2.start(); std3.start(); std4.start(); std5.start(); std6.start(); }} notifyAll() 예제코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package ch17;import java.util.ArrayList;import java.util.InputMismatchException;class Library { public ArrayList&lt;String&gt; shelf = new ArrayList&lt;&gt;(); public Library() { shelf.add(&quot;태백산맥1&quot;); shelf.add(&quot;태백산맥2&quot;); shelf.add(&quot;태백산맥3&quot;); } public synchronized String lendBook() throws InterruptedException { Thread t = Thread.currentThread(); while (shelf.size() == 0) { System.out.println(t.getName() + &quot; : waiting start&quot;); wait(); System.out.println(t.getName() + &quot; : waiting end&quot;); } if (shelf.size() &gt; 0 ){ String book = shelf.remove(0); System.out.println(t.getName() + &quot; : &quot; + book + &quot; lend&quot;); return book; } else return null; } public synchronized void returnBook(String book) { Thread t = Thread.currentThread(); shelf.add(book); System.out.println(t.getName() + &quot; : &quot; + book + &quot; return&quot;); notifyAll(); }}class Student extends Thread{ public Student(String name) { super(name); } @Override public void run() { try{ String title = LibraryMain.library.lendBook(); if (title == null) { System.out.println(getName() + &quot; : 빌리지 못했음&quot;); return; } sleep(5000); LibraryMain.library.returnBook(title); } catch (InterruptedException e) { System.out.println(e); } }}public class LibraryMain { public static Library library = new Library(); public static void main(String[] args) { Student std1 = new Student(&quot;std1&quot;); Student std2 = new Student(&quot;std2&quot;); Student std3 = new Student(&quot;std3&quot;); Student std4 = new Student(&quot;std4&quot;); Student std5 = new Student(&quot;std5&quot;); Student std6 = new Student(&quot;std6&quot;); std1.start(); std2.start(); std3.start(); std4.start(); std5.start(); std6.start(); }} 멀티 쓰레딩 (Multi-Threading) 여러 thread가 동시에 수행되는 프로그래밍, 여러 작업이 동시에 실행되는 효과 thread는 각각 자신만의 작업 공간을 가짐 (context) 각 thread 사이에서 공유하는 자원이 있을 수 있음 (자바에서는 static instance) 여러 thread가 자원을 공유하여 작업이 수행되는 경우 서로 자원을 차지하려는 race condition이 발생할 수 있음 이렇게 여러 thread가 공유하는 자원 중 경쟁이 발생하는 부분을 critical section이라고 함 critical section에 대한 동기화(일종의 순차적 수행)를 구현하지 않으면 오류가 발생할 수 있음 관련 : Synchronization, Monitor, Semaphore 등 동기화 (Synchronization) 공유 자원을 사용할 때 한 쓰레드가 사용 중이면 Lock을 걸어서 다른 쓰레드의 접근을 막는다 메서드에 synchronized 키워드 입력 synchronized 블록 생성 @쓰레드, 메서드 synchronized(참조형 수식) {} 예제 코드1 확인하기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package ch17;class Bank{ private int money = 10000; public synchronized void saveMoney(int save){ int m = getMoney(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } setMoney(m + save); } public synchronized void minusMoney(int minus){ int m = getMoney(); try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } setMoney(m-minus); } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; }}class Park extends Thread{ @Override public void run() { System.out.println(&quot;start save&quot;); SyncMain.myBank.saveMoney(3000); System.out.println(&quot;saveMoney : &quot; + SyncMain.myBank.getMoney()); }}class ParkWife extends Thread{ @Override public void run() { System.out.println(&quot;start minus&quot;); SyncMain.myBank.minusMoney(1000); System.out.println(&quot;minusMoney : &quot; + SyncMain.myBank.getMoney()); }}public class SyncMain { public static Bank myBank = new Bank(); public static void main(String[] args) { Park p = new Park(); p.start(); try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } ParkWife pw = new ParkWife(); pw.start(); }} 예제 코드 2 확인하기 12345678910111213public void saveMoney(int save){ synchronized (this) { int m = getMoney(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } setMoney(m + save); }} 메서드우선순위 Thread.MIN_PRIORITY(=1) ~ Thread.MAX_PRIORITY(=10) 디폴트 우선순위 : Thread.NORMAL_PRIORITY(=5) 우선 순위가 높은 Thread가 CPU의 배분을 받을 확률이 높다 우선순위 설정 및 호출이 가능하다 setPriority()/getPriority() 예제 코드 확인하기 1234567891011121314151617181920212223242526272829class PriorityThread extends Thread{ public void run(){ int sum = 0; Thread t = Thread.currentThread(); System.out.println( t + &quot;start&quot;); for(int i =0; i&lt;=1000000; i++){ sum += i; } System.out.println( t.getPriority() + &quot;end&quot;); }}public class PriorityTest { public static void main(String[] args) { int i; for(i=Thread.MIN_PRIORITY; i&lt;= Thread.MAX_PRIORITY; i++){ PriorityThread pt = new PriorityThread(); pt.setPriority(i); pt.start(); } }} join 동시에 두 개 이상의 Thread가 실행 될 때 다른 Thread의 결과를 참조 하여 실행해야 하는 경우 join() 함수를 사용 join() 함수를 호출한 Thread가 not-runnable 상태가 감 다른 Thread의 수행이 끝나면 runnable 상태로 돌아옴 예제 코드 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package ch17;public class JoinTest extends Thread{ int start; int end; int total; public JoinTest(int start, int end) { this.start = start; this.end = end; } public void run() { int i; for (i = start; i &lt;= end; i++){ total += i; } } public static void main(String[] args) { JoinTest jt1 = new JoinTest(1, 50); JoinTest jt2 = new JoinTest(51, 100); jt1.start(); jt2.start(); // jt1, jt2가 끝날 때까지 main thread는 Not Runnable 상태가 된다. // 무한 루프 등 hang을 해결하기 위해 Exception을 날려준다. try { jt1.join(); jt2.join(); } catch (InterruptedException e) { e.printStackTrace(); } // 아직 계산하고 있는 중이라서 값이 할당되지 않을 수 있다. int lastTotal = jt1.total + jt2.total; System.out.println(&quot;jt1.total = &quot; + jt1.total); System.out.println(&quot;jt2.total = &quot; + jt2.total); System.out.println(&quot;LastTotal = &quot; + lastTotal); }} interrupt 다른 Thread에 예외를 발생시키는 interrupt를 보낸다. join(), sleep(), wait()에 의해 Not Runnable 상태일 때, 호출하면 다시 runnable 상태가 된다. 쓰레드 종료 무한 반복의 경우 while(flag)의 flag를 false로 바꾸어 종료시킨다. while(true)가 아닌 다른 값을 입력해주기 위해 변수를 사용한다. 예제 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class TerminateThread extends Thread{ private boolean flag = false; int i; public TerminateThread(String name){ super(name); } public void run(){ while(!flag){ try { sleep(100); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } System.out.println( getName() + &quot; end&quot; ); } public void setFlag(boolean flag){ this.flag = flag; } public static void main(String[] args) throws IOException { TerminateThread threadA = new TerminateThread(&quot;A&quot;); TerminateThread threadB = new TerminateThread(&quot;B&quot;); TerminateThread threadC = new TerminateThread(&quot;C&quot;); threadA.start(); threadB.start(); threadC.start(); int in; while(true){ in = System.in.read(); if ( in == 'A'){ threadA.setFlag(true); }else if(in == 'B'){ threadB.setFlag(true); }else if( in == 'C'){ threadC.setFlag(true); }else if( in == 'M'){ threadA.setFlag(true); threadB.setFlag(true); threadC.setFlag(true); break; }else{ System.out.println(&quot;type again&quot;); } } System.out.println(&quot;main end&quot;); }} 구현extends Thread Thread가 수행이되면 run 메서드가 실행된다. 기본적으로 메인 쓰레드가 수행이된다. 예제에서 쓰레드 2개를 추가하여 테스트 (메인 포함 총 3개 쓰레드) 예제 코드 확인하기 123456789101112131415161718192021222324package ch17;class MyThread extends Thread { public void run() { int i; for (i = 1; i&lt;=200; i++){ System.out.print(i + &quot;\\t&quot;); } }}public class ThreadTest { public static void main(String[] args) { // 현재 main 내의 thread확인 // [호출한 함수, priority, threadGroup] System.out.println(Thread.currentThread() + &quot;start&quot;); MyThread th1 = new MyThread(); MyThread th2 = new MyThread(); th1.start(); th2.start(); System.out.println(Thread.currentThread() + &quot;end&quot;); }} implements Runnable run 메서드를 override 해주어어야 한다. Main에서 Thread를 생성할 때 runnable 객체를 생성하여 생성자의 parameter로 넣어준다. 예제 코드 확인하기 1234567891011121314151617181920212223242526272829package ch17;class MyThread implements Runnable { @Override public void run() { int i; for (i = 0; i &lt;= 200; i++) { System.out.print(i + &quot;\\t&quot;); } }}public class ThreadTest { public static void main(String[] args) { System.out.println(Thread.currentThread() + &quot;start&quot;); // runnable 객체 생성 MyThread runnable = new MyThread(); // runnable기반으로 쓰레드가 돌아간다. Thread th1 = new Thread(runnable); Thread th2 = new Thread(runnable); th1.start(); th2.start(); System.out.println(Thread.currentThread() + &quot;end&quot;); }}","link":"/09/06/Thread/"},{"title":"AOP (Aspect Oriented Programming)","text":"AOP (Aspect Oriented Programming) 관점 지향 프로그래밍이라고도 불리는 AOP는 로직을 핵심, 부가적인 관점을 나누어 각각 모듈화하는 프로그래밍이다. 핵심적인 관점 : 핵심 비즈니스 로직 부가적인 관점 : DB 연결, 로깅, 파일 입출력 등 AOP를 통해 스프링 IoC와 연동하여 중복 코드, 객체 간 복잡도 등에 대한 해결책을 지원한다. 중복되는 코드를 Aspect로 모듈화하여 재사용성을 높일 수 있다. 중복되는 코드들을 **흩어진 관심사(Crosscutting Concerns)**라고 칭한다. 실행 전 후 특정 기능 추가(method의 실행시간 체크 등), response 정보 저장 등 Spring Bean(스프링 빈)에만 적용 가능하며, 접근 제어와 부가 기능 추가를 위해 proxy패턴 기반의 구현체를 사용한다. AOP 구성 요소 출처 : cloudinary Aspect 중복되는 코드(흩어진 관심사)를 모듈화한 것 Target Object Aspect가 적용되는 클래스, 메서드 등의 객체 Proxy Aspect와 Target을 연결해주는 클래스 Join Point Advice가 적용되는 지점 (실행 전 후 특정 기능 추가와 관련) Point Cut JointPoint를 구체화한 Advice가 실행 될 지점 Advice Joint Point, Point Cut에서 실행되는 코드, 실질적인 구현부 Weaving Joint Point에 Advice를 적용하는 방법","link":"/09/13/AOP/"},{"title":"gRPC (Google Remote Procedure Call)","text":"gRPC는 무엇인가? Google사에서 개발한 RPC(Remote Procedure Call) 시스템으로, HTTP 2.0, TCP/IP 프로토콜을 사용한다. RPC는 원격 프로시저 호출로 별도의 코딩없이 다른 주소의 메서드나 프로시저를 실행할 수 있게하는 프로세스 간의 통신 기술이다. 프로토콜 버퍼(protocol buffer)를 인터페이스 정의어(IDL), 메세지 교환 형식으로 사용한다. 프로토콜 버퍼를 사용하여 보다 빠르고, 편리하게 통신할 수 있다. 프로토콜 버퍼란? (개인적으로 프로토콜 버퍼를 이해할 때 참고한 블로그입니다.) 장점 통신이 빠르다 파싱을 할 필요가 없다 단점 프로토콜 버퍼에서 독자적으로 쓰이는 proto 문법을 익혀야한다. 모든 클라이언트에서 proto파일이 있어야 하기 때문에 내부 서비스 데이터 교환에서 주로 쓰인다. gRPC를 사용하면 클라이언트 단에서 서버 단의 메소드를 로컬 객체처럼 바로 호출할 수 있다. Server side : 인터페이스를 구현하여 Client 요청을 handling할 수 있다. Client side : 서버에 있는 메소드와 동일한 stub을 제공한다. stub을 client라 칭하는 언어도 있다. 출처 : https://grpc.io/ 서버와 클라이언트 구글 내부 서버부터 데스크톱까지 다양한 환경에서 실행도 가능하다. API에서도 지원하여 기능 구현에 용이하다. 지원하는 언어로 서버와 클라이언트를 구현할 수 있다. 서버는 java, 클라이언트는 python과 같이 다른 언어로 구현할 수 있다. 빠른 데이터 처리, 편리하고 유연한 환경을 계속해서 강조하고 있다. RPC Life Cycle Unary RPC (단항 RPC)클라이언트에서 단일 요청을 보내고 단일 응답 받는다. 클라이언트가 stub 메서드를 호출하면 이에 대한 메타데이터(요청, 메소드명, 대기시간 등)를 서버에 알린다. 서버는 response를 보내기 전에 초기 메타데이터를 클라이언트에 바로 되돌려주거나, 요청 메시지를 기다린다. 어떤 것이 먼저 발생할 지는 application마다 다르다. 클라이언트의 요청 메시지를 받으면 서버에서는 응답 생성에 필요한 모든 실행을 한다. 성공적으로 생성 시 status code, message 등과 함께 response를 보낸다. Server Streaming RPC 클라이언트가 단일 요청 시 서버는 응답에 대해 stream을 응답하는 것을 제외하면 단항 RPC와 동일하다. Client streaming RPC 클라이언트가 단일 요청이 아닌 메시지의 stream으로 요청하는 것을 제외하면 단항 RPC와 동일하다. Bidirectional streaming RPC클라이언트가 메서드를 호출하고, 서버가 client의 메타데이터를 받으면 시작된다. 서버는 초기 메타데이터를 응답하거나, 클라이언트가 메시지를 streaming할 때 까지 대기한다. Client side와 Server side의 스트림 처리는 애플리케이션마다 다르다. - 두 스트림이 독립적이므로 순서에 상관없이 메시지를 읽고 쓸 수 있다. - 클라이언트의 모든 메시지를 수신할 때까지 서버는 대기하거나, 계속 해서 요청과 응답을 주고받을 수 있다. Terminate | Cancel Terminate (종료)클라이언트와 서버에서는 호출에 대한 성공 여부를 각각 독립적이고, local하게 결정을 내린다. 서버에서는 성공, 클라이언트에서는 실패가 나올 수 있다. 서버에서 모든 response를 성공적으로 보내도, 클라이언트의 Deadline이 지나서 응답하면 클라이언트는 실패로 인식한다. 클라이언트는 요청에 대한 응답까지의 시간을 지정할 수 있으며, 시간이 지나면 DEADLINE_EXCEEDED Error로 종료된다. 서버에서는 DeadLine까지 남은 시간과 시간이 만료된 요청이 있는지 query를 통해 확인할 수 있다. 클라이언트의 요청이 끝나지않아도 서버에서 완료 처리를 할 수 있다. Cancel (취소)클라이언트와 서버단에서 언제든 RPC에 대해 취소할 수 있고, 취소할 시 RPC가 즉시 종료된다. 취소 이전의 내용은 복구할 수 없음에 유의하여야 한다.","link":"/09/16/gRPC/"},{"title":"LINUX의 사용","text":"리눅스 파일 및 권한 관리 리눅스의 default editor로 주로 사용되는 bash를 통해 관련 명령을 알아보자. User 관련 명령어 sudo super user do의 약어로 관리자 권한으로 실행할 때 명령어 앞에 붙여 사용한다. whoami 로그인한 사용자의 ID를 알려준다. useradd | adduser 사용자를 추가할 때 사용된다. useradd : 사용자 기본 설정을 자동으로 하지 않고 추가한다. 계정을 생성할 때 필요한 모든 설정들을 명시해주어야 한다. adduser : 사용가 기본 설정을 자동으로 수행한다. /etc/adduser.conf 에 있는 정보를 물어보고 설정하게 해준다. 사용자 홈 디렉토리 생성 등 passwd 로그인한 사용자 ID의 암호를 설정 / 변경한다. su | su - 사용자를 변경할 때 사용한다. su user : 현재 로그인 되어있는 사용자의 환경 설정을 기반으로, 계정만 user로 전환한다. su - user : user의 환경설정을 기반으로 계정을 user로 전환한다. Directory/File 일반 명령어 pwd 현재 디렉토리 확인 cd 폴더 이동 cd ~ : home으로 이동 cd - : 이전 폴더로 이동 ls 현재 디렉토리의 파일 목록 출력 ls -al로 주로 사용된다. 디렉토리 내 파일의 다양한 정보를 포함하고 있다.12 (1) (2) (3) (4) (5) (6) (7) (8) drwxr-xr-x 4 root root 4096 Sep 29 11:55 .. 10개의 문자로 이루어지며, 1, 3, 3, 3개의 문자로 구분하여 읽는다. 첫 번째 그룹(1) : d, l, - 이 위치할 수 있다. d : directory, 폴더(디렉토리) l : link, 링크 f : file, 파일 두 번째 그룹(2~4) : 소유자가 갖는 권한 세 번째 그룹(5~7) : 그룹이 갖는 권한 네 번째 그룹(8~10) : 기타 사용자가 갖는 권한 권한을 표현하는 방법 중에는 rwx로 표현하는 기호 표기법과 숫자 표기법이 있다. 하드링크 번호 : 링크된 파일의 수를 의미한다. 소유자 소유 그룹 (소유자의 소유 그룹이 없을 때는 소유자를 나타낸다.) 파일의 크기(Byte) 파일이 생성, 수정된 날짜 파일이 생성, 수정된 시간 파일 및 디렉토리 이름 cat 파일 내용 출력 head | tail 파일 내용 출력 (출력되는 라인 수 설정 가능) 기본 값 : 10 more 파일 내용 출력 파일 내용을 터미널 화면의 크기에 맞춰 페이지 단위로 보여준다. 스페이스바로 다음 페이지를 확인할 수 있으며 끝까지 확인하면 화면이 종료된다. rm 삭제 LINUX에는 휴지통이 없으므로 파일이 바로 삭제된다. rm -rf로 디렉토리를 삭제하면 하위 모든 파일과 함께 강제로 삭제된다. r : recursive f : force Directory/File 권한 관련 명령어 chmod change mode : 파일 권한 변경 ls -al에서 나타났던 권한을 변경한다. 기호 표기법 누구에게 : u(사용자), g(그룹), o(기타 사용자), a(전부) 권한을 : +(준다), -(뺐는다), =(설정) 권한 : r(읽기), w(쓰기), x(실행) 모두에게 profile 파일에 대한 읽기 권한을 준다. chmode a+r profile 숫자 표기법 소유자, 그룹, 기타 사용자에 대한 권한을 3개의 숫자로 표현한다. 3비트로 구성되어 r = 4, w = 2 , x = 1를 뜻한다. rwxrwxrwx :777 rwx—— : 700","link":"/09/29/Aboutlinux/"},{"title":"M1 환경에서 LINUX 설치","text":"Virtual MachineParallels Desktop for Mac 버전 17 Intel 등의 CPU는 가상화 기술을 지원하지만 M1은 아직 안정적으로 지원하지 않고 있었다. 하지만 지난 8월 가상화 소프트웨어 전문 기업인 Parallels에서 애플 M1칩 기반 맥에서 정식적으로 가상화를 지원하는 Parallels Desktop for Mac 버전 17을 공개하였다. 출처 : Parallels 공식 홈페이지 M1 칩 맥에서도 Linux의 Ubuntu, Fedora, Windows 11버전 등의 가상화를 지원한다. 설치 Parallels 다운로드 링크 Ubuntu Server 다운로드 링크 위 링크를 통해 Parallels와 Ubuntu Server 이미지를 다운로드하였다. 안정적으로 가상화가 되었다.","link":"/09/29/linux/"},{"title":"Context Switching, 스레드 수준, fork()","text":"11. Context Switching 이란? 하나의 프로세스가 CPU를 사용 중인 상태에서, 다른 프로세스가 CPU를 점유하려고 할 때, 사용 중인 프로세스의 context를 PCB에 저장하고, 새로운 프로세스 의 상태를 CPU에 적재하는 작업 11-1. PCB의 저장 위치PCB는 중요 정보를 담고있기 때문에, 일반 사용자가 접근할 수 없는 보호된 메모리에 저장한다. 일부 OS에서는 안전하고, 편리한 커널의 스택 첫 부분에 저장을 한다. 11-2. PC(Program Counter) 이란?CPU 내부의 레지스터 중 하나로, 다음에 실행될 명령어의 주소를 가지고 있다. 명령 주기에 따라 자동으로 증가하고, 반복문 등에서는 다음 코드가 아닌 새로운 코드의 위치 값이 들어간다. 12. 사용자 수준 스레드와 커널 수준 스레드의 차이 커널 수준 스레드는 OS에서 생성하고, 관리하는 스레드이고, 사용자 수준 스레드는 라이브러리 등을 통해 사용자가 생성한 스레드다. 영역을 나눠줌으로써 코드 단에서 critical 한 systemcall(중요 파일에 대해 파일삭제 등)을 날리면 커널에서 막아준다. 사용자 수준 스레드 장점 kernel에 접근하지 않기 때문에, context switching이 없다. 따라서 커널 스레드에 비해 오버헤드가 적다. 라이브러리를 통해 스케줄링을 제어하여 유연한 스케줄링 가능 단점 한 스레드가 block되면 모든 스레드가 실행 불가 상태가 된다. 커널 수준의 보호 방법을 사용할 수 없다. 커널 수준 스레드 장점 각 스레드들을 독립적으로 관리할 수 있고, 멀티 프로세서를 활용할 수 있다. 한 스레드가 block돼도 다른 스레드들은 실행시킬 수 있다. 단점 context switching으로 인한 오버헤드 12-1. 멀티 프로세싱과 멀티 프로그래밍의 차이멀티 프로세싱 여러 개의 CPU가 협력적으로 일을 처리하는 것 fork를 통해 프로세스를 여러 개로 늘려, 여러 프로그램을 병렬로 처리 멀티 프로그래밍 한 프로그램이 대기 상태일 때, 다른 프로그램을 수행하는 것 멀티 태스킹 OS의 스케줄링을 통해 task를 번갈아가며 수행하는 것 task를 자주 번갈아가며 수행하여 동시에 수행하고 있다고 느낀다. 멀티 스레딩 하나의 프로세스를 여러 개의 스레드끼리 자원을 공유하여 처리하는 것 하나의 프로그램을 병렬로 처리 13. fork()와 vfork()의 차이점 자식 프로세스를 생성하는 시스템콜이다. fork()는 부모 프로세스의 메모리를 복사해서 사용하지만, vfork()는 부모 프로세스의 메모리를 공유한다. fork()를 실행하고 자식 프로세스에 변경사항이 생기면 독립적인 주소 공간을 생성시킨다. vfork()는 fork()에 비해 생성 속도가 빠르지만, 자원을 공유하기 때문에 race condition이 발생하지 않도록 자식 프로세스가 부모 프로세스를 exit하거나 실행될 때까지 block 해야한다. 13-1. 스레드의 저장 위치PCB 내부에 Thread Control Block에 저장한다. 멀티 프로세스에서는 둘 다 교환해준다. 13-2. 오버헤드어떤 처리를 하기 위해 소요되는 처리시간, 메모리 등을 말한다. 13-3. 혼합 스레드N:M 매핑을 통해 사용자 수준의 스레드 오버헤드 측면에서 thread pooling으로 보완가능 13-4. vfork()를 할 때 공유 자원에 대한 conflict 회피할 수 있는 방법=&gt; copyOnWrite() &gt; COW","link":"/11/10/0-interview-os4/"},{"title":"REST(Representational State Transfer)","text":"REST (Representational State Transfer) 조건 Client와 Server의 분리 서로 독립적으로 분리되어 있어야 한다. Stateless 요청에 대해서 클라이언트의 상태를 서버에 저장하지 않는다. 매 요청을 새롭게 처리한다 Cache (캐시) 클라이언트는 서버의 응답을 임시 저장하여, 재사용하고 부하를 낮추어야한다. Layered System (계층화) 서버와 클라이언트 사이를 다양한 계층 형태로 구성하고, 이를 확장할 수 있어야한다. 인터페이스 일관성 인터페이스의 일관성을 지킨다. 아키텍처를 단순화, 작은 단위로 분리하여 클라이언트, 서버를 독립적으로 개선할 수 있어야한다. 인터페이스의 일관성을 기초로 REST를 잘 사용하였는지 판단할 수 있다. 자원의 식별 URI를 통하여 리소스에 접근한다. 메시지를 통한 리소스 조작 데이터의 타입을 알려주는 header부분의 content-type 자기 서술적 메시지 요청하는 데이터가 어떻게 처리되어야하는지 충분한 데이터 포함 애플리케이션 상태에 대한 엔진으로써 하이퍼미디어 요청에 대한 데이터만이 아닌 관련된 리소스에 대한 Link정보 포함 Code On Demand 특정 기능을 서버로부터 전달받아 클라이언트가 실행할 수 있어야한다. Method GET 리소스 취득 CRUD 중 R(Read) POST 리소스 생성, 추가 CRUD 중 C(Create) PUT 리소스 갱신, 생성 CRUD 중 C(Create)/U(Update) 데이터가 없으면 생성하고, 있으면 갱신한다. DELETE 리소스 삭제 CRUD 중 D(Delete) HEAD 헤더 데이터 취득 OPTIONS 지원하는 메소드 취득 TRACE 요청메시지 반환 CONNECT 프록시 동작의 터널 접속으로 변경","link":"/09/29/rest/"},{"title":"Object Mapper","text":"Object Mapper Object Mapper를 통하여 Java에서 JSON 값을 가공 및 활용할 수 있습니다. Java Object를 JSON으로 Serializing 하거나 반대로 JSON 객체를 Object로 Deserializing 할 수 있습니다. Dependency 저는 Gradle과 Jackson Databind 2.12.3 API를 사용하였습니다. maven repository 홈페이지에서 object mapper키워드를 검색해서 찾을 수 있습니다. 편의를 위해 아래 코드 블럭에 위 버전의 dependency를 복사해두었습니다. 다른 버전 이용은 아래 링크를 참고해주세요 MVN REPOSITORY - jackson databind 12// https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databindimplementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.12.3' build.gradle에 dependency를 추가하면 jar파일을 온라인에서 불러와 클래스 패스에 자체적으로 추가시켜줍니다. Using Case User 객체가 내부적으로 Car 객체의 배열을 갖는 형태로 구성하였습니다. 이해를 돕기 위해 아래 사진을 첨부하였습니다. User 클래스 멤버 변수 String name int age List cars Car 클래스 멤버 변수 String name String carNumber String type User 객체 코드 123456789101112131415161718192021222324252627282930313233343536373839404142package dto;import java.util.List;public class User { private String name; private int age; private List&lt;Car&gt; cars; public List&lt;Car&gt; getCars() { return cars; } public void setCars(List&lt;Car&gt; cars) { this.cars = cars; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;User{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, cars=&quot; + cars + '}'; }} Car 객체 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344package dto;import com.fasterxml.jackson.annotation.JsonProperty;public class Car { private String name; private String carNumber; private String type; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCarNumber() { return carNumber; } public void setCarNumber(String car_number) { this.carNumber = car_number; } public String getType() { return type; } public void setType(String type) { this.type = type; } @Override public String toString() { return &quot;Car{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, car_number='&quot; + carNumber + '\\'' + &quot;, type='&quot; + type + '\\'' + '}'; }} 0. 객체 준비 User 객체에 나이와 이름을 setter를 통해 입력해줍니다. car 객체 2개를 생성하여 이름, 차량 번호, type을 입력해줍니다. User 객체에 보유한 차들을 List 형태로 가지고 있기 때문에 2개를 생성하였습니다. 생성한 car 객체 2개를 Array 형태로 변환하여 User 객체에 넣어줍니다. 객체 생성 코드 12345678910111213141516var user = new User();user.setName(&quot;홍길동&quot;);user.setAge(10);var car1 = new Car();car1.setName(&quot;K5&quot;);car1.setCarNumber(&quot;11가 1111&quot;);car1.setType(&quot;sedan&quot;);var car2 = new Car();car2.setName(&quot;Q5&quot;);car2.setCarNumber(&quot;22가 2222&quot;);car2.setType(&quot;SUV&quot;);List&lt;Car&gt; carList = Arrays.asList(car1,car2);user.setCars(carList); 1. Object를 JSON 등의 타입으로 변환 ObjectMapper 객체를 생성해줍니다. writeValueAsString()메서드를 통하여 객체를 String으로 변환하고 String 변수에 담아줍니다. User 객체를 JSON 형태로 설계하였기 때문에 JSON 형태의 String이 출력됩니다. 객체의 Value를 String으로 저장한다라고 해석하시면 이해하기 편합니다. Object Mapper 코드 123ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user); System.out.println(json); 12// 결과값// {&quot;name&quot;:&quot;홍길동&quot;,&quot;age&quot;:10,&quot;cars&quot;:[{&quot;name&quot;:&quot;K5&quot;,&quot;carNumber&quot;:&quot;11가 1111&quot;,&quot;type&quot;:&quot;sedan&quot;},{&quot;name&quot;:&quot;Q5&quot;,&quot;carNumber&quot;:&quot;22가 2222&quot;,&quot;type&quot;:&quot;SUV&quot;}]} 1-1. JSON 특정 key의 value 조회 readTree() 메서드JSON의 가장 바깥부분의 key들은 JsonNode를 가지고 있어, 이를 통해 JSON 객체에 직접적인 접근을 할 수 있습니다. JSON은 트리 구조와 같이 생겨서 Node를 읽어올 때는 readTree(객체) 메서드를 사용합니다. JsonNode 코드 확인하기 123456JsonNode jsonNode = objectMapper.readTree(json);String _name = jsonNode.get(&quot;name&quot;).asText();int _age = jsonNode.get(&quot;age&quot;).asInt();System.out.println(&quot;name : &quot; + _name);System.out.println(&quot;age : &quot; + _age); 123// 결과값// name : 홍길동// age : 10 하지만, 일반적인 key, value 쌍과는 다르게 cars는 내부적으로 배열 형태를 띄고 있습니다.내부의 배열은 ArrayNode라는 타입을 이용하여 접근할 수 있습니다. 순서 JsonNode로 cars 배열의 Node 불러오기 JsonNode를 ArrayNode로 명시적 형변환 ArrayNode 코드 확인하기 123JsonNode _cars = jsonNode.get(&quot;cars&quot;);ArrayNode arrayNode = (ArrayNode)_cars;System.out.println(&quot;cars : &quot; + arrayNode); 12// 결과값// cars : [{&quot;name&quot;:&quot;K5&quot;,&quot;carNumber&quot;:&quot;11가 1111&quot;,&quot;type&quot;:&quot;sedan&quot;},{&quot;name&quot;:&quot;Q5&quot;,&quot;carNumber&quot;:&quot;22가 2222&quot;,&quot;type&quot;:&quot;SUV&quot;}] 1-2. JSON 특정 key의 value 변경JsonNode는 value를 변경할 수 없도록 되어 있습니다. 따라서 값을 변경하고 싶을 때는 JsonNode를 ObjectNode로 명시적 형변환 해준 뒤에 값을 변경할 수 있습니다. 예제 코드 확인하기 12ObjectNode objectNode = (ObjectNode) jsonNode;objectNode.put(&quot;name&quot;, &quot;정동렬&quot;); 추가 적으로 objectNode의 값을 보기 편하게 출력하려면 toPrettyString()메서드를 사용하면 됩니다. System.out.println(objectNode.toPrettyString()); 2. JSON을 Object로 변환바로 위 ArrayNode 코드 확인하기에서 cars의 값을 arrayNode에 초기화시켜주었습니다. 이번에는 역으로 JSON 형태로 존재하는 arrayNode를 기존 User객체에 넣어주었던 List 객체로 mapping 해보겠습니다. convertValue(Object fromValue, TypeReference toValueTypeRef) fromValue : 변환하고 싶은 객체 (JSON형태의 값) TypeReference : mapping하고 싶은 객체의 타입 (List) Object로 mapping하기 12List&lt;Car&gt; cars = objectMapper.convertValue(arrayNode, new TypeReference&lt;List&lt;Car&gt;&gt;() {});System.out.println(cars); 12// 결과값// [Car{name='K5', car_number='11가 1111', type='sedan'}, Car{name='Q5', car_number='22가 2222', type='SUV'}]","link":"/10/07/obejctmapper/"},{"title":"IPC (Inter-Process Communication)","text":"IPC란 무엇인가? IPC는 Inter-Process Communication의 약어로 프로세스간 통신의 약어이다. 프로세스는 서로 독립되어 있어 다른 프로세스의 영향을 받지 않습니다. 이는 보는 관점에 따라 장점이 될 수도, 단점이 될 수도 있습니다. 서로 독립되어 있어 다른 프로세스의 영향을 받지 않을 수 있다는 장점이 있지만, 이는 서로 간의 통신이 어려운 것으로 해석할 수 있습니다. 이를 위해 OS의 커널 영역에서는 IPC를 제공하고, 이를 통해 프로세스간 통신이 가능해집니다. IPC 표준1. System V IPC 오랜 역사를 가지고 있다. 서로 다른 기종간의 코드 호환성을 안정적으로 보장해준다. 불명확한 함수명과 API의 버전이 오래되었다. 2. POSIX IPC 유닉스 시스템 프로그래밍 인터페이스 표준이다. IEEE (Institute of Electronic and Electronics Engineers)에서 표준화를 시도함 직관적인 API로 인해 비교적 사용하기 쉽다.","link":"/10/12/pipe/"},{"title":"IPC - 파이프 (Pipe)","text":"Pipe(파이프) 기법 기본적인 파이프 기법은 단방향 통신으로 구성되어 있습니다. Half-Duplex 통신이라고 불리기도 합니다. 두 개의 프로세스를 연결하여 한 쪽에서는 데이터를 write하고, 다른 한 쪽에서는 read만 할 수 있습니다. 또는 한 프로세스의 출력 스트림을 다른 프로세스의 입력 스트림으로 사용할 때 사용됩니다. C언어에서 fork()로 자식 프로세스를 생성했을 때, 부모와 자식간의 통신도 파이프를 통해 이루어지게 됩니다. 아래 예제를 통해 파이프 코드를 살펴보도록 하겠습니다. Pipe 예제 코드 1. 출력 스트림을 입력 스트림으로 사용Mac OS의 iterm에서 디렉토리 내 디렉토리, 파일을 보여주는 ls코드로 예제를 만들어 보겠습니다. ls -al를 입력하여 아래와 같은 화면이 출력되었습니다. 위 폴더 중 단어 code가 포함된 결과물만을 출력할 때 파이프 라인을 사용할 수 있습니다. ls -al | grep code 파이프 라인을 통하여 위 1차 출력을 입력으로 받고, 그 중 code가 포함된 결과물을 가져 옵니다. 여기서 |가 파이프 라인을 의미합니다.","link":"/10/12/realpipe/"},{"title":"Shell Script와 서버 작업 자동화","text":"쉘 스크립트를 통한 서버 작업 자동화 및 운영(DevOps) Why? 왜 필요한가? 서버는 일반적으로 로그파일을 생성한다. 생성 도중 용량 문제 등으로 작업이 중지되어 프로그램이 비정상적인 동작을 하여 다운되었다고 가정했을 때, 어떻게 문제를 해결할 수 있을까? 간단한 쉘 스크립트를 통해 일정 시간이 경과한 로그파일을 자동으로 삭제해주면 저장 공간에 대한 오류는 해결할 수 있다. 쉘 스크립트 쉘 명령어를 기본으로 하되, 몇 가지 문법이 추가된 형태이다. 쉘 스크립트는 filename.sh 형태의 파일로 작성 후, 파일을 실행한다. 기본 문법 파일의 가장 첫 라인은 #!/bin/bash로 시작한다. 쉘 스크립트 파일은 실행 시 권한을 가지고 있어야한다. - chmod 777 &lt;FileName&gt;등과 같이 실행 권한을 부여해준다. 1. 변수 변수명='text' 와 같이 띄어쓰기 없이 입력해준다. text 내의 띄어쓰기는 가능하다. $ 기호를 통해 변수임을 알려준다. 12345#!/bin/bashmy_name='Dongryeol Jeong'echo $my_name 2. 배열 변수명=(데이터1 데이터2 데이터3) 과 같이 배열을 선언할 수 있다. ${변수명[인덱스번호]) 로 배열을 출력할 수 있다. 123456789101112131415161718#!/bin/bashtest=(&quot;http&quot; &quot;sqld&quot; &quot;test&quot;)# 배열의 모든 데이터 출력 출력echo ${test[@]}echo ${test[*]}# 배열의 특정 인덱스 출력echo ${test[1]}# 배열의 크기 출력echo ${#test[@]}# 디렉토리의 파일 리스트를 배열로 입력받는 법file = $(ls)# 출력echo ${file[*]} 3. 지역변수 $$ : 쉘의 프로세스 번호, pid ls -al -z를 실행했을 때 $0 : 쉘 스크립트 이름 (ls) $1 ~ $9 : 명령 줄의 인수 ($1 : -al , $2 : -z) $* : 모든 명령줄 인수 리스트 (-al -z) $# : 인수의 개수 (2개) $? : 최근 실행한 명령어의 종료 값 0 : 성공 1 ~ 255 : 에러 메세지 4. 연산 `expr` : 숫자 계산 피 연산자와 연산 기호를 expr 뒤에 붙혀준다. 괄호에는 항상 \\(역슬래쉬)를 붙여주어야한다. 12345#!/bin/bashret=`expr \\( 10 + 20 \\) / 8 + 1`echo $ret 5. 조건문 if로 시작하여 fi로 끝내준다. 값 비교 문법 -z : 문자가 null이면 true -n : 문자가 null이면 false -eq : equal (같으면 참) -ne : not equal (다르면 참) -lt : less than -le : less or equal -gt : greater than -ge : greater or equal 파일 검사 문법 -e : 파일이 존재하면 true -d : 파일이 디렉토리이면 true -h : 심볼링 링크파일이면 true -f : 일반 파일이면 true -r : 읽기 가능하면 true -s : 파일 크기가 0이 아니면 true -u : 파일이 set-user-id가 설정되면 true -w : 파일이 쓰기 가능 상태이면 true -x : 파일이 실행 가능 상태이면 true 123456789#!/bin/bashif [ $1 -eq $2 ]then echo &quot;Same Values&quot; exitelse echo &quot;Different Values&quot;fi 6. 반복문for문 for 변수 in 변수값1 변수값 2 ... 로 범위를 설정하고, do 다음 줄에 실행구문을 작성하고 done으로 반복문을 종료한다. ls를 통해 디렉토리에 있는 모든 파일을 출력해주고 끝내는 반복문 123456#!/bin/bashfor data in $(ls)do echo $datadone while문123456789101112#!/bin/bashlist=$(ls)num=${#list[*]}index=0while [ $num -ge 0 ]do echo ${list[$index]} index=`expr $index + 1` num=`expr $num - 1`done 서버에서 쉘 스크립트 사용 ping 명령어를 통해 ip에 요청을 보내고 응답이 돌아올 시 “GateWay ping succeed” 구문을 출력하고, 실패 시 “GateWay ping failed” 구문을 출력하게 하여 서버가 열려있는지 확인할 수 있다. 타 컴퓨터와 협업을 할 때 ping을 통해 확인하고, 성공 시 작업을 수행하게 할 수 있다. 12345678910#!/bin/bashping -c 1 192.168.0.3 1&gt; /dev/nullif [ $? == 0 ]then echo &quot;GateWay ping succeed&quot;else echo &quot;GateWay ping failed&quot;fi 백업하기두 개의 인자를 받았을 때 null이면 파일을 만들어서 폴더에 넣어주고, 아니면 각각 디렉토리에 날짜를 포함한 이름을 설정하여 저장 압축 명령 tar : 과게어는 여러 파일을 묶기만 했었지만, 현재는 파일을 묶고 압축할 수 있다. 주요 옵션 x : 묶음 해제 c : 파일 묶음 v : 묶음 / 해제 과정을 화면에 표시 z : gunzip 사용 f : v파일 이름 지정 압축 시 주로 사용하는 옵션 : tar -cvzf [압축파일 이름] [압축할 파일 or 폴더명] 해제 시 주로 사용하는 옵션 : tar -xvzf [압출 해제할 아카이브 이름] 123456789101112131415#!/bin/bashif [ -z $1 ]||[ -z $2 ]; then echo usage: $0 sourcedir targetdirelse SRCDIR=$1 DSTDIR=$2 BACKUPFILE=backup.$(date +%y$m$d$H$M$S).tar.gz if [ -d $DSTDIR ]; then tar -cvzf $DSTDIR/$BACKUPFILE $SRCDIR else mkdir $DSTDIR tar -cvzf $DSTDIR/$BACKUPFILE $SRCDIR fifi Logfile 정리하기 정책을 먼저 정하고, 그에 따라 파일을 어떻게 관리해줄 것인지 구현한다. 2일이 경과한 log파일은 gz파일로 압축시켜주고, 압축된 지 3일이 경과한 파일은 삭제하도록한다. find 함수를 통해 아래와 같이 구현할 수 있다. 12345678910111213#!/bin/bashLOGDIR=/var/logGZIPDAY=1DELDAY=2cd $LOGDIRecho &quot;cd $LOGDIR&quot;sudo find . -type f -name '*log.*' -mtime +$GZIPDAY -exec bash -c &quot;gzip {}&quot; \\; 2&gt; /dev/nullsudo find . -type f -name '*.gz' -mtime +$DELDAY -exec bash -c &quot;rm -f {}&quot; \\; 2&gt; /dev/null","link":"/10/14/shell/"},{"title":"싱글톤 패턴 (Singleton Pattern)","text":"Singleton Pattern 이란 무엇인가?프로그램 내에서 오로지 1개만 존재하는 객체를 생성하여, 내부에서 이를 호출하여 사용하는 경우가 있습니다. 이벤트의 스케줄링, 환경설정, 로그 파일의 생성, 하드웨어 기기의 인터페이스, 캐시 등의 다양한 케이스가 있습니다. 위와 같은 상황에서 Singleton 패턴을 이용하여 객체를 프로그램 내부에서 단 1개만 생성하고,멀티 쓰레드 환경에서 이 객체를 공유하고, 동시 접근으로 인해 발생하는 동시성 문제도 해결할 수 있습니다. 정리 Singleton 패턴 프로그램 내에 특정 객체가 단 1개가 존재한다. 프로그램 내부의 다른 부분에서 이 객체를 공유하며 사용한다. Singleton를 사용하는 이유 장점 인스턴스를 1개만 생성함으로써, 메모리 공간을 절약할 수 있다. 호출할 때마다 생성하지 않아도 되므로, 로딩 시간이 절약된다. 어디서든 전역 변수처럼 사용할 수 있고, 다른 인스턴스들과 데이터 공유가 잘 이루어진다. 유의 사항 클래스 내부에서 객체를 직접 생성하기 때문에 DIP(Dependency Inversion Principle) 를 위배하게 된다. 특정 인터페이스에 의존하는 것이 아닌 한 개의 인스턴스에 의존, 전역적으로 직접 참조하게 됩니다. 이는 의존성 주입(Dependency Injection)을 통해 피할 수 있습니다. 멀티 쓰레드 환경에서 안전하게 구현하려면 Thread-Safe, 동기화 처리를 해주어야한다. Singleton 구현 기본 구현12345678910111213// 객체에 대한 직접적인 접근을 막기위해 private으로 생성private static CentralBank centralBank;// 생성자를 외부에서 접근할 수 없도록 private으로 설정private CentralBank(){};// 객체에 접근할 수 있는 public 코드 작성public static CentralBank getCentralBank(){ // 객체가 null이면 객체 생성 if (centralBank == null) { centralBank = new CentralBank(); } // 객체 return return centralBank;} 인스턴스와 생성자 모두 private으로 설정하여 외부에서 직접적인 접근을 막아줍니다. getCentralBank() 메서드를 통해서만 인스턴스에 접근이 가능합니다. 하지만 위 코드는 멀티 쓰레드 환경에서 Thread-safe를 보장하지 않습니다. 인스턴스가 null인 상태에서 두 개의 쓰레드에서 동시에 getInstance를 호출하면 instance를 두 번 생성할 수 있게 됩니다. 이를 해결하기 위해서는 동기화가 필요합니다. 동기화 구현12345678910111213// 객체에 대한 직접적인 접근을 막기위해 private으로 생성private static CentralBank centralBank;// 생성자를 외부에서 접근할 수 없도록 private으로 설정private CentralBank(){};// 객체에 접근할 수 있는 public 코드 작성public static synchronized CentralBank getCentralBank(){ // 객체가 null이면 객체 생성 if (centralBank == null) { centralBank = new CentralBank(); } // 객체 return return centralBank;} 여러 쓰레드가 동시 접근이 가능한 메서드에 synchronized 키워드를 추가하여 이를 해결할 수 있습니다. 위 코드에서는 Thread-safe는 보장되지만 속도가 저하된다는 문제가 발생합니다. 반갑게도 Thread-safe와 속도를 모두 보장하는 방법이 존재합니다. 아래에서 두 가지 예시로 살펴보도록 하겠습니다. Double Check Lock(DCL) 방식1234567891011121314151617181920public class CentralBank { // volatile 키워드를 통해 cache가 아닌 main memory에서 데이터를 읽고 쓴다. private volatile static CentralBank centralBank; private CentralBank() { } public static CentralBank getCentralBank() { // null인지 1번 체크 if (centralBank == null) { synchronized (CentralBank.class) { // 동기화 후에 null인지 다시 한번 체크 (Double check) if (centralBank == null) { centralBank = new CentralBank(); } } } return centralBank; }} 여러 쓰레드가 접근하는 인스턴스에 volatile 키워드를 추가해줍니다. volatile 키워드가 없을 때, 멀티 쓰레드 어플리케이션에서는 작업을 수행하는 동안 성능 향상을 위해 메인 메모리에서 읽은 변수의 값을 Cache에 저장합니다. 이 때, 각 CPU Cache에 저장되는 값이 불일치하는 상황이 발생할 수 있습니다. volatile 키워드를 추가하여 각 CPU의 Cache가 아닌 메인 메모리에 값을 저장하고 읽어오기 때문에, 불일치 문제를 해결할 수 있습니다. 인스턴스를 return해주는 getCentralBank()함수에서 Double-Check를 수행하게 됩니다. First Check 인스턴스를 호출할 때 null이면 동기화를 통해 class에 대한 접근을 Lock합니다. Second Check 접근을 막은 상태에서 다시 한 번 인스턴스가 null인지 확인하고, null이면 객체를 생성합니다. LazyHolder 방식123456789101112public class CentralBank { // 외부에서의 생성을 막기위해 private으로 설정 private CentralBank(){} // private한 내부 클래스를 만들고, 그 안에서 final로 인스턴스를 상수화시켜 생성 private static class LazyHolder{ private static final CentralBank centralBank = new CentralBank(); } // 호출 시 클래스에서 인스턴스를 호출 public CentralBank getCentralBank(){ return LazyHolder.centralBank; }} LazyHolder 방식은 윌리엄 푸가 제안한 방법으로 Bill Pugh Solution으로 불리기도 합니다. 클래스 내부에 private static class를 만들어 사용하고 싶을 때 public static 메서드를 통해 호출하게 됩니다. 이는 private static class의 특징을 이용하였습니다. private static class static이지만 메모리에 바로 올라가지 않고, 누군가가 getCentralBank() 메서드를 호출할 때만 호출이 되게 됩니다. 처음 호출할 때 JVM이 LazyHolder를 load하여 초기화합니다. LazyHolder 클래스를 초기화하면 인스턴스(centralBank)가 초기화시키기 위해 생성자를 호출합니다. 클래스 초기화 단계는 JLS에 의해 순차적으로 보장되므로, 호출 시에 추가적인 동기화는 불필요하게 됩니다. 또한 static 변수인 centralBank를 순차적으로 입력하기 때문에 동기화가 불필요합니다. 내부 변수 또한 final키워드를 통해 차후에 값이 변하지 않도록 설정하였습니다.","link":"/10/04/singleton/"},{"title":"어댑터 패턴 (Adapter Pattern)","text":"Adapter Pattern 이란 무엇인가? 어댑터 패턴은 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스를 변환해주는 패턴으로, 호환성이 없는 인터페이스로 인해 호환이 되지않는 클래스들을 함께 작동할 수 있도록 해준다. 대부분의 글에서 이 어댑터를 ‘돼지코’라 불리는 변환 어댑터를 예시로 듭니다. 또한 아래와 같은 사진을 자주 보실 수 있습니다. 여기서 Client는 사용자를 뜻합니다. Target은 돼지코를 꽂을 수 있는 콘센트입니다. 일본에 여행을 가서 핸드폰을 충전하려고 보니 콘센트가 110V 충전기만 호환되도록 11자 모양으로 구멍이 뚫려있습니다. Adaptee는 제가 가지고 있는 220V 충전기인데 일본 콘센트(Target)에 꽂을 수가 없겠죠? 이 때 필요한게 Adapter, 돼지코입니다. 돼지코는 220V의 콘센트를 받아 110V로 변환시켜줍니다. 돼지코의 단자, 출력은 Target(110V 콘센트)과 같은 110V입니다. 이 부분을 계속 떠올리셔야 헷갈리지 않게 구현할 수 있습니다. 여기서 포인트는 기존의 충전기 자체를 변경하지않고, 그대로 사용할 수 있는 것입니다. Adapter Pattern의 구현 돼지코를 통해 전체적인 흐름을 보았으니, 실무적인 영역으로 넘어가 보겠습니다. 1. Client는 항상 같은 Target을 통해 Web에 특정한 요청을 하고 있습니다. 2. Client에게 새로운 기능을 제공하기 위해 외부에 요청하여 바이트코드 파일을 전달받았습니다. 기존에 기능을 제공하는 Interface와 호환되지 않고, 직접적인 접근이 불가능합니다. 3. Adapter를 통해 기존 Interface와 외부 코드를 호환시켜줍니다. 이때 Adapter는 위의 돼지코 단자, 출력이 Target, 110V와 같은 것과 같이 기존 Interface와 같아야합니다. 1. Target (콘센트, WebRequester) Target은 WebRequester 입니다. 123public interface WebRequester { void requestHandler();} 2. 외부 코드 기존 Target Interface와 호환이 되지 않는 형태입니다. 예시에서는 제가 임의로 작성하였기에 직접적인 접근도 가능하고 수정이 가능하지만, 바이트코드로 저장해서 불러오면 직접적인 접근이 어렵습니다.12345public class NewService { public void newService(){ System.out.println(&quot;New Service&quot;); }} 3. Adapter 생성 계속 강조했던 부분이 나옵니다. 아래 질문에 대해 생각을 잠시 해보고 넘어가시면 좋습니다. Target(콘센트)은 몇 V였나요? 돼지코는 220V를 호환시켜주기 위해 220V를 받아주고, 결국 몇 V 였을까요? 여기서부터는 다시 정리를 하며 한 줄씩 작성해 나가보겠습니다. 3-1. 어댑터 클래스를 만들어줍니다. 123public class Adapter {} 12345질문1. 돼지코 예제에서 Target은 몇 V였나요?질문2. 돼지코는 몇 V에 꽂으려한 거 였을까요?&lt; 정답 : 콘센트와 돼지코는 호환이되는 110V였습니다. &gt; 3-2. Adapter를 Target과 호환시키기 위해 형태를 맞춰줍니다. Target, Adapter는 콘센트와 돼지코처럼 호환되기 위해 형태가 같아야겠죠? Adapter class에 WebRequester를 implements해줍니다. Interface였으니까 Override를 해주어야겠죠? 1234567public class Adapter implements WebRequester{ @Override public void requestHandler() { }} 4. 호환시켜주고 싶은 Adaptee를 Adapter에 꽂아줍니다. 돼지코만 콘센트에 꽂아두면 안되겠죠 ?, 돼지코에 220V 충전기(Adaptee)를 연결해주어야 의미가 있는 거겠죠 ! 여기서 Adaptee는 2번에서 보았던 외부 코드, 새로운 기능입니다. NewService 클래스를 Adapter에 주입해주었습니다 (돼지코(Adapter)에 220V(NewService)를 꽂아준 것입니다.) 다른 클래스의 객체를 내부에 주입시키는 것을 의존성 주입(Dependency Injection)이라고 합니다. 123456789101112public class Adapter implements WebRequester{ NewService newService; public Adapter(NewService newService){ this.newService = newService; } @Override public void requestHandler() { newService.newService(); }} 5. Adapter Pattern 완성 4번과 같이 의존성 주입을 통해 호환이 되지 않던 기능과 인터페이스가 Adapter를 통해 호환이 되게 되었습니다! 테스트를 해보겠습니다. 궁극적인 형태는 WebRequester(Target)였죠? WebRequester webRequester = NewService를 Adapter에 꽂아 형태를 맞춰줍니다. new Adapter(new NewService()) 1234567public class Main { public static void main(String[] args) { WebRequester webRequester = new Adapter(new NewService()); webRequester.requestHandler(); }}","link":"/10/14/adapter/"},{"title":"Spring Boot에서의 Exception 처리","text":"Web Application의 입장에서, 에러가 발생했을 때 처리해줄 수 있는 방법은 많지 않다.크게 에러 페이지, 4 ~ 500번대 에러, 별도의 에러 메세지 전달 정도가 있다. 아래 예제 코드를 통해 확인해보도록 하자. name(String), age(Integer) 속성을 가지고 있는 User 객체에, controller에서 Integer와 int의 합을 도출하도록 해서 억지로 에러를 발생시켜 보았다. User 코드 확인하기 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.exception.dto;import javax.validation.constraints.Min;import javax.validation.constraints.NotEmpty;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;public class User { @NotEmpty @Size(min = 2, max = 10) private String name; @Min(1) @NotNull private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return &quot;User{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; }} Controller 코드 확인하기 123456789101112131415161718192021222324252627package com.example.exception.controller;import com.example.exception.dto.User;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/api&quot;)public class ApiController { @GetMapping(&quot;&quot;) public User get(@RequestParam(required = false) String name, @RequestParam(required = false) Integer age){ User user = new User(); user.setName(name); user.setAge(age); // 에러 발생 시키기 int a = 10+age; return user; } @PostMapping(&quot;&quot;) public User post(@RequestBody User user){ System.out.println(user); return user; }} Client에게 친절한 Exception 처리는 기본적으로 두 가지 방식이 있다. 이를 Advice(조언) 이라고 한다. Server에서 Client에게 오류에 대한 조언을 해주는 것이다. 관련 Annotation @RestControllerAdvice 페이징 처리를 하는 view resolver 영역의 white label page, error page를 global하게 처리할 수 있는 집합 장소 @ExceptionHandler Global하게 처리할 때는 RestControllerAdvice Annotation이 붙은 클래스 내에, 특정 Controller의 예외 처리를 할 때 특정 컨트롤러 내부에 사용한다. 동일한 Handler가 Global, Controller에 모두 존재하면 특정 Controller 내부의 handler가 처리된다. 전역으로 처리하는 handler 생성 1234567891011121314151617181920package com.example.exception.advice;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;@RestControllerAdvicepublic class GlobalControlAdvice { @ExceptionHandler(value = Exception.class) public ResponseEntity exception(Exception e){ System.out.println(e.getClass().getName()); System.out.println(&quot;------------&quot;); System.out.println(e.getLocalizedMessage()); System.out.println(&quot;------------&quot;); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage()); }} 특정 Exception 처리하는 handler생성 12345@ExceptionHandler(value = NullPointerException.class)public ResponseEntity methodArg(NullPointerException e){ return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(&quot;값이 유효하지 않습니다.&quot;);} 혹은 RestControllerAdvice Annotation에 basePackageClasses인자를 추가하여 특정 컨트롤러에 한정 시킬 수 있다. @RestControllerAdvice(basePackageClasses = ApiController.class) Client 단에서 발생할 수 있는 에러 Client가 발생시킬 수 있는 에러는 형식에 맞지 않게 값을 입력하는 것이다. 이름을 1글자만 입력하거나, 나이를 0살로 입력하는 등의 예가 있다. Validated Annotation을 클래스 단에 추가해준 뒤 GetMapping을 해주는 get 메서드의 RequestParam에 제한 사항을 추가해 주었다. 이름을 최소 2글자 이상 작성하여야 하고, 나이는 최소 1살이며 비워두면 안된다. Validated 예제코드 확인하기 1234567891011121314151617181920@RestController@RequestMapping(&quot;/api&quot;)@Validatedpublic class ApiController { @GetMapping(&quot;&quot;) public User get( @Size(min = 2) @RequestParam String name, @NotNull @Min(1) @RequestParam Integer age){ User user = new User(); user.setName(name); user.setAge(age); return user; }} 처음 접근은 Client단에서 값을 잘못입력했을 때어떠한 Exception이 발생하는지 확인하는 것으로 시작한다.12345678910111213// ApiController 클래스에서 발생한 오류@RestControllerAdvice(basePackageClasses = ApiController.class)public class ApiControllerAdvice { // Exception 클래스 내부의 객체가 들어오면 실행 (모든 Exception을 받는다) @ExceptionHandler(value = Exception.class) public ResponseEntity exception(Exception e) { // Exception의 클래스 이름을 출력하여 확인한다. System.out.println(e.getClass().getName()); // 테스트 코드이므로 Client 단에는 아무것도 출력되지 않도록 하였습니다. return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;&quot;); } ...} Chrome의 확장 프로그램인 Talend API를 통해 서버 테스트를 해보았다. RequestParameter에 아무 값도 넣어주지 않아 아래와 같은 에러가 도출됐다. 위와 같이 Spring에서 자체적으로 예외에 대한 기본적인 처리는 해준다. 출력된 클래스는 org.springframework.web.bind.MissingServletRequestParameterException가 IDE에 출력되었다. MissingServletRequestParameterException이 잡혔으니 value값을 이로 설정해서 원하는 정보를 제공할 수 있도록 구현해보자. 1234@ExceptionHandler(value = MissingServletRequestParameterException.class)public ResponseEntity missingServletRequestParameterException(MissingServletRequestParameterException e){ return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(&quot;값이 입력되지 않았습니다.&quot;);} 위와 같이 body에 정보를 보내주고, HttpStatus는 400을 띄워주었다. 보다 Client들이 발생시키는 오류를 줄일 수 있다.","link":"/10/18/SpringException/"},{"title":"Servlet 이란","text":"Servlet의 특징 servlet은 class이고, 이식성이 뛰어나다.Multi-Thread 멀티 스레드로 동작하여 성능이 뛰어나다.플랫폼 독립성 java와 같이 플랫폼에 독립적인 기술이다.서버 독립성 servlet은 웹 서버와 무관하게 실행된다.확장성 다양한 vendor에서 제공하는 클래스 라이브러리를 jar형태로 받아 사용할 수 있다.동적인 요청이 들어오면 engine이 처리, 정적인 요청은 web server가 처리한다.servlet을 생성하지 않다가, 동적인 요청이 들어오면 servlet을 생성한다. 엔진이 servlet객쳉을 생성해서, method를 호출해준다. Servlet의 문법 서블릿 엔진이 접근을 해야하기 때문에 Servlet은 반드시 public으로 작성해야하고, 반드시 Default 생성자만 있어야한다. 멤버 변수를 default 초기화한다고해서, default 생성자이다. HTTP 프로토콜 상에서 동작하는 sevlet이라면 반드시 HttpServlet 클래스를 상속해야한다. 상속 관계 : 내가 만든 Servlet -&gt; HttpServlet -&gt; GenericServlet -&gt; Servlet 상속을 해주어야만 Servlet타입을 가질 수 있게 된다. 다른 servlet을 상속해도 되지만, web에서 사용할 수 없다. Http 프로토콜에서 최적화된 HTTPServelt을 상속해주어야한다. 라이프 사이클과 관련된 HttpServlet 클래스의 callback method를 적절하게 override 해주어야한다. callback method : 서블릿 엔진이 적절한 시점에 호출해주는 메서드 우리가 직접 호출하지 않는다. 흐름 Servlet 객체는 메모리에 1개만 존재할 수 있다. Servlet Engine이 생성되는 순간 Thread Pool을 생성한다. 서버마다 Thread 개수다 다르다. 브라우저에서 html, image 파일이 아닌 요청을 보내면 Servlet 엔진으로 전달된다. 요청하는 Servlet이 메모리에 있는지 확인한다. 메모리에 있을 시 바로 4번으로 이동한다. Servlet class파일을 찾아서 로딩하고, 생성자를 호출하고, 객체가 생성된 직후에 init() 메서드를 호출한다. default 생성자로 생성된 객체를 init() 메서드가 멤버 변수를 초기화 시켜준다. Thread를 할당받고, run() 메서드가 실행된다. Thread Pool에 있는 Thread 중에서 랜덤으로 할당받는다. run() 메서드가 service()를 호출한다. service() 메서드를 overriding하지 않으면 부모로부터 상속받는다. 요청 방식이 get방식의 메서드인지, post방식의 메서드인지 분기시킨다. Servlet을 수정하고 저장 하면 Reloading을 해준다. destroy() 메서드가 호출되고 수정된 Servlet으로 교체된다. 혹은 server를 종료시키면, 엔진은 생성한 객체를 destory하고 종료된다. Servlet은 최초 호출 시에만 느리고, 그 후에는 바로 Thread를 할당받으므로 빠르게 작동한다.","link":"/10/30/servlet/"},{"title":"Spring Boot Validation check","text":"Validation 이란Java에서 null 값에 대한 접근이 발생할 때 null pointer exception이 발생하므로, 이를 사전에 방지하기 위해 유효성을 검사하는 과정이 Validation 입니다. 일반적인 java 코드에서 validation을 체크하는 예제 코드를 확인해보겠습니다.parameter의 값이 null이면 exception이 발생할 수 있으므로, null이 들어오면 return을 하여 이를 막아줍니다. 123456public void showPrice(int price){ if (price == null) { return ; } // 정상 Logic ... 위 코드에서는 검증해야 할 값이 1개지만, 값이 많아질수록 코드가 길어지고, 재사용성에 한계가 있습니다. 또한 유지 보수 측면에서도 바람직하지 않으며 일반적으로 Service Logic과 분리가 필요합니다.. Spring Boot Validation build.gradle에 implementation 'org.springframework.boot:spring-boot-starter-validation'을 추가하여 사용할 수 있다. 클래스 혹은 원하는 변수위에 Annotation을 추가하여 사용할 수 있습니다. 1234567891011public class User { @NotBlank private String name; @Max(value = 90) private int age; @Email private String Email; @YearMonth private String birthday; ...} @Size : 문자 길이 설정 min, max값을 통해 최소, 최대 문자 길이 설정 가능 @NotNull : null 불가 @NotEmpty : null 또는 “”(빈문자열) 불가 @NotBlank : null 또는 “”(빈문자열), “ “(공백) 불가 @Past : 과거 날짜 @PastOrPresent : 과거 혹은 오늘 날짜 @Future : 미래 날짜 @Pattern : 정규식 적용 regex = “[정규식]” 과 같이 사용할 수 있다. @Max, @Min : 최대, 최소값 설정 @Valid : 해당 object에 대해 validation 실행 아래 예시와 같이 ResponseBody로 들어오는 User객체에 대해 Validation을 실행해줍니다. 객체의 왼쪽, 오른쪽 아무 곳에나 붙여도 상관 없습니다.123public ResponseEntity post(@Valid @RequestBody User user, BindingResult bindingResult){ ... } Custom Validation 원하는 Validation이 존재하지 않을 때 custom으로 생성하여 사용하는 예제를 확인해보겠습니다. 먼저 Annotation을 생성해주고, 이를 통작하게 해줄 Validator를 구현해주어야합니다. 저는 아래 예시를 통해 올바른 연(Year), 월(Month) 형식이 들어오는지 체크하는 Annotation을 생성해보겠습니다. 1. Annotation 생성 Annotation의 Annotation (Annotation의 범위, 타겟 등 설정) Constraint : 어떤 클래스(validator)에 의해 유효성 검사가 될 것인지 설정 Target에는 임의로 메서드, 필드 등을 넣어주었습니다. 실행 중일 때 동작하도록 Retention은 RUNTIME으로 설정하였습니다. 메타 정보 생성 message() : 유효하지 않을 시 출력해주는 message를 관리하기 위해 사용됩니다. groups() : Validation을 적용할 그룹을 제한할 수 있습니다. payload() : Custom Annotation에 관련된 메타 정보를 정의합니다. Error가 발생했을 때 심각도를 나타냅니다. payload = Severity.Error.class와 같이 사용합니다. pattern() : 날짜 검증을 위해서 기본 형식을 설정해주었습니다. 12345678910111213@Constraint(validatedBy = {YearMonthValidator.class})@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })@Retention(RUNTIME)public @interface YearMonth { String message() default &quot;yyyyMMdd 형식으로 입력하세요&quot;; Class&lt;?&gt;[] groups() default { }; Class&lt;? extends Payload&gt;[] payload() default { }; String pattern() default &quot;yyyyMMdd&quot;;} 2. Validator 생성위에서 생성한 @YearMonth를 동작시키기 위해서 Validator가 필요합니다. 1. ConstraintValidator&lt;**동작시킬 Annotation**, **검증 객체 타입**&gt;을 implements 해줍니다.2. 객체 검증 기준 생성 위에서 Annotation을 생성할 때, 검증할 때 기준이 되는 String을 pattern()으로 초기화시켜놓았습니다. 이 패턴을 가져오기 위해 같은 자료형의 변수를 생성해줍니다. 3. initailize(YearMonth constraintAnnotation)메서드를 Override해줍니다. Argument로 들어있는 YearMonth에 Custom Annotation을 넣어주면 됩니다. 2번에서 생성한 변수에 Annotation에서 초기화해주었던 pattern을 넣어줍니다. 4. isValid(String value, ContraintValidatorContext context) 메서드 Override 비교값과, 정해놓은 기준을 비교하여 유효성을 체크해주는 함수입니다. 저는 애초에 연(Year), 월(Month)를 체크하고자 Custom Validator를 만들고 있었습니다. LocalDate로는 연, 월, 일 값만 비교할 수 있기 때문에, 모든 월이 가지고 있는 01일을 비교값에 추가해주었습니다. 123456789101112131415161718192021public class YearMonthValidator implements ConstraintValidator&lt;YearMonth, String&gt; { private String pattern; @Override public void initialize(YearMonth constraintAnnotation) { this.pattern = constraintAnnotation.pattern(); } @Override public boolean isValid(String value, ConstraintValidatorContext context) { try{ LocalDate localDate = LocalDate.parse(value+&quot;01&quot;, DateTimeFormatter.ofPattern(pattern)); } catch (Exception e){ return false; } return true; }} Custom Validation 사용 Target에 Field를 입력해주었기 때문에, 변수에도 사용할 수 있습니다.12345678910111213141516아래와 같이 birthday라는 변수 위에 Annotation을 추가해주었으며,```javapublic class User { @NotBlank private String name; @Max(value = 90) private int age; @Email private String Email; @YearMonth private String birthday; ...} 컨트롤러 단에서 User 객체의 멤버 변수에 설정한 Annotation들이 동작하도록 @Valid라는 Annotation을 입력해주었습니다. 123public ResponseEntity post(@Valid @RequestBody User user, BindingResult bindingResult){ ... }","link":"/10/25/springvalidation/"},{"title":"Spring - filter","text":"Filter 란 ? Spring은 Client로부터 request를 받고, response를 줄 때 Filter를 거쳐서 전달해준다. Filter는 웹 어플리케이션에서 관리되는 영역으로, Spring에 의해서 데이터가 변환 되기 전, Client가 보낸 순수한 요청, 응답 값을 확인할 수 있다. Filter의 사용 절차 Filter를 사용하기 위해 Filter를 implements한 클래스를 생성한다. WebFilter 어노테이션을 추가하고, 적용범위를 설정한다. default = 모든 url doFilter() 메서드를 오버라이드한다. SpringBootApplication 어노테이션이 추가된 메인부에 @ServletComponentScan을 추가해준다 doFilter() 메서드메서드의 parameter로 FilterChain 타입의 chain을 받을 수 있다. chain.doFilter() 메서드를 기준으로 필터에 들어오기 전, 후를 구분할 수 있다. &lt; 전처리 &gt;다른 parameter 중 ServletRequest request, ServletResponse reponse가 들어온다. 위 Servlet 타입은 response, request를 단 1번만 사용할 수 있다. 들어온 요청을 log로 서버에 남기면 이를 다른 용도로 활용할 수 없는 것이다. 따라서 ContentCahchingRequestWrapper, ContentCachingResponseWrapper를 생성해준다. 생성자의 인자로 ServletRequest과 ServletResponse를 사용할 수 있다. &lt; 후처리 &gt;서버에는 사용자가 보낸 내용과, 요청을 보낸 uri를 확인하기 위해 get메서드를 통해 로그로 남겨주었다. 응답으로 보내주는 httpStatus와 content 또한 저장하며 log에 기록해주었다. 1. TalentAPI를 통해 객체에 맞는 데이터를 post 해준다. 2. Post한 값과, uri가 log로 찍힌다. 3. Response 한 값과 HttpStatus가 알맞게 log에 찍히는 것을 확인할 수 있다. 1234567891011121314151617181920212223242526@WebFilter(urlPatterns = &quot;/api/user/*&quot;)public class GlobalFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 전처리 ContentCachingRequestWrapper contentCachingRequestWrapper = new ContentCachingRequestWrapper((HttpServletRequest) request); ContentCachingResponseWrapper contentCachingResponseWrapper = new ContentCachingResponseWrapper((HttpServletResponse) response); // 필터 chain.doFilter(contentCachingRequestWrapper, contentCachingResponseWrapper); // 후처리 String reqContetnt = new String(contentCachingRequestWrapper.getContentAsByteArray()); String url = contentCachingRequestWrapper.getRequestURI(); log.info(&quot;url : {}, reqContent : {}&quot;, url, reqContetnt); int httpStatus = contentCachingResponseWrapper.getStatus(); String content = new String(contentCachingResponseWrapper.getContentAsByteArray()); log.info(&quot;http status : {}, content : {}&quot;, httpStatus, content); contentCachingResponseWrapper.copyBodyToResponse(); }}","link":"/10/26/springfilter/"},{"title":"Annotation 기반 Servlet 설정","text":"WebServlet Annotation @WebServlet(urlPatterns = &quot;/insertBoard.do&quot;, initParams = @WebInitParam(name = &quot;encoding&quot;, value = &quot;EUC-KR&quot;)) web.xml 파일의 servlet-mapping 내의 내용을 넣어줄 수 있다. init-paramxml에 대한 설정을 하는 것이 java 소스코드와 분리되어있어, Annotation 기반으로 처리하게 되었다. initParams = 초기화 parameter들을 servlet으로 넘겨줄 수 있다. Servlet객체를 생성한 후에 ServletConfig 생성 -&gt; parameter value 호출 -&gt; init()에게 넘겨준다. 123456public void init(ServletConfig config) throws ServletException { // ServletConfig를 이용하면 web.xml에 설정된 로컬 파라미터 정보를 추출할 수 있다. boardEncoding = config.getInitParameter(&quot;encoding&quot;); /* ... */} Global Parameter 설정12345&lt;!-- Global Parameter --&gt;&lt;context-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;EUC-KR&lt;/param-value&gt;&lt;/context-param&gt; 원하는 servlet의 service()단에서 아래 코드를 통해 적용 가능하다. 1234/* ... */ServletContext context = getServletContext();boardEncoding = context.getInitParameter(&quot;encoding&quot;);/* ... */ ServletContext는 ServletEngine을 객체화 시킨 거라고 생각하면 된다. 어디서든, 여려번 parameter에 접근하여 사용할 수 있다. ServletConfig는 Servlet이 생성되고, init()이 호출될 때만 사용할 수 있다.","link":"/11/02/webServlet/"},{"title":"JPA Methods","text":"ORM은 java 객체와 DB record와의 연동을 해주는 것이므로, 최종 동작은 SQL 쿼리가 실행된다. JpaRepository의 메서드를 통해 실행되는 실제 쿼리들을 살펴볼 수 있다. show-sql : 메서드를 통해 실행되는 쿼리를 log로 찍을 수 있음 properties:hibernate:format_sql : 보기 좋게 정렬 1234567spring: jpa: defer-datasource-initialization: true show-sql: true properties: hibernate: format_sql: true Method getOne(), getById(), FindById()getOne() Entity에 대해서 Lazy Loading을 하여, Spring Data JPA 2.5 버전 이전에만 사용되었다. 일반적으로 객체를 getOne()으로 불러와 저장, 출력 등을 실행할 때 session이 만료되기 때문에 @Transactional 어노테이션과 함께 사용하여야한다. 더 이상 사용되지 않는 getOne() 메서드를 getById() 메서드가 대체합니다.참조값을 return해주기 때문에, query를 통해 구현되던 기존의 getById() 메서드로 대체합니다.이로 인해 transaction 외부에서 LazyLoadingException이 발생할 수 있는데, 이를 방지하기 위해 getById()메서드를 getXyzId() 메서드로 변경해야한다.Xyz에는 아무 문자열이나 들어갈 수 있다.출처 : Spring Data JPA docs 1234567@Deprecated@Overridepublic T getOne(ID id) { Assert.notNull(id, ID_MUST_NOT_BE_NULL); return em.getReference(getDomainClass(), id); } 위와 같이 EntityManager em이 reference만 가지고있고, 실제 값을 구하는 시점에 세션을 통해 값을 가져와야한다. getById() JPA 2.5 버전 이상에서 getOne()과 같이 사용하면 됩니다. 구현 코드 또한 같다. findById() Opional entity를 리턴해주며, Eager Loading 방식이다. Optional 객체로 wrapping되어 있기 때문에 별도의 처리가 필요하다. 아래와 같이 해당 객체가 없으면 null을 리턴하도록 처리하였다. 123User user = userRepository.findById(1L).orElse(null);System.out.println(user); 1return Optional.ofNullable(type == null ? em.find(domainType, id, hints) : em.find(domainType, id, type, hints)); Entity Manger에서 바로 find()메서드를 통해 가져온다. Sort()sort.by를 사용하면 ORDER BY 쿼리가 실행된다. 123List&lt;User&gt; users = userRepository.findAll(Sort.by(Sort.Direction.DESC, &quot;name&quot;));users.forEach(System.out::println); findAllById()findAllById, findById를 사용하면 WHERE 쿼리를 사용한다. 123List&lt;Long&gt; ids = new ArrayList&lt;Long&gt;;ids.add(1L);/* ... */ Main 폴더에서 사용할 때는 위와 같이 ArrayList를 생성해서 값을 넣어주어야한다. 하지만 Test 코드에서는 assrtj의 클래스를 사용하여 아래와 같이 사용할 수 있다. 12List&lt;User&gt; users = userRepository.findAllById(Lists.newArrayList(1L, 3L, 5L));users.forEach(System.out::println); saveAll()saveAll()을 실행하면 각 객체에 대해 INSERT 쿼리를 객체 수만큼 실행한다. 1234User user1 = new User(&quot;inwoo&quot;, &quot;inwoo@gmail.com&quot;);User user2 = new User(&quot;eddy&quot;, &quot;eddy@gmail.com&quot;);userRepository.saveAll(Lists.newArrayList(user1, user2)); flush(), saveAndFlush()flush()를 실행하여 DB에 반영하는 시점을 제어할 수 있다. saveAndFlush()는 저장 후 바로 DB에 반영을 시켜주는 메서드이다. 12345userRepostiory.save(new User(&quot;inwoo&quot;, &quot;inwoo@gmail.com&quot;));userRepository.flush();userRepository.saveAndFlush(); count()count는 이름 그대로 Repository의 데이터가 개수를 리턴해준다.리턴 타입은 long이다. 1long count = userRepository.count(); existsById()Id 값을 parameter로 넣어 해당 id에 해당하는 데이터가 있는지 boolean 타입으로 리턴한다. 1boolean exists = userRepository.existsById(1L); delete()해당 데이터를 찾아서 parameter로 입력하면 data를 WHERE 쿼리를 통해 삭제한다. 1userRepository.delete(userRepository.findById(1L).orElseThrow(RuntimeException::new)); etc. (Page, QBE) Page Page는 데이터를 literally page 형태로 감싸준다. 아래 코드는 repo에 있는 모든 데이터를 Pagerequest를 통해 1페이지의 데이터를 가져오고, 1페이지당 size 3으로 나누어 생성한다. 1Page&lt;User&gt; users = userRepository.findAll(PageRequest.of(1,3)); 위 코드의 users 페이지의 getter()를 통해 다양한 데이터를 호출할 수 있다. 123456System.out.println(&quot;page 정보 : &quot; + users);System.out.println(&quot;전체 데이터 개수 : &quot; + users.getTotalElements());System.out.println(&quot;데이터 리스트를 size로 나누었을 때 나온 전체 페이지&quot; + users.getTotalPages());System.out.println(&quot;PageRequest에 요청했던 페이지에 있는 데이터 개수 (zero-bases)&quot; + users.getNumberOfElements());System.out.println(&quot;Sort로 설정한 값&quot; + users.getSort());System.out.println(&quot;PageRequest에 요청했던 페이지 1개당 size&quot; + users.getSize()); QBE (Query By Example) QBE는 단어그대로 Example과 Matcher를 생성하여, 해당된 데이터를 찾아내는 방식이다. 1234567ExampleMatcher matcher = ExampleMatcher.matching() // matching 선언 .withIgenorePaths(&quot;name&quot;) // matching에서 제외할 column 설정 .withMatcher(&quot;email&quot;, endsWith()); // email column에서 설정한 단어로 끝나는 데이터가 있으면 matchExample&lt;User&gt; example = Example.of(new User(&quot;Any name does'nt care&quot;, &quot;gmail.com&quot;), matcher);userRepository.findAll(example).forEach(System.out::println); 위 코드를 보면 먼저 ExampleMatcher를 생성하고, Example의 타입을 알맞은 Data 타입으로 설정해준다. 내부에서 임시적으로 객체를 생성하여, 이 객체와 matching되는 데이터를 matcher를 통해 찾는다.","link":"/11/03/jpa/"},{"title":"TroubleShooting SpringBoot와 data.sql 충돌","text":"결론해결 방안을 얻고 싶은 분은 이 부분만 참고하시면 됩니다. Spring Boot 2.5 버전 이상에서 h2 DB를 통한 테스트를 실행할 때,1. SQL의 Column은 `(grave accent)로 감싸고, Value는 '(single quote)로 감쌌는지 확인2. yml파일에 spring:jpa:defer-datasource-initialization: true 추가하기 발단 1. Spring Boot에서 sql파일을 생성하고, JPA 연동을 통해 데이터가 잘 로드되는지 간단한 테스트를 하기위해 프로젝트를 생성했다. build.gradle 확인하기 123456789101112131415161718192021222324252627282930313233plugins { id 'org.springframework.boot' version '2.5.6' id 'io.spring.dependency-management' version '1.0.11.RELEASE' id 'java'}group = 'com.inwoo.jpa'version = '0.0.1-SNAPSHOT'sourceCompatibility = '1.8'configurations { compileOnly { extendsFrom annotationProcessor }}repositories { mavenCentral()}dependencies { implementation 'org.springframework.boot:spring-boot-starter-data-jpa' implementation 'org.springframework.boot:spring-boot-starter-web' compileOnly 'org.projectlombok:lombok' runtimeOnly 'com.h2database:h2' annotationProcessor 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test'}test { useJUnitPlatform()} 2. main 폴더 하위에 JpaRepository를 상속받은 repo를 생성하고, test폴더 하위 resource 폴더 내에 data.sql 파일을 생성하였다.Primary Key인 id 증가를 위해 call next value for hibernate_sequence; 코드를 추가해주었다. 1234567891011121314call next value for hibernate_sequence;insert into user ('id', 'name', 'email', 'created_at', 'updated_at') values (1, 'INWOO', 'INWOO@NAVER.COM', now(), now());call next value for hibernate_sequence;insert into user ('id', 'name', 'email', 'created_at', 'updated_at') values (2, 'DENNIS', 'DENNIS@NAVER.COM', now(), now());call next value for hibernate_sequence;insert into user ('id', 'name', 'email', 'created_at', 'updated_at') values (3, 'SOPHIA', 'SOPHIA@GOOGLE.COM', now(), now());call next value for hibernate_sequence;insert into user ('id', 'name', 'email', 'created_at', 'updated_at') values (4, 'JAMES', 'JAMES@GMAIL.COM', now(), now());call next value for hibernate_sequence;insert into user ('id', 'name', 'email', 'created_at', 'updated_at') values (5, 'INWOO', 'inwoo@gmail.com', now(), now()); 3. Test 코드에 repo를 DI한 후 crud 테스트를 진행하였다. 결과 BeanCreationException 발생Bean Definition에 있는 bean을 생성하려할 때 BeanFactory에서 발생하는 예외입니다. Error creating bean with name ‘dataSourceScriptDatabaseInitializer’ defined in class path resource [path]: class path에 위치한 Database와 관련된 bean을 생성할 때 오류가 발생하였다. Invocation of init method failed; nested exception is org.springframework.jdbc.datasource.init.ScriptStatementFailedException: init 메서드를 호출 실패; ScriptStatementFailedException 예외도 따라서 발생되었다. Failed to execute SQL script statement #2 of URL [filepath]: path의 2번째에 위치한 script 실행이 실패하였다. 해결 시도 Controller 테스트는 통과하였고, 생성한 repository는 상속만 받았다. 테스트 코드에서 Autowired를 해주었고, 단순 메서드만 호출하였기 때문에 오류는 없었다. Exception을 참고하여 Spring 자체에서 Bean 자체를 생성하지 못하고 있다는 걸 깨달았다. SpringBoot 2.5 버전이 나올 때 어떤 이슈가 있었는지 찾아보기 위해 Release Notes를 확인해보았다.Release Notes 이슈 schema.sql and data.sql Files With Spring Boot 2.5.1 and above, the new SQL initialization properties support detection of embedded datasources for JDBC and R2DBC. Spring Boot 2.5.1버전 이상부터 새로운 SQL initialization 속성이 JDBC와 R2DBC의 source를 찾아줍니다. By default, SQL database initialization is only performed when using an embedded in-memory database. Default로는 in-memory db를 사용할 때만 초기화가 동작합니다. To always initialize a SQL database, irrespective of its type, set spring.sql.init.mode to always. 모든 Type의 SQL DB를 초기화를 적용하기 위해 spring.sql.init.mode 값을 always로 바꿔주어야합니다. application.yml 파일의 설정을 아무리 바꿔주어도 해결되지 않았다.그래서 build.gradle 파일을 확인해보았는데, dependency와 test가 제대로 build 되지 않고 있었다. vi $HOME/.zsh를 통해 jdk 버전을 확인해보았는데 jdk가 16버전이었고, 이는 gradle과 아직 호환이 되지 않는 버전이었다. 그래도 실행이 되지 않았다.. 해결 sql에 syntax 오류가 있는지 확인해봤는데 자세히 보니 column은 (grave accent)로 닫아주고 value는 '(Single Quote)로 닫아주었다 123456789101112131415call next value for hibernate_sequence;insert into user (`id`, `name`, `email`, `created_at`,`updated_at`) values (1, 'martin', 'martin@fastcampus.com', now(), now());call next value for hibernate_sequence;insert into user (`id`, `name`, `email`, `created_at`,`updated_at`) values (2, 'dennis', 'dennis@fastcampus.com', now(), now());call next value for hibernate_sequence;insert into user (`id`, `name`, `email`, `created_at`,`updated_at`) values (3, 'sophia', 'sophia@slowcampus.com', now(), now());call next value for hibernate_sequence;insert into user (`id`, `name`, `email`, `created_at`,`updated_at`) values (4, 'inwoo', 'inwoo@slowcampus.com', now(), now());call next value for hibernate_sequence;insert into user (`id`, `name`, `email`, `created_at`,`updated_at`) values (5, 'inwoo', 'inwoo@google.com', now(), now());","link":"/11/03/jpaTroubleShooting/"},{"title":"gRPC 탐구 생활 (1)","text":"네트워크 통신로컬 컴퓨터의 프로세스 ↔️ 서버 컴퓨터의 프로세스의 IPC 통신이다. 시작 (21. 10. 29.) 한 달 전에 gRPC에 관심이 생겨서 Docs를 찾아보고, 내용을 정리하여 글을 작성했었다. 오늘 프로토콜 관련 강의를 듣다가, HTTP는 Header에 많은 데이터가 들어가서 현업에서 무겁다는 평가를 받고 있다는 소식을 들었다. 이 때 gRPC가 계속해서 강조해오던 빠른 데이터 처리, 편리하고 유연한 환경이 떠올라 gRPC Quick Start를 통해 실행해 본 과정과 결과에 대해 작성하려 한다. Quick Start (21. 10. 29) 설치 전 환경 설정issue : gradle과 자바 버전gRPC는 JDK 버전이 7 버전 이상이어야 사용할 수 있다. 나는 16 버전을 사용하고 있어서, 당연히 사용할 수 있을 줄 알았다. 결과적으로 설치 이후에는 16 버전을 사용해도 상관없었다. gRPC가 안내한 방법에는 gradle을 통한 설치 방법이 나와있는데, gradle은 아직 자바 16 버전을 지원하지 않고 있다. 설치 시 General error during semantic analysis: Unsupported class file major version 60 오류가 발생하였다. 7 이상 15버전 이하를 사용하면 gradle을 통해 설치할 수 있고, 버전을 다운로드 받은 후 환경 변수를 설정해주면 된다. Mac OS 환경변수 설정법 확인 cd /Library/Java/JavaVirtualMachines 로 이동 ls -al 을 통해 설치되어있는 jdk 버전 확인 Big sur 버전 이상 : vi $HOME/.zshrcBir sur 버전 미만 : vi ~/.bash_profile export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk폴더이름/Contents/Home 입력 설치원하는 폴더로 이동하여 git clone을 통하여 설치하거나, zip 파일을 다운로드하여 압축 해제를 해주면된다. 원하는 폴더로 이동한다. $ git clone -b v1.41.0 https://github.com/grpc/grpc-java를 입력하여 파일을 받는다. cd grpc-java/examples 를 통해 폴더를 이동해준다. ./gradlew installDist로 설치를 해준다. 테스트gRPC는 서버와 서버 간의 통신에서 자주 사용된다. 테스트도 위와 같은 상황에서 진행을 해보았다. 이를 위해 터미널 2개를 켜놓고 실행해주어야 한다. 1개는 Client, 1개는 Server의 역할을 해줄 것이다. 아래 예제 코드는 grpc-java의 하위 폴더 example에서 실행해주어야 한다. 1. Server 역할 Terminal$ ./build/install/examples/bin/hello-world-server 위 명령어를 실행하면 INFO: Server started, listening on 50051 라는 메세지가 나타난다. 50051번 포트를 열어 놓고 서버 측에서 대기를 하고 있게 된다. 2. Client 역할 Terminal$ ./build/install/examples/bin/hello-world-client 위 명령어를 실행하면 INFO: Will try to greet world … INFO: Greeting: Hello world 메세지가 나타난다. REST, HTTP와는 다르게 server 쪽의 메서드를 Client단에서 호출했다. 이렇게되면 gRPC를 통하여 Client-server 어플리케이션을 실행한 것이다.","link":"/10/29/grpc/"},{"title":"OSI 7 Layer","text":"여러 프로토콜이 Data에 계속해서 각각의 header를 붙여서 헤더와 정보를 구성한다. Application-&gt;Presentation-&gt;Session-&gt;Transport-&gt;Network-&gt;DataLink-&gt;Physical 이전 계층의 header도 하나의 데이터로 취급한다. LAN 카드를 통해 헤더와 데이터를 보내고, 전송받은 곳에서는 역순으로 헤더를 check하고 떼어낸다. 배열에서 인덱스 0번의 데이터를 제외하고 slicing하는 모습과 유사하다. + 캡슐화와 역캡슐화송신측에서 데이터에 header를 붙이고, 캡슐화를 한다.수신측에서는 역캡슐화하여 각 계층의 header에 해당하는 데이터를 제외시킨다. Application Layer (응용 계층)대표적인 프로토콜 : HTTP네트워크 응용프로그램을 위한 인터페이스를 제공한다. Presentation Layer (표현 계층)응용 계층으로부터 전달받거나, 전달해야하는 데이터의 암호화를 담당한다. Http와 https의 차이는 암호화에 있다. Session Layer (세션 계층)세션 및 Dialogue 연결 및 관리를 담당한다. FTP를 통해 여러 파일을 다운로드 받을 때, 각 다운로드를 Session으로 구분하여 연결하고 관리한다. Transport Layer (전송 계층)대표적인 프로토콜 : TCP데이터 단위 : segment 목적지에 신뢰할 수 있는 데이터 전달을 담당한다. 목적지의 어떤 응용 프로그램에 데이터를 전달해야하는지 포트를 통해 식별할 수 있다. TCP vs UDPTCP 연결형 프로토콜, 데이터의 전송순서 및 신뢰성 보장 Path를 만들어놓고, 송수신이 끝나면 끊는다. UDP 비연결형 프로토콜, TCP보다 빠른 전송 속도 스트리밍, 브로드캐스팅 서비스에 사용된다. 데이터 단위 : 데이터 그램 Network Layer (네트워크 계층)대표적인 프로토콜 : IP데이터 단위 : packet 다양하고, 방대한 네트워크 상에서, 컴퓨터의 논리적인 연결을 할 수 있게 해준다. Source, Destination IP Address를 가지고 있다. Data Link Layer (데이터 링크 계층)대표적인 프로토콜 : Ethernet데이터 단위 : Frame 물리적 네트워크 사이의 데이터 송, 수신을 담당한다. Ethernet 헤더는 Source, Destination MAC address 정보를 담고있다. 각 하드웨어는 유일한 MAC Address를 가지고있다. Physical Layer (물리 계층)디지털은 0, 1로 데이터를 주고 받지만, 아날로그 신호는 주파수에 데이터를 실어서 송수신한다.물리 계층에서는 디지털 신호를 전기 신호로 변환하여 송수신한다. TCP/IP 모델 인터넷 통신을 위한 모델이다. 전송계층과, 인터넷(네트워크) 계층은 그래도 존재한다. 물리, 데이터링크 계층은 네트워크 접속 계층으로, 세션, 표현, 응용 계층은 응용 계층으로 처리한다.","link":"/11/03/osi7layer/"},{"title":"Spring - Interceptor","text":"Interceptor 란 ? 출처 : 갓대희의 작은 공간 Interceptor는 Filter와 유사한 형태로 존재한다. AOP가 흩어진 관심사를 묶어 처리하는 것과 같이 공통처리를 위해 활용될 수 있다. 실행순서는 아래와 같다. 요청 : Filter -&gt; Dispatcher Servlet -&gt; Interceptor -&gt; AOP 응답 : AOP -&gt; Interceptor -&gt; Dispatcher Servlet -&gt; Filter 비고 Filter Interceptor 등록 WebApplication(web.xml) Spring Context 전,후처리 chain.doFilter() preHandle, postHandle 등 예외처리 WebApplication ExceptionHandler 기타 Servlet 응답, 요청에 대한 교체 가능 HandlerMethod를 통한 추가 작업, View 렌더링 전 추가 작업, AOP와 유사한 기능 제공(인증단계, 로깅 등), Service business logic과의 분리 사용 인코딩처리, XSS 방어 등 로그인, 권한 체크, 로그확인 등 Interceptor 구현 절차1. Interceptor를 생성할 때 HandlerInterceptor 인터페이스를 implements 해준다.2. Spring이 Component Scan을 할 때 인식되기 위해 @Component Annotation을 추가해준다.3. 전, 후처리에 맞추어 method를 override해준다. 전처리 : preHandle() 후처리 : postHandle() 응답완료 후 : afterCompletion() 아래 예제에서는 전처리를 하기위해 preHandle()메서드를 override 해주었다. request한 uri와 Auth라는 Annotation을 유무 여부를 체크 및 로깅해주고, Annotation이 있다면 query를 log로 찍어주었다. CheckAnnotation 메서드는 handler와 handlerMethod를 통해 annotation이 Bean 혹은 MethodAnnotation이 맞는지 체크해주었다. if (handlerMethod instanceof HttpRequestHandler) { return true; } 코드는 Html 등 resource일 시 true를 반환해주도록했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Slf4j@Componentpublic class AuthInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String uri = request.getRequestURI(); log.info(&quot;uri : {}&quot;, uri); URI urii = UriComponentsBuilder.fromUriString(uri) .query(request.getQueryString()) .build() .toUri(); boolean hasAnnotation = checkAnnotation(handler, Auth.class); log.info(&quot;has annotation : {}&quot;, hasAnnotation); if (hasAnnotation) { String query = urii.getQuery(); log.info(&quot;query : {}&quot;, query); if (query.equals(&quot;name=Inwoo&quot;)) { return true; } throw new AuthException(); } return false; } public boolean checkAnnotation(Object handler, Class clazz) { HandlerMethod handlerMethod = (HandlerMethod) handler; // pass resource if (handlerMethod instanceof HttpRequestHandler) { return true; } // pass annotation if (handlerMethod.getBeanType().getAnnotation(clazz) != null || handlerMethod.getMethodAnnotation(clazz) != null) { return true; } return false; }}","link":"/10/28/springInterceptor/"},{"title":"TCP Protocol","text":"TCP Header Port 정보 TCP는 포트를 통해 통신하므로 Source, Destination Port를 가지고 있다. 16bit 데이터를 전송할 때 데이터를 순서에 맞게 나눠서 전송하는데 이를 위한 Sequence Number도 있다. Ack Number 잘 받았는지 확인하기 위한 정보 Code Bits URG, ACK, PSH, RST, SYN, FIN TCP 3-way-handshake (연결) Server에 Connect하면 sync를 1로해서 보낸다. seq에 1을 더해서 ack을 설정한 뒤 접속한다. TCP 4-way-handshake (연결 해제) Client에서 FIN을 1로 해서 보내고, Server에서 ACK를 1을 주고, 잠시 후에 FIN을 1로 보내고마지막으로 Cli에서 FIN 1을 보낸다. port가 사용중이라하면 4th 과정에서 응답을 안해줘서 그럴 수도 있다. 전송 header에 Len 인자에 데이터 길이를 넣어서 보낸다. 2GB 파일을 패킷의 최대 크기인 1500KB???로 나눠서 보내는데,, , len : 전체 데이터의 길이 ACK = seq + len(데이터 길이) 제어 수도관처럼 시간 당 보낼 수 있는 양에 한계가 있다. 적절하게 전송해줘야 유실되지않고, 정확이 도착할 것이다. 네트워크 트래픽에 따른 효율적/신뢰적 송신을 위한 제어 알고리즘 적용 흐름 제어(Flow Control) End to End 컴퓨터의 성능을 자동으로 detect해서 전송한다.Sliding Window 알고리즘을 통해 알맞게 흐름량을 제어해준다. Sliding window송신자와 수신자가 한 번에 주고 받을 수 있는 양의 minimum을 선택하여 window size로 정한다. SYN와 SYN/ACK 사이의 시간인 RTT를 기반으로 window size를 재설정해줘서 mininum보다 더 큰 값으로 설정된다. ACK를 받지 못해도 window size만큼 데이터를 보낸다. ACK를 받으면 한 칸씩 sliding하며 window를 옮겨준다. =&gt; ACK을 받은 만큼 데이터를 또 전송할 수 있다. 과거에는 Stop and Wait 방식을 사용해서 각 패킷마다 번호를 할당하고, 한 패킷이 보내질 때 이에 대한 ACK가 돌아와야 다른 패킷을 전송했다. 혼잡 제어(Congestion Control) 다양한 망을 타고 데이터가 전송 될 때, 망의 traffic을 고려해서 알맞게 데이터 양을 설정하는 알고리즘 Congestion window 초기값 1 MSS (기본 단위) 한 번에 데이터를 보낼 수 있는 크기 MSS = MTU - (IP 헤더 길이) - (TCP 헤더 길이) 보통 1500 - 20 - 20 =. 460 AIMD(Additive Increase/Multicative Decrease) 지속적으로 증가시키다가 트래픽이 안오면 절반으로 감소시키고, 들어오면 다시 증가시키는 알고리즘 처음 CWND = 1 패킷 전송이 성공하여 ACK가 도착하면 CWND += 1 도착하지않으면 CWND /= 2 Slow Start 처음 CWND = 1 패킷 전송이 성공하여 *ACK가 도착하면 CWND = 2 도착하지않으면 CWND = 1 Congestion Avoidance CWND가 일정 크기에 도달하고, ACK가 도착하면 CWND += 1 UDP UDP 란? UDP는 User Datagram protocol로 사용자 데이터그램 프로토콜이다. TCP와 달리 브로드캐스팅 지원을 해주고, 신뢰성이 없기 때문에 데이터의 유실이 일부있어도 문제 없고, 속도가 필요한 동영상 스트리밍 등의 서비스에서 많이 사용된다. 헤더도 TCP에 비해 단순하여 비교적 가볍다.","link":"/11/03/tcpProtocol/"},{"title":"Session (세션)","text":"브라우저 상에서 CRUD를 누구나 수행할 수 있게되면 악의적인 실행을 통해 서버 데이터 유지가 어려워질 수 있다. Servlet 입장에서 요청한 브라우저의 상태 정보를 매 번 확인할 수 있어야한다. 관련해서 정책이 필요한데, 예를 들면 로그인 된 상태에서, 작성자가 일치하면 UPDATE나 DELETE를 할 수 있는 정책이다. Session12/* HttpServletRequest request */HttpSession session = request.getSession(); getSession() 이 호출되면 key, value를 저장할 메모리가 할당된다. 요청한 브라우저와 매핑된 세션을 서버 메모리에서 찾아주며, 브라우저가 종료되면 해당 세션이 삭제된다. 브라우저 1개당, 서버 메모리 1개 getAttribute()Session을 통해 userID의 값이 저장(로그인) 돼었을 때만 service 단에 접근할 수 있도록 만들 수 있다. 12345if (session.getAttribute(&quot;userID&quot;) == null) { response.sendRedirect(&quot;login.html&quot;);} else { /* ... */} getAttribute() 메서드를 사용할 때는 Object 타입으로 해주기 떄문에 형변환 1String userRole = (String)session.getAttribute(&quot;userRole&quot;); swetAttribute(), removeAttribute()각 속성 값을 아래와 같이 설정할 수 있으며, Key 값이 중복되면 value 값이 update 된다. removeAttribute() 메서드를 통해 Key, value 쌍을 삭제할 수 있다. 12345session.setAttribute(&quot;userID&quot;, user.getId());session.setAttribute(&quot;userName&quot;, user.getName());session.setAttribute(&quot;userRole&quot;, user.getRole());session.setAttribute(&quot;userID&quot;, user.getId());session.removeAttribute(&quot;userID&quot;); 세션의 timealive메모리가 낭비될 수 있기 때문에 tomcat 서버의 default 값은 30분이다. Interaction(서버에 요청)이 없는 순간을 기준으로 한다. 1session.setMaxInactiveInterval(10); invalidate()Logout을 할 때 session을 강제로 삭제시킬 때 주로 사용된다. 12HttpSession session = request.getSession();session.invalidate();","link":"/11/03/session/"},{"title":"Spring - 비동기 처리 (async)","text":"비동기적 (Asynchronous) 이란 ? 비동기는 요청과 결과가 동시에 일어나지 않는 것입니다. 위에서 Synchronous 처리는 다른 처리가 끝나야 다른 task를 시작하기 시작합니다. 반면에 Asynchronous는 다른 작업이 끝나기를 기다리지 않고 또 다른 작업을 수행할 수 있습니다. Web MVC에서는 많이 활용되고 있지는 않습니다. Spring에서는 CompletableFuture를 통해 비동기 처리를 할 수 있다. CompletableFutureCompletableFuture는 java util에서 제공하는 클래스로 Future과 CompletionStage 인터페이스를 Implements합니다. 쓰레드를 직접 생성하지 않고, 미리 저장해둔 thread 관련 configure을 통해 호출할 수 있습니다. Future비동기적 연산의 결과를 표현하는 인터페이스입니다. 멀티 쓰레드 환경에서 처리된 데이터를 다른 쓰레드에 전달할 수 있고, Thread-Safe합니다. Spring의 비동기 처리 Spring MVC 3.2 버전 이후부터 Servlet 3.0 기반의 비동기 처리가 가능합니다. Spring에서는 annotation을 통해 메서드를 비동기적으로 호출할 수 있습니다. 1. Main 클래스에 @EnableAsync Annotation 추가비동기 처리를 사용하기 위해서 @SpringBootApplication이 명시된 곳에 @EnableAsync를 추가해 주어야 합니다. 12345678@SpringBootApplication@EnableAsyncpublic class AsyncTestApplication { public static void main(String[] args) { SpringApplication.run(AsyncTestApplication.class, args); }} 2. ThreadPoolTaskExecutor 구현필수적인 것은 아니지만 서버를 개발함에 있어서 traffic을 예상하여 미리 Thread를 할당해주는 방법이 좋다고 생각합니다. ThreadPoolTaskExecutor 클래스를 통해 Thread Pool의 Max Size, Core Pool Size, Queue Capacity, Thread Name Prefix 등을 설정할 수 있습니다. Core Pool Size(동시 실행 가능한 쓰레드 개수)에 설정한 쓰레드 풀의 크기를 초과하는 task가 들어오면 Queue Capacity에 task가 쌓입니다. 이 때 Queue Capacity에 최대 Max Pool Size에 설정한만큼 task를 보관할 수 있습니다. 이를 통해 호출된 Thread에는 Async-라는 이름이 붙도록 prefix를 설정해주었습니다. 123456789101112@Configurationpublic class AsyncConfiguration { @Bean(&quot;async-thread&quot;) public Executor asyncConfig(){ ThreadPoolTaskExecutor tpte = new ThreadPoolTaskExecutor(); tpte.setMaxPoolSize(100); tpte.setCorePoolSize(10); tpte.setQueueCapacity(10); tpte.setThreadNamePrefix(&quot;Async-&quot;); return tpte; }} 3. Service 단에서 사용메서드에 @Async라는 Annotation을 붙이고, 위에서 지정한 Bean의 id를 통해 사용할 Thread Pool을 설정하였습니다. 서비스 로직(hello)을 작성하여 CompletableFuture를 return하는 메서드에 넣어주었습니다. 여기서 AsyncResult는 비동기처리를위해 Future를 리턴하는 메서드의 method signature로 사용되는 handlerdlek. - method signature : 메서드 이름과, 파라미터에 관해 약속된 메서드 생성 규칙 123456789101112131415161718192021@Slf4j@Servicepublic class ApiService { @Async(&quot;async-thread&quot;) public CompletableFuture run() { return new AsyncResult(hello()).completable(); } public String hello() { for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(2000); log.info(&quot;Thread Sleeping..&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } return &quot;service hello&quot;; }} 이후에 추가적으로 Controller에서 Service Class를 의존성 주입하고, run()메서드를 호출하면 비동기 처리가 가능합니다.","link":"/11/09/async/"},{"title":"1 - Docker Repository 운영","text":"Docker Registry컨테이지 이미지를 저장하는 저장소 docker push 명령으로 hub에 이미지를 업로드한다. registry에는 public한 Docker Hub와 private한 private Registry가 있다. Docker Hub (public)Docker Hub 에서 public으로 업로드 된 이미지를 검색 및 사용할 수 있다. $ docker search &quot;keyword&quot;를 통해 iTerm 등에서 이미지를 검색할 수 있다. image 종류 : Officail Images, Verified Publisher 등 Official ImagesDocker에서 운영하고 관리하는 Official Image들이 담겨있다. 살펴보면 Docker file에 설정할 수 있는 tag 목록과, 사용 방법을 제공한다. Verified PublisherOracle 등의 vendor에서 운영하고 관리하는 Image들이 담겨있다. Repository 생성한 container를 docker push하게 되면 repository에 등록된다. - 하지만 내 Repository 또한 검색을 통해 접근이 가능하다 -혼자만 사용할 수 있는 저장소를 갖기 위해서는 비용을 지불하여야한다. 등록 방법local에서 pull, build한 이미지를 Repository에 등록하기 위해 먼저 1. login이 필요하다. 2. 또한 등록하기 위해서는 Repository 이름으로 설정한 문장 앞에 userId/을 넣어주어야한다. - 예시 : inwoo/httpd:latest 마지막으로 $ docker push [RepositoryName]으로 3. push를 해준다. 실행이 성공적으로 완료되면 아래와 같이 repository에 container가 등록된다 - 누구나 어디서든 다운로드가 가능하다. - private으로 전환하는 것은 1개까지는 무료이지만, 이후로는 추가비용이 소요된다. Private Registry사용 이유외부 Network이 되지 않는 곳이나, 사내에서 전용으로 사용하는 registry를 운영하기 위함이다. Docker에서 지원하는 registry image를 사용하여 사내 혹은 개인의 계정을 통해 private registry를 생성 및 관리할 수 있다. 생성 방법$ docker run -d -p 5000:5000 --restart always --name registry registry:2 를 실행하면 localhost의 5000번 port를 통해 registry가 아래와 같이 동작된다. 동작 중인 환경에서 등록하고 싶은 이미지의 이름 앞에 localhost:5000 또는 ipName:5000를 붙여서 localhost의 5000번 포트를 통해 관리되는 registry임을 명시해준다. 최종적으로 $ docker push localhost:5000/httpd:latest를 통해 push를 해준다. $ docker run -d -p 5000:5000 --restart always --name registry registry:2 명령어를 사용하여 local registry를 실행할 수 있다. image repositoryprivate registry를 사용할 때는 localhost:5000/ubuntu:18.04 혹은 docker.privateexample.com:5000/ubuntu18.04등과 같이 localhost 이름, 포트 넘버 등으로 repository 이름을 설정하여야한다. 이후 push를 통해서 생성할 수 있다.","link":"/11/11/dockerRegis/"},{"title":"Controller와 Rest-Controller의 차이점","text":"Spring에서 Controller임을 명시하기 위해 클래스 상단에 Controller 혹은 RestController 어노테이션을 붙여준다. 이 둘의 주요 차이점은 HTTP Response Body가 생성되는 방식에 있다.RestController는 Controller와 ResponseBody의 조합으로 생각해도 좋다.Controller : Spring MVC 모델에서 사용RestController : RESTful 웹 서비스에서 사용 Spring MVC 처리과정 @Controller12345@Target(value=TYEP)@Retention(value=RUNTIME)@Documented@Componentpublic @interface Controller Spring MVC의 Controller는 Model 객체를 만들어 데이터를 담아 적절한 jsp파일 등의 View를 반환해주는 역할을 한다. @RestController123456@Target(value=TYEP)@Retention(value=RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController RestController는 단순히 객체를 반환하고, 객체 데이터는 JSON, XML 등의 형식으로 HTTP 응답에 담아서 전송한다. 뷰가 아닌 Data를 반환하여 응답에 보다 유용하게 사용된다. RestController 어노테이션에는 Controller와 ResponseBody 어노테이션이 달려있다. 참고기회는 찬스 Baeldung Blog","link":"/11/14/ControllerRestController/"},{"title":"JPA Entity Listener 사용","text":"Entity Listner 란? Listener는 Entity에 발생하는 Event를 기반으로 동작하며, Annotation을 기반으로 입력한다. Pre/Post + Persist/Update/Remove/Load(post) 조합으로 구성된다. 어떤 시점에서 메서드가 실행되는 지 테스트하기 위해 아래와 같이 함수를 작성해보았다. 12345678910111213141516171819202122232425262728@PrePersistpublic void prePersist(){ System.out.println(&quot;===&gt; prePersist() method 호출&quot;);}@PostPersistpublic void postPersist(){ System.out.println(&quot;===&gt; postPersist() method 호출&quot;);}@PreUpdatepublic void preUpdate(){ System.out.println(&quot;===&gt; preUpdate() method 호출&quot;);}@PostUpdatepublic void postUpdate(){ System.out.println(&quot;===&gt; postUpdate() method 호출&quot;);}@PreRemovepublic void preRemove(){ System.out.println(&quot;===&gt; preRemove() method 호출&quot;);}@PostRemovepublic void postRemove(){ System.out.println(&quot;===&gt; postRemove() method 호출&quot;);}@PostLoadpublic void postLoad(){ System.out.println(&quot;===&gt; postLoad() method 호출&quot;);} 아래 코드를 통해 user를 INSERT(Persist)하고, findByID()로 SELECT(Load)하고, UPDATE(Update)하고, 마지막으로 DELETE(Remove) 해주었다. 1234567891011121314@Testvoid listenerTest(){ User user = new User(); user.setEmail(&quot;inwoo2@gmail.com&quot;); user.setName(&quot;inwoo&quot;); // INSERT 실행 userRepository.save(user); User user2 = userRepository.findById(1L).orElseThrow(RuntimeException::new); user2.setName(&quot;eddy&quot;); userRepository.save(user2); userRepository.deleteById(2L);} 결과 확인하기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071===&gt; prePersist() method 호출Hibernate: call next value for hibernate_sequenceHibernate: insert into user (created_at, email, gender, name, updated_at, id) values (?, ?, ?, ?, ?, ?)===&gt; postPersist() method 호출Hibernate: select user0_.id as id1_0_0_, user0_.created_at as created_2_0_0_, user0_.email as email3_0_0_, user0_.gender as gender4_0_0_, user0_.name as name5_0_0_, user0_.updated_at as updated_6_0_0_ from user user0_ where user0_.id=?===&gt; postLoad() method 호출Hibernate: select user0_.id as id1_0_0_, user0_.created_at as created_2_0_0_, user0_.email as email3_0_0_, user0_.gender as gender4_0_0_, user0_.name as name5_0_0_, user0_.updated_at as updated_6_0_0_ from user user0_ where user0_.id=?===&gt; postLoad() method 호출===&gt; preUpdate() method 호출Hibernate: update user set created_at=?, email=?, gender=?, name=?, updated_at=? where id=?===&gt; postUpdate() method 호출Hibernate: select user0_.id as id1_0_0_, user0_.created_at as created_2_0_0_, user0_.email as email3_0_0_, user0_.gender as gender4_0_0_, user0_.name as name5_0_0_, user0_.updated_at as updated_6_0_0_ from user user0_ where user0_.id=?===&gt; postLoad() method 호출===&gt; preRemove() method 호출Hibernate: delete from user where id=?===&gt; postRemove() method 호출 활용 실제로는 데이터베이스 오디팅에 자주 사용된다. 오디팅(Auditing)이란 선택된 DB 사용자의 활동을 감시하는 프로세스이다. Entity의 필드 값에 대한 prePersist, preUpdate가 자주 사용한다. INSERT 이전 UPDATE 이전 Entity에 직접 구현Entity에서 아래와 같이 객체의 생성된 날짜와 수정 날짜를 INSERT 이전, UPDATE 이전에 시행하도록 설정할 수 있다. 12345678910@PrePersistpublic void prePersist(){ this.createdAt = LocalDate.now(); this.updatedAt = LocalDate.now();}@PreUpdatepublic void preUpdate(){ this.updatedAt = LocalDate.now();} Entity Listener class 구현중복되는 코드를 방지하기위해 별도의 EntityListener class를 구현할 수도 있다. 공통된 field를 가지고 있는 Entity들을 위해 Interface로 구현해주어도 된다. 1. 원하는 field의 getter/setter method()를 Interface로 작성한다.- 예제에서는 user의 `createdAt`, `updatedAt`을 관리한다. - 아래와 같이 interface를 구현하고 Implements하였다. - Lombok의 `@DATA`를 사용하여 override는 해주지 않아도 되지만, 변수 명에 유의하여야한다. 1234567public interface Auditable { LocalDateTime getCreatedAt(); LocalDateTime getUpdatedAt(); void setCreatedAt(LocalDateTime createdAt); void setUpdatedAt(LocalDateTime updatedAt);} 1public class User implements Auditable{ 2. EventListner class를 생성하고, Entity에 Annotation을 추가한다.123public class UserEntityListener { /* 아래에서 구현 */} 어떠한 클래스를 Listener로 사용할 것인지 아래와 같이 추가해준다. @EntityListeners(value = UserEntityListener.class) Entity를 받아서 처리를 해야하지만, 어떠한 타입인지 모르기 때문에 Prameter를 Object 객체로 지정해야한다. 따라서 아래와 같이 구현해주었다. 12345678910111213141516public class UserEntityListener { @PrePersist public void prePersist(Object o){ if (o instanceof Auditable){ ((Auditable) o).setCreatedAt(LocalDateTime.now()); ((Auditable) o).setUpdatedAt(LocalDateTime.now()); } } @PreUpdate public void preUpdate(Object o) { if (o instanceof Auditable){ ((Auditable) o).setUpdatedAt(LocalDateTime.now()); } }}","link":"/11/11/jpaEntityListener/"},{"title":"큐","text":"큐 (Queue)특징 데이터가 뒤(rear)로 들어가서 앞(front)으로 나오는 자료 FIFO (First In First Out) 스케줄링, 탐색 알고리즘 등에서 사용된다. 구현배열로 구현선언 배열은 사전에 배열의 크기를 지정해줘야한다. front와 rear를 선언해준다. 1234567#include &lt;stdio.h&gt;#define SIZE 10000#define INF 99999999int queue[SIZE];int front = 0;int rear = 0; 삽입 큐는 한 쪽으로만 데이터가 들어간다. 큐의 마지막인 rear에 1을 추가하여 데이터를 삽입해준다. 배열의 크기를 초과했을 때는 큐 오버플로우를 선언해준다. 1234567void push(int data) { if (rear &gt;= SIZE) { printf(&quot;큐 오버플로우가 발생했습니다. \\n&quot;); return; } queue[rear++] = data;} 삭제 큐는 삽입과 같이 한 쪽에서만 데이터가 나온다. 큐의 front++를 return함으로써 front를 제거한다. 큐가 비어있을 때 시도하면 언더플로우를 선언한다. 1234567void pop() { if (front == rear) { printf(&quot;큐 언더플로우가 발생했습니다. \\n&quot;); return -INF; } return queue[front++];} 모든 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#define SIZE 10000#define INF 99999999int queue[SIZE];int front = 0;int rear = 0;void push(int data) { if (rear &gt;= SIZE) { printf(&quot;큐 오버플로우가 발생했습니다. \\n&quot;); return; } queue[rear++] = data;}void pop() { if (front == rear) { printf(&quot;큐 언더플로우가 발생했습니다. \\n&quot;); return -INF; } return queue[front++];}void show() { printf(&quot;---큐의 앞--- \\n&quot;); for (int i = front; i &lt; rear; i++) { printf(&quot;%d\\n&quot;, queue[i]); } printf(&quot;---큐의 뒤--- \\n&quot;);}int main(void) { push(7); push(5); push(1); pop(); show(); system(&quot;pause&quot;); return 0;} 연결리스트로 구현선언 data와 노드와 다음 데이터를 연결하는 next를 구조에 포함한다. 데이터가 나오는 front, 들어가는 node, 데이터 수를 담을 count를 선언한다. 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INF 99999999typedef struct { int data; struct Node* next;}Node;typedef struct { Node* front; Node* rear; int count;}Queue; 삽입 새로운 node를 동적메모리에 할당해준다. node에 데이터를 담고, next는 NULL로 초기화해준다. 조건문을 통해 큐에 데이터가 없을 시 front로 선언한다. 데이터가 존재할 시 큐의 rear가 node를 가리키게 한다. 큐의 rear를 node로 지정하고, count를 추가해준다. 12345678910111213void push(Queue* queue, int data) { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; node-&gt;next = NULL; if (queue-&gt;count == 0) { queue-&gt;front = node; } else { queue-&gt;rear-&gt;next = node; } queue-&gt;rear = node; queue-&gt;count++;} 삭제 큐에 데이터가 없을 시 실행하면 언더플로우를 선언해준다. 큐의 front를 담을 노드를 생성하고, 데이터도 담아준다. 큐의 front를 위 노드의 next로 선언한다. 기존의 front 다음의 데이터가 front가 되는 것 원래의 front를 담고 있던 node를 해제해주고, count를 감소시킨다. 12345678910111213void pop(Queue* queue) { if (queue-&gt;count == 0) { printf(&quot;큐 언더플로우가 발생하였습니다. \\n&quot;); return -INF; } Node* node = queue-&gt;front; int data = node-&gt;data; queue-&gt;front = node-&gt;next; free(node); queue-&gt;count--; return data;} 모든 코드 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INF 99999999typedef struct { int data; struct Node* next;}Node;typedef struct { Node* front; Node* rear; int count;}Queue;void push(Queue* queue, int data) { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; node-&gt;next = NULL; if (queue-&gt;count == 0) { queue-&gt;front = node; } else { queue-&gt;rear-&gt;next = node; } queue-&gt;rear = node; queue-&gt;count++;}void pop(Queue* queue) { if (queue-&gt;count == 0) { printf(&quot;큐 언더플로우가 발생하였습니다. \\n&quot;); return -INF; } Node* node = queue-&gt;front; int data = node-&gt;data; queue-&gt;front = node-&gt;next; free(node); queue-&gt;count--; return data;}void show(Queue* queue) { Node* cur = queue-&gt;front; printf(&quot;---큐의 앞---\\n&quot;); while (cur != NULL) { printf(&quot;%d\\n&quot;, cur-&gt;data); cur = cur-&gt;next; } printf(&quot;---큐의 뒤---&quot;);}int main(void) { Queue queue; queue.front = queue.rear = NULL; queue.count = 0; push(&amp;queue, 7); push(&amp;queue, 5); push(&amp;queue, 4); pop(&amp;queue); push(&amp;queue, 6); pop(&amp;queue); show(&amp;queue); system(&quot;pause&quot;); return 0;}","link":"/08/03/20210803-til2-md/"},{"title":"상태 패턴 (State Pattern)","text":"State Pattern 이란 무엇인가? 객체가 특정 상태에 따라 행위를 달리하는 상황에서, 상태를 체크하고 이에 따른 행위를 호출하는 것이 아닌 상태를 객체화하여 행동을 할 수 있도록 위임하는 패턴이다. Why ? State Pattern을 왜 사용하여아 하는가?State는 literally 상태를 뜻한다. 현실 세계에서 객체는 동일한 동작도 상태에 따라 다른 출력값을 낸다. 장점 모든 상태에 대한 behavior가 한 곳에 모여있어서 유지보수에 용이하다. 긴 분기문을 제거할 수 있다. 단점 분기가 많지 않다면 State pattern을 사용하는 것이 오히려 복잡해질 수 있습니다. 노트북을 예시로 확인해보자. 노트북은 하나의 전원 버튼만 가지고 있다. 전원 버튼은 상태에 따라 아래와 같이 동작한다. 꺼진 상태 -&gt; 전원 On &amp; 전원 On 상태로 전환 켜진 상태 -&gt; 전원 Off &amp; 전원 Off 상태로 전환 절전 모드 -&gt; 화면 깨우기 &amp; 전원 On 상태로 전환 예제 코드 PowerState라는 여러 가지 상태가 Implements할 Interface를 선언해주었습니다. 구체적인 상태 객체로는 Saving, On, Off를 구현하였습니다. State12345package state;public interface PowerState { void powerButtonPush();} 12345678package state;public class StateOn implements PowerState{ @Override public void powerButtonPush() { System.out.println(&quot;전원을 종료합니다.&quot;); }} 12345678package state;public class StateSaving implements PowerState{ @Override public void powerButtonPush() { System.out.println(&quot;화면을 깨웁니다.&quot;); }} Context다음으로는 Context를 정의하였습니다. 의존성 주입이 필요하기 때문에 abstract class로 구현하여 미리 주입을 해주었습니다. 123456789101112131415package Computer;import state.PowerState;public abstract class Laptop { private PowerState powerState; public void setPowerState(PowerState powerState) { this.powerState = powerState; } public void powerButtonPush(){ powerState.powerButtonPush(); }} 12345678910111213141516package Computer;import state.PowerState;public class MacBook extends Laptop{ @Override public void setPowerState(PowerState powerState) { super.setPowerState(powerState); } @Override public void powerButtonPush() { super.powerButtonPush(); }} 정리앞서 보았던 Strategy Pattern과 의존성 주입을 하고, setter를 통해서 주입된 객체의 상태를 바꿔준다는 면에서 유사한 패턴이라는 생각이 들었습니다. Strategy Pattern은 상태에 따라 다른 전략, 알고리즘을 부여할 때 사용하고, State Pattern은 객체의 상태에 따라 어떤 행동을 취할지 부여할 때 사용할 수 있습니다.","link":"/11/14/StatePattern/"},{"title":"연결리스트","text":"연결리스트 (Linked List)특징 데이터를 선형적으로 저장 및 처리한다. 삽입과 삭제가 많은 경우 효율적이다. 리스트의 중간 지점에 노드의 추가/삭제가 가능하여야 한다. 메모리 공간을 미리 할당하는 배열을 보완하여 공간 낭비를 감소시킨다. ✚ 배열 기반의 리스트 장점 : 즉시 접근이 가능하다. 단점 : 삽입 삭제가 비효율적이며 메모리 공간을 미리 할당한다. 종류단일 연결리스트 단일 연결리스트는 가장 앞의 노드를 가르키는 HEAD를 갖는다. 각 노드별로 동적 메모리를 할당하여야 하며, 각 노드를 연결시켜주어야 한다. ####︎︎ 노드 삽입 HEAD 다음에 노드를 삽입한다고 가정 ‘HEAD의 *next’가 ‘삽입 노드의 값’을 가리키게 한다. ‘삽입 노드의 *next’가 ‘기존 노드의 값’을 가리키게 한다. 노드 삭제 HEAD 다음에 위치한 노드를 삭제한다고 가정 ‘HEAD의 *next’가 ‘삭제될 노드의 다음 값’을 가리키게 한다. 삭제된 노드의 동적 메모리를 해제하여 메모리 누수를 방지한다.","link":"/07/30/20210730-til1/"},{"title":"이진 트리","text":"이진트리 (Binary Tree)특징 일반적인 트리는 한 개의 노드가 여러 개의 자식 노드를 가질 수 있다. 이진 트리는 노드 1개 당 최대 2개의 자식 노드를 가질 수 있다. 종류포화 이진트리 (Full Binary Tree) 리프 노드(최하단 노드)를 제외한 모든 노드가 2개의 자식 노드를 가진 구조. 완전 이진트리 (Complete Binary Tree) 왼쪽 노드부터 점진적으로 채워진 구조 높이 균형 트리 (Height Balanced Tree) 왼쪽, 오른쪽 트리의 높이의 차이가 1이하인 트리 구현순회 전, 중, 후를 root의 순서로 보면 이해하기 쉽다. 전위순회 (Preorder) 순서 : root -&gt; 왼쪽 노드-&gt; 오른쪽 노드 중위순회 (Inorder) 순서 : 왼쪽 노드 -&gt; root -&gt; 오른쪽 노드 후위순회 (Postorder) 순서 : 왼쪽 노드 -&gt; 오른쪽 노드 -&gt; root","link":"/08/04/20210804-BinaryTree/"},{"title":"JPA Entity 관련 Annotation","text":"@Enumerate Enumerate는 JPA에 사용 시 명확히 설정하지 않으면 예기치 못한 에러를 초래할 수 있다. 예를 들어 아래와 같이 Gender enum을 만들었다. 123456public enum Gender { MALE, FEMALE} Entity에 Gender field를 추가하고 테스트 코드를 통해 확인해보자. UserRepository 인터페이스에 @Query를 통해 findRowRecord()라는 custom 쿼리를 작성하였으므로 참고하길 바란다. 12@Query(value = &quot;select * from user limit 1&quot;, nativeQuery = true)Map&lt;String, Object&gt; findRowRecord(Long id); 12345678910@Testvoid enumTest(){ User user = userRepository.findById(1L).orElseThrow(RuntimeException::new); user.setGender(Gender.MALE); userRepository.save(user); userRepository.findAll().forEach(System.out::println); System.out.println(userRepository.findRowRecord(1L).get(&quot;gender&quot;));} 그 결과 위와 같이 findAll()을 해서 조회할 때는 gender=MALE로 입력이 돼었지만, gender의 값을 조회하면 0이라는 값이 나온다. Enumerate의 EnumType의 default 값은 ORDINAL이다. zero-base로 값의 index를 설정한다. 위에서 MALE이 0번째로 설정되어 0이 출력된 것이다. ORDINAL을 사용하면 추후에 Enum 내의 순서가 바뀌면 index값이 달라지게 되고 에러를 초래할 수 있다. 12345678910111213---### @Table`테이블과 관련된` Annotation으로 이름, Index, 제약조건 등을 설정할 수 있다.uniqueConstraints는 여러 column을 사용해 `unique한 복합 column`을 생성하도록 한다.```java@Table(name = &quot;user&quot;, indexes = {@Index(columnList=&quot;name&quot;)}, uniqueConstraints = {@UniqueConstraint(columnNames = &quot;email&quot;)}) @ColumnField의 각 속성을 지정하는 Field-scope의 Annotation이다. 과거에는 Column 이름을 모음을 제거하고 설정하는 경우가 많았다. Field name과 Column name을 분리하기 위해 사용된다. nullable 속성도 자주 사용된다. DDL을 호출할 때 not null column을 만들기 위해 설정한다. 일반적인 조회 쿼리에서 validation을 하지 않는다. Column이 단독적으로 unique해야 한다면 @Column의 속성에 추가할 수 있다. insertable, updateable 속성은 DDL 외에 DML에도 영향을 받는다. 12@Column(name = &quot;crtdat&quot;, nullable = false)private LocalDate createdAt; @TransientTransient는 JPA의 Entity에서 DB의 column외의 추가 field를 갖고 싶을 때 추가해준다. 아래와 같이 설정하면 쿼리문을 실행할 때 DB에 반영되지 않고, JPA에서만 사용된다. 12@Transientprivate String secret;","link":"/11/10/jpaAnnotation/"},{"title":"계수 및 기수 정렬","text":"계수 정렬 (Counting Sort)특징 데이터의 크기가 한정적일 때 사용한다. 데이터를 읽어나가면서 바로 정렬한다 시간복잡도 : O(N) 기수 정렬 (Radix Sort)특징 자리 수를 기준으로 차례대로 데이터를 정렬한다. 자리 수는 가장 큰 값의 자리수를 기준으로 한다. 예시 ) 가장 큰 값 : 345 (1, 10, 100의 자리)","link":"/08/04/20210804-til5/"},{"title":"퀵 정렬","text":"퀵 정렬 (Quick Sort)특징 C++ Algorithm 라이브러리에서 sort()를 통해 사용할 수 있다. 피벗을 기준으로 큰 값, 작은 값을 교체한다. 완전 이진 트리와 흡사한 형태를 가진다. 퀵정렬을 통한 오름차순 구현순서 피벗 : 가장 왼쪽에 위치한 값이라 가정 start : 피벗 다음에 위치한 값 end : 가장 오른쪽에 위치한 값 start : 앞에서부터 뒤로 이동하며 피벗보다 큰 값을 찾음 end : 뒤에서 앞으로 이동하며 피벗보다 작은 값을 찾음 start와 end가 엇갈리는 시점에서 작은 값과 피벗을 교체함 피벗을 기준으로 왼쪽, 오른쪽에서 다시 퀵정렬을 수행한다.","link":"/08/04/20210804-til4/"},{"title":"AVL트리","text":"AVL 트리특징 ‘AVL 트리’는 균형이 갖춰진 이진 트리이다. 균형을 갖추기 위해 회전(Rotation)을 통해 재구성할 수 있다. 균형 균형 인수가 -1, 0, +1 인 상태 균형 인수 왼쪽 자식의 높이 - 오른쪽 자식의 높이 불균형 상태LL 형식 노드가 Left1-Left2로 편향되어 있는 상태재구성 결과적으로 편향된 노드들을 가진 노드(2)를 root가 된다. 노드(2)가 가지고있던 오른쪽 자식 노드들을 root(1)의 왼쪽 자식 노드로 설정한다. 기존의 root(1)는 노드(2)의 오른쪽 자식 노드로 설정한다. RR 형식 노드가 Right1-Right2로 편향되어 있는 상태재구성 LL형식의 재구성 방식을 반대로 수행한다. 편향된 노드의 왼쪽 자식 노드를 root의 오른쪽 노드로 설정한다. 편향된 노드의 왼쪽 자식 노드를 root로 설정한다. LR 형식 노드가 Left1-Right1로 편향되어 있는 상태 편향된 노드에 RR회전을 수행하여 불균형 노드를 왼쪽으로 몰아 넣는다. 몰아넣은 노드에 LL회전을 수행한다. RL 형식 노드가 Right1-Left1로 편향되어 있는 상태 편향된 노드에 LL회전을 수행하여 불균형 노드를 오른쪽으로 몰아 넣는다. 몰아넣은 노드에 RR회전을 수행한다.","link":"/08/05/20210805-AVLtree/"},{"title":"Spring Security 개요","text":"해결하려는 문제 웹사이트의 보안 웹 사이트에는 여러 서비스를 배포하기 위한 리소스와, 이를 사용하는 유저들의 정보가 담겨있습니다. 악의적인 접근으로 부터 이 리소스를 보호하기 위해 Security Library가 사용됩니다. 인증 (Authentication)모든 사용자에게 열려있는 페이지도 있지만, 특정 리소스에 접근하거나, private 사용을 보장하기 위해 일반적으로 Login 하는 과정이 필요합니다. Login은 기존에 ID와 Password를 입력하여 로그인하였으나, 최근에 생긴 페이지들에서는 KAKAO, NAVER 등을 통해 인증을 대리하는 추세입니다. Login 후 인증을 기존에는 Session으로 관리하였으나, 최근에는 서비스가 확장되며 서버들을 scale-out을 해나가면서session을 분산해서 저장하고, 동기화가 필요해졌습니다. 이를 보완하기 위해 session-less의 token 관리 방식으로 인증을 하기 시작하고 있습니다. 권한, 인가 (Authorization)Login을 완료한 후에 이 사용자가 가진 권한으로 어떤 일을 할 수 있는지 설정합니다. 크게는 관리자(ADMIN), 사용자(USER)로 권한을 설정합니다. 웹 서비스를 개발할 때에 권한이 있는 사용자만 특정 uri, 리소스에 접근할 수 있도록 하여야합니다. 이는 Spring Security Framework을 통해 보다 쉽게 구현할 수 있습니다. 비즈니스 로직이 복잡해지고, annotaion으로 체크하는 것이 어려워지면 AOP 등 다양한 방법을 사용한다. 권한을 다루는 방법은 무수히 많습니다. 예제 코드aaplication.ymlLogin과 권한 테스트를 위해 yml파일에 user 1명을 생성해주었습니다. 123456spring: security: user: name: user1 password: 1111 roles: USER Controllerindex : uri를 /로 설정하고, “홈페이지”라는 String을 return 해주는 페이지 /auth : SecurityContextHolder를 통해 사용자의 권한 등 세부 사항을 return 해주는 페이지 123456789101112131415@RestControllerpublic class HomeController { @RequestMapping(&quot;/&quot;) public String index() { return &quot;홈페이지&quot;; } @RequestMapping(&quot;/auth&quot;) public Authentication auth() { return SecurityContextHolder.getContext() .getAuthentication(); } /*...*/} @PreAuthorize 어노테이션을 사용하여 특정 권한을 가진 사람만 접근 허용 SecurityMessage라는 POJO를 만들어 Authentication과 String 타입을 갖는 변수들을 선언해주었습니다. SecurityMessage 코드 보기 123456789101112131415import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import lombok.AllArgsConstructor;import org.springframework.security.core.Authentication;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class SecurityMessage { private Authentication auth; private String message;} /user 에는 USER라는 권한(ROLE)을 가진 사람, /admin에는 ADMIN 권한을 가진 사람만 접근할 수 있도록 해주었습니다. 아직까지는 application.yml에서 설정한 user의 roles는 USER이지만 /admin에도 접근이 가능합니다. @PreAuthorize(“hasZnyAuthority(‘ROLE’)”) 을 활성화 시켜주기 위해서는 WebSecurityConfigurerAdapter 클래스를 extends한 클래스가 존재해야하고, 추가로 annotation을 설정해주어야 합니다.. 123456789101112131415161718/*...*/@PreAuthorize(&quot;hasAnyAuthority('ROLE_USER')&quot;)@RequestMapping(&quot;/user&quot;)public SecurityMessage user(){ return SecurityMessage.builder() .auth(SecurityContextHolder.getContext().getAuthentication()) .message(&quot;User 정보&quot;) .build();}@PreAuthorize(&quot;hasAnyAuthority('ROLE_ADMIN')&quot;)@RequestMapping(&quot;/admin&quot;)public SecurityMessage admin(){ return SecurityMessage.builder() .auth(SecurityContextHolder.getContext().getAuthentication()) .message(&quot;관리자 정보&quot;) .build();} Config Class1. @PreAuthorize를 활성화시키기 위해 SecurityConfig라는 클래스를 만들어 WebSecurityConfigurerAdapter를 extends 해주었습니다.2. @EnableWebSecurity(debug = true) : default 값은 false이지만 security를 debug로 실행시키기 위해 추가하였습니다.3. @EnableGlobalMethodSecurity(prePostEnabled = true) : prePostEnabled를 true로 설정하였습니다.12345@EnableWebSecurity(debug = true)@EnableGlobalMethodSecurity(prePostEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter { /*...*/} 위와 같이 활성화를 시키면 USER 권한을 가진 사용자가 /admin에 접근할 때 아래와 같이 403에러가 발생한다. 접근 테스트를 위해 WebSecurityConfigurerAdapter 를 extends한 클래스 내에서 user를 생성하여 테스트 할 수 있다. User TestWebSecurityConfigurerAdapter는 configure(AuthenticationManagerBuilder auth) 메서드를 가지고 있는데, parameter에서도 알 수 있듯이 AuthenticationManager를 Build하여 생성할 수 있다. configure(AuthenticationManagerBuilder auth) 메서드를 override하게 되면 application.yml에서 설정한 user는 사용할 수 없다.아래 코드를 통해 inMemoryAuthentication 방식으로 user 2명을 생성하였다. 이 때 유의할 점은 password를 등록할 때 암호화를 해주어야 한다는 것이다. 아직까지는 ADMIN 권한을 가진 user는 /admin에만, USER 권한은 /user에만 접근할 수 있다. 123456789101112131415161718@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(User.builder() .username(&quot;user2&quot;) .password(passwordEncoder().encode(&quot;2222&quot;)) .roles(&quot;USER&quot;) ).withUser(User.builder() .username(&quot;user3&quot;) .password(passwordEncoder().encode(&quot;3333&quot;)) .roles(&quot;ADMIN&quot;)) ;}@Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } 누구나 접근할 수 있는 페이지권한에 상관없이 누구나 접근할 수 있는 페이지도 configure(HttpSecurity http) 메서드로 설정할 수 있다. index 페이지인 /를 누구나 접근할 수 있도록 설정하였다. request를 받아, / 에 접근하는 요청에 대해 permitAll()을 통해 누구나 접근할 수 있도록 설정할 수 있다. 123456789@Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests((requests) -&gt; requests.antMatchers(&quot;/&quot;).permitAll() .anyRequest().authenticated() ); http.formLogin(); http.httpBasic(); }","link":"/11/16/springsecurity/"},{"title":"선택 및 삽입 정렬","text":"선택 정렬 (Selection Sort)특징 가장 작은 것을 선택해서 앞으로 보냄 시간복잡도 : 가장 작은 데이터 선택 (N) * 앞으로 보내기 (N) = O(N^2) 삽입 정렬특징 각 숫자를 적절한 위치에 삽입 일반적으로 선택 정렬보다 빠르게 동작한다. 시간복잡도 : 들어갈 위치를 선택 (N) * 데이터를 선택하는 횟수 (N) = O(N^2)","link":"/08/04/20210804-til3/"},{"title":"그래프 탐색","text":"그래프 탐색깊이 우선 탐색 (Depth First Search)특징 깊은 것을 우선적으로 탐색한다. 전체 노드를 탐색하며, 모든 경우의 수를 탐색한다. 스택 자료구조에 기초하며, O(N)이 소요된다. 구현 모든 노드는 탐색되지 않은 상태임을 가정 스택에 삽입되면 탐색이 완료된 것으로 간주한다. 탐색을 시작할 노드를 스택에 삽입(탐색)한다. 시작 노드와 인접한 노드를 순차적으로 스택에 삽입(탐색)한다. 더이상 인접한 노드가 없을 때는 스택에서 순차적으로 노드를 꺼낸다. 너비 우선 탐색 (Breadth First Search)특징 너비를 우선으로 하여 탐색을 수행한다. 전체 노드를 탐색하고, DFS보다 빠르다. 큐 자료구조에 기초하며, O(N)이 소요된다. 고급 그래프 탐색 알고리즘에서 자주 활용된다. 구현 모든 노드는 탐색되지 않은 상태임을 가정 스택에 삽입되면 탐색이 완료된 것으로 간주한다. 탐색을 시작할 노드를 큐에 삽입한다. 삽입한 노드를 꺼내고, 인접 노드를 삽입한다. 2를 더이상 수행할 수 없을 때까지 반복한다.","link":"/08/05/20210805-DFS/"},{"title":"해시","text":"해시 (Hash)특징 해시를 이용하면 메모리를 많이 소요하지만 최대 빠른 속도로 관리할 수 있다. DB 소프트웨어에서 많이 사용된다. 수학적 연산을 통한 키를 이용하여 값에 접근한다. 나머지를 사용하는 방법이 보편적이다. 테이블 크기를 소수로 설정하여야 충돌 확률이 낮다. 키가 중복이 생길 경우 충돌이 생긴다고 표현하는데 이를 해결하는 방법에는 2가지가 있다. 충돌 해결충돌 시 다른 위치에 저장하기 선형 조사법 키가 중복이 생기면 해당 키의 다음 인덱스에 데이터를 저장한다. 다시 중복이 생기면 인덱스+1을 해나가며 저장한다. 단점 충돌이 발생하기 시작하면 유사한 값을 가지는 데이터가 밀집되는 집중 결합 문제가 발생한다. 테이블의 크기가 매우 크면, 충돌은 적어지고, 데이터에 빠르게 접근할 수 있다. 이차 조사법 키 값이 중복되면 완전 제곱수를 더해 나가며 저장한다. 인덱스+1, 인덱스+4 … 선형 조사법 및 이차 조사법에서 데이터의 수가 테이블 인덱스를 초과하게 되면 크기를 확장하여 유지할 수 있도록 설정하여야 한다. 충돌 시 하나의 bucket에 여러 데이터 저장하기 체이닝 기법 연결리스트를 활용하여 동일한 키를 가지는 인덱스들을 연결하여 저장한다. 연결리스트를 사용하기 때문에 삽입 삭제가 용이하다. 테이블 크기는 동적 메모리할당을 통해 해결이 가능하지만 추가적인 메모리 공간이 요구된다.","link":"/08/05/20210805-hash/"},{"title":"그래프","text":"그래프 (Graph) 사물을 정점(Vertex)과 간선(Edge)로 나타내는 구조 종류 E : Edge (간선)V : Vertex (정점) 무방향 비가중치 그래프 모든 노드의 연결여부를 확인하여야한다. 2차원 Matrix를 이용하여 확인하므로 O(V^2)이 소요되고, 값은 바로 확인할 수 있기 때문에 O(1)이 소요된다.인접 행렬(Adjacency Matrix)을 이용한 구현 방향 가중치 그래프 모든 간선이 방향을 가지고, 가중치를 가진 그래프 연결된 간선의 정보만 저장하기 때문에 공간은 O(E)가 소요되고, 노드만 확인하여 값을 확인하므로 O(V)가 소요된다.인접 리스트(Adjacency List)를 이용한 구현","link":"/08/05/20210805-graph/"},{"title":"탐색","text":"탐색 (Search)종류순차 탐색 (Sequential Search) 특정한 원소를 찾기위해 순차적으로 탐색을 수행한다. 이진 탐색 (Binary Search) 배열의 내부 데이터가 이미 정렬되어 있는 상황에서 사용한다. 탐색 범위를 절반씩 좁혀가며 탐색을 수행한다.구성 start (가장 앞에 위치한 원소) mid (중간에 위치한 원소) end (가장 뒤에 위치한 원소)","link":"/08/05/20210805-search/"},{"title":"우선순위 큐","text":"우선순위 큐 (Priority Queue)특징 우선 순위를 가진 데이터를 저장하는 큐 데이터 추출 시 우선순위가 높은 데이터가 추출된다. OS의 스케줄링, 정렬, 네트워크 관리 등에 이용된다. 비교큐 (Queue) 선형구조 및 FIFO 구조를 가진다. 우선순위 큐 (Priority Queue) 트리 구조와 유사하며, 최대 힙으로 구현한다. 최대힙 구조 힙은 항상 완전 이진 트리 구조여야 한다. 부모 노드가 항상 자식노드보다 큰 값을 가진 구조 root가 최대 값을 가진다. 데이터 삽입 전체 트리가 최대힙 구조를 유지하도록 코딩할 수 있다. 삽입하는 원소는 완전 이진 트리를 유지하는 형태로 삽입한다. 삽입 후에 자식 노드보다 크고, 부모 노드보다 작을 때 까지 상향식 이동을 한다. 데이터 삭제 데이터를 삭제할 때는 root를 삭제해준다. 마지막에 위치하던 노드를 root로 이동시킨다. 삭제 후에 부모 노드보다 작고, 자식 노드보다 클 때 까지 하향식으로 이동한다.","link":"/08/05/20210805-priorityQueue/"},{"title":"이진 탐색 트리","text":"이진 탐색 트리 (Binary Search Tree)특징 이진 탐색 트리에서 부모 노드는 왼쪽 자식 노드보다는 크고 오른쪽 자식 노드보다는 작다 값의 크기 비교 : 왼쪽 자식 노드 &lt; 부모 노드 &lt; 오른쪽 자식 노드 탐색 속도를 극대화할 수 있는 구조이다. 한 번 확인할 때 마다 탐색할 노드의 개수가 절반씩 줄어든다. 완전 이진 탐색 트리에서 실행할 경우 O(logN)의 시간복잡도를 가진다. 탐색 트리 내의 데이터를 탐색한다. 탐색하고 싶은 노드를 부모 노드와 비교한다. 부모 노드보다 클 경우 오른쪽 자식 노드에 포함되므로 오른쪽으로 이동한다. 부모 노드보다 작을 경우 왼쪽 자식 노드에 포함되므로 왼쪽으로 이동한다. 삽입 삽입하고 싶은 데이터를 부모 노드와 비교하여 탐색 프로세스와 같이 이동하며 적절한 위치에 값을 삽입한다. 삭제 자식 노드가 없는 노드의 삭제 데이터를 탐색하여 삭제한다. 1개의 자식 노드가 있는 노드의 삭제 삭제할 노드의 자리에 자식 노드를 삽입한다. 2개의 자식 노드가 있는 노드의 삭제 삭제할 노드 다음으로 큰 노드를 삭제할 노드의 위치에 삽입한다.","link":"/08/05/20210805-BinarySearchTree/"},{"title":"자바란 ?","text":"자바 (Java)특징 C, C++에 비해 안정적이다. 객체 지향적 언어로 객체 간의 협력을 할 수 있다. 플랫폼에 영향을 받지 않는다. Java의 소스코드를 컴파일러가 바이트 코드로 변환하여 JVM에서 플랫폼에 맞게 다시 변환하고 실행한다. 웹 서버, 안드로이드, 게임 프로그래밍에 사용된다. Convention Class 선언 : Class는 대문자로 시작한다. Hot key Ctrl + D : 삭제 Ctrl + F11 : Run 자료형정수 byte (1byte) 1바이트 단위인 음악 동영상, 실행파일 등의 자료처리를 할 때 사용된다. short (2byte) C/C++과 호환 시 사용된다. int (4byte) 자바에서 정수의 기본형으로 사용된다. 프로그램에서 사용하는 모든 숫자(리터럴)는 int로 표현된다. long (8byte) int의 범위를 넘어선 -2의 63승 ~ 2의 63승 -1까지 표현 숫자의 뒤에 L 또는 l을 사용하여 long자료형임을 표시한다. 실수 float (4byte) double (8byte) 자바에서 실수의 기본형으로 사용된다.표현 실수는 가수, 밑수, 지수로 나뉘어 부동 소수점 방식으로 값이 표현된다. 컴퓨터에서는 밑수를 2로 사용한다.정규화 가수가 밑수보다 작은 한자리까지 가수로 표현 되는 것 예시 : 컴퓨터에서는 밑수가 2로 표현되므로, 정규화를 수행하면 가수부분의 첫 번째 자리 숫자는 항상 1로 표현된다.오류 부동 소수점 방식으로는 지수가 0을 표현할 수 없기 때문에 약간의 오차가 발생할 수 있다. 문자 컴퓨터에서는 문자를 표현하기 위해 문자세트(Charset)를 사용한다. 문자세트 : 각 문자를 어떠한 숫자로 표현할 것인지 코드표로 나타낸 세트 종류 : ASKII, euc-kr, uft-8, utf-16 등 자바에서는 문자를 나타내기 위해 세계 표준인 UNICODE를 사용한다. utf-16 인코딩을 사용하여 모든 문자를 2바이트로 표시한다.","link":"/08/10/20210810-java/"},{"title":"프림 알고리즘","text":"프림 알고리즘 (Prim’s Algorithm)개요프림 알고리즘 가중치가 있는 연결된 무향 그래프의 모든 꼭짓점을 포함하면서 각 변의 비용의 합이 최소가 되는 부분 그래프인 트리, 즉 최소 신장트리 를 찾는 알고리즘이다최소 신장트리 (Minimum Spanning Tree, MST) 신장 트리 중에서 간선의 가중치 합이 가장 작은 트리 신장트리 특정한 그래프에서 모든 정점을 포함하는 그래프 프림 알고리즘 처음에 트리는 비어있다고 가정한다. 그래프에서 정점 하나를 선택하여 트리에 포함시킨다. 1에서 포함된 정점과 인접한 노드의 간선 중에서 가중치가 가장 작은 간선을 찾아 포함시킨다. 2번을 모든 노드가 포함될 때까지 반복한다. 동작 과정 이미지 삽입 예정 구현 모든 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#define NODE_MAX 1001#define EDGE_MAX 200001 // 양방향 간선이므로 100,000개// 구조체 정의typedef struct {int cost;int node;} Edge;// 데이터 위치 변환을 위한 함수 구현void swap(Edge *a, Edge *b) {Edge temp;temp.cost = a-&gt;cost;temp.node = a-&gt;node;a-&gt;cost = b-&gt;cost;a-&gt;node = b-&gt;node;b-&gt;cost = temp.cost;b-&gt;node = temp.node;}// 우선순위 큐 정의typedef struct {Edge *heap[EDGE_MAX];int count;} priorityQueue;// 데이터 삽입 함수void push(priorityQueue *pq, Edge *edge) { if (pq-&gt;count &gt;= EDGE_MAX) return; pq-&gt;heap[pq-&gt;count] = edge; int now = pq-&gt;count; int parent = (pq-&gt;count - 1) / 2; // 새 원소를 삽입한 이후에 상향식으로 힙을 구성한다. while (now &gt; 0 &amp;&amp; pq-&gt;heap[now]-&gt;cost &lt; pq-&gt;heap[parent]-&gt;cost) { swap(pq-&gt;heap[now], pq-&gt;heap[parent]); now = parent; parent = (parent - 1) / 2; } pq-&gt;count++;}// 데이터 추출함수 구현Edge* pop(priorityQueue *pq) {if (pq-&gt;count &lt;= 0) return NULL;Edge *res = pq-&gt;heap[0];pq-&gt;count--;pq-&gt;heap[0] = pq-&gt;heap[pq-&gt;count];int now = 0, leftChild = 1, rightChild = 2;int target = now;// 새 원소를 추출한 이후에 하향식으로 힙을 구성합니다.while (leftChild &lt; pq-&gt;count) { if (pq-&gt;heap[target]-&gt;cost &gt; pq-&gt;heap[leftChild]-&gt;cost) target = leftChild; if (pq-&gt;heap[target]-&gt;cost &gt; pq-&gt;heap[rightChild]-&gt;cost &amp;&amp; rightChild &lt; pq-&gt;count) target = rightChild; if (target == now) break; // 더 이상 내려가지 않아도 될 때 종료 else { swap(pq-&gt;heap[now], pq-&gt;heap[target]); now = target; leftChild = now * 2 + 1; rightChild = now * 2 + 2; } } return res;}// 데이터 연결리스트 구현typedef struct Node {Edge *data;struct Node *next;} Node;Node** adj;int d[NODE_MAX];// 노드 추가를 위한 함수void addNode(Node** target, int index, Edge* edge) { if (target[index] == NULL) { target[index] = (Node*)malloc(sizeof(Node)); target[index]-&gt;data = edge; target[index]-&gt;next = NULL; } else { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = edge; node-&gt;next = target[index]; target[index] = node; }}// 알고리즘 실행int main(void) { int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); // 큐 초기화 adj = (Node**)malloc(sizeof(Node*) * (n + 1)); for (int i = 1; i &lt;= n; i++) { adj[i] = NULL;}priorityQueue *pq;pq = (priorityQueue*)malloc(sizeof(priorityQueue));pq-&gt;count = 0;for (int i = 0; i &lt; m; i++) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); Edge *edge1 = (Edge*)malloc(sizeof(Edge)); edge1-&gt;node = b; edge1-&gt;cost = c; addNode(adj, a, edge1); Edge *edge2 = (Edge*)malloc(sizeof(Edge)); edge2-&gt;node = a; edge2-&gt;cost = c; addNode(adj, b, edge2);}","link":"/08/05/20210805-prims/"},{"title":"추상 클래스 (Abstract Class)","text":"추상 클래스 (Abstract Class)의미 구현 코드없이 메서드의 선언만 있는 추상 메서드를 포함한 클래스 메서드를 생성할 때 반환값, 메서드 이름, 매개변수로 구성되어있다. 구현은 상속받은 자식 클래스가 한다. 추상 클래스는 인스턴스화(new 로 생성) 할 수 없다. 기능이 완벽하지 않기 때문 일반 클래스도 abstract 라고 명시하면 이를 생성할 수 없다. 자식클래스에서 추상 메서드 중 하나라도 구현하지 않으면 자식클래스도 추상클래스가 된다. 구체적(Concrete)과 반대되는 말로, 구현부를 작성하지 않은 클래스라고 생각할 수 있다. 추상 클래스를 생성하는 것은 선언이라고 한다. 어떤 기능을 할지 구현부를 작성하면 메서드를 정의한다고 한다. 다이어그램으로 나타낼 때 추상 메서드와 클래스는 Italic체로 작성한다.1234int add(int a, intb); //선언 (추상 메서드)int add(int a, intb){ //정의 구현할 기능ㅔ}","link":"/08/12/20210812-Abstract/"},{"title":"다운캐스팅(DownCasting)","text":"다운캐스팅 (DownCasting)의미 업캐스팅된 클래스를 원래의 타입으로 다시 형변환하는 것 하위 클래스로의 형변환(다운캐스팅)은 명시적으로 해야한다. 클래스B가 클래스A에게 상속받는 경우12A instance = new B(); // 묵시적B instanceB = (B)instance; //명시적 유의 사항 클래스 B와 C가 클래스 A에게 상속 받는 경우1234567// A의 타입으로 B, C의 인스턴스를 생성해준다.A ins1 = new B();A ins2 = new C();// C타입을 B타입인 ins3로 생성을 시도한다.// 실행전까지는 에러가 나지 않지만 실행 시 에러가 발생한다.B ins3 = (B)ins2; 아래와 같은 방어 코드로 에러를 방지할 수 있다. instanceof : in2가 B클래스로 생성된 인스턴스인지 확인한다123if ( in2 instanceof B ){B ins3 = (B)ins2;}","link":"/08/12/20210812-DownCasting/"},{"title":"가상메서드(VirtualMethod)","text":"가상 메서드메서드 (Method) 명령어의 집합 (set) Java에서 모든 메서드는 가상 메서드이다. 메서드의 이름은 주소값을 나타낸다. 메서드를 호출하면 이름과 mapping되어 있는 주소값이 호출된다.함수 호출 방식 프로그램이 로드되면 메서드 영역(코드 영역)에 명령어 set이 위치한다. 메서드가 호출되면 명령어 set이 위치한 주소를 찾아가 명령어가 실행된다. 이 때 메서드에 위치한 변수들은 stack메모리에 위치하게 된다. 서로 다른 인스턴스가 동일한 메서드를 호출하면 같은 method가 호출된다.인스턴스가 생성되면 변수는 heap메모리에 저장이 되지만, 메서드 명령어 set은 한 번만 로드된다. 가상 메서드 (Virtual Method) 클래스마다 가상 메서드 테이블(Virtual Method Table)에 메서드의 address를 가지고 있다. 메서드가 재정의되면 재정의된 클래스의 테이블에 address가 추가된다.","link":"/08/12/20210812-VirtualMethod/"},{"title":"자바 기초","text":"자바 기초객체 지향 프로그래밍 (OOP; Object Oriented Programming) Java는 객체 지향 프로그래밍 언어 중 하나이다. 객체 : 구체적, 추상적 데이터의 단위 (사람, 사물, 주문 등) 객체 지향 프로그래밍 언어는 협력을 통해 기능을 수행할 수 있다. 클래스로 객체를 정의한다. 객체의 속성을 클래스 내부의 멤버 변수로 넣는다. 역할과 책임 등을 기능으로 구현한다. 클래스 간의 협력을 통해 실행한다. 함수 (Function) 함수는 기능을 수행하는 단독 모듈이다. 함수를 호출하여 수행하고 반환할 수 있다. 기본형 &lt;접근 제어자&gt; &lt;static | final&gt; &lt;반환형&gt; &lt;함수명&gt; 접근 제어자 (Access Modifier) 어떠한 범위 내에서 함수, 클래스에 대해 접근을 통제할 것인지 정의합니다. public : 어디서든 접근 가능 private : 동일한 클래스 내에서만 접근 가능 public으로 구현된 메서드를 통해 접근이 가능하다. protected : 동일한 패키지 내, 이를 상속받은 자식 클래스 내에서 접근 가능 default : 같은 패키지 내에서 접근 가능 접근제어자를 입력하지 않았을 때 default가 적용된다. Static | Final static 이 메서드를 공용으로 사용할 것인지 아닌지를 결정한다. static을 삽입하면 공용으로 사용할 수 있다. static으로 지정하면 static메모리 공간에 저장되어 프로그램의 시작부터 종료 시 까지 저장된다. Final 상속, 제정의, 변경이 불가한 상태로 지정한다. 상수를 정의할 때도 사용된다. 반환형 (Return Type) 반환형에는 자료형을 삽입할 수 있다. 생성한 class를 반환형으로 사용할 수도 있다. 메서드 (Method) 클래스 안에서 멤버변수를 이용하여 수행한다. 메서드는 사용하는 객체에 맞게 작명하는 것이 중요하다. 생성자 (Constructor) 객체를 사용할 때 항상 생성자를 통해 생성한 후에 사용한다. 생성하면 heap메모리에 인스턴스가 생성된다. 생성자를 별도로 구현하지 않아도, default constructor가 생성된다. 기본 문법 &lt;ClassName&gt;([Argument]) { [Statements] } 생성자는 오버로딩이 가능하여, 1개 이상 존재할 수 있다. 오버로딩 (Overloading) 사용자의 편의성을 위해 주로 사용된다. 예시: 회원 가입 시 필수 질문만 작성할 수 있고, 추가 정보를 작성하여 가입할 수도 있다.","link":"/08/12/20210812-java2/"},{"title":"상속(Inheritance)","text":"Java 상속, 형변환, 재정의상속 구현되어 있는 기능, 속성을 확장하여 재사용하는 것 class B extends A{ } extends 뒤에는 하나의 클래스만 올 수 있다. 자바는 안정성을 위해 단일 상속만을 지원한다. 상속 하는 클래스 : 상위 클래스, parent class, child class 상속 받는 클래스 : 하위, child, sub 상속을 사용하는 경우 객체 지향 프로그래밍에서는 크게 2가지 방법을 사용할 수 있다. IS-A 관계 (is a relationship : inheritance), HAS-A관계(composition) IS-A관계에서 상속을 사용한다. IS-A 관계 예시 : 포유류 - 인간, 호랑이, 사자 등 일반적인 개념과 구체적인 개념의 관계 뼈대를 구축하고 이를 확장해서 사용할 때 자주 사용된다. 상속은 클래스간의 결합도가 높은 설계이다. 계층구조가 복잡하거나 hiearchy가 높으면 좋지 않다. HAS-A 관계 예시 : Java의 ArrayList 클래스를 사용하는 경우 클래스가 다른 클래스를 포함하는 관계 (변수로 선언) 코드 재사용의 가장 일반적인 방법 상속을 구현하는 경우 일반적인 클래스로부터 보다 구체적인 클래스를 생성하고 싶을 때 사용한다. 직업 (일반 클래스) - 개발자 (구체적인 클래스) 하위 클래스가 생성되는 과정 extends로 하위클래스를 생성하면 상위 클래스가 먼저 생성된다. 하위 클래스의 생성자가 상위 클래스의 생성자를 호출하게 된다. 컴파일러가 하위 클래스의 생성자 내에 super()를 자동으로 입력하여 default 생성자를 호출한다. 생성자에 매개 변수가 존재할 경우, super(매개변수)를 이용하여 명시적으로 호출해주어야 한다. 형변환 상위 클래스로 변수를 생성하고 하위 클래스의 생성자로 인스턴스를 생성 상위 클래스 타입의 변수에 하위 클래스의 변수가 대입 (업 캐스팅) 메서드의 인자에 하위 클래스 타입을 넣어도 상위 클래스 타입으로 형변환이 가능하다. 하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 묵시적 형변환이 가능하다. 12345class B extends A {}A instanceA = new B();method(instanceB);type method(A instanceA){} 하위 클래스로 생성이 되었지만 type이 상위 클래스의 type이므로 하위 클래스에서 생성한 method 등에는 접근할 수 없다. 재정의 (Overriding) 상위 클래스에서 정의한 method를 하위 클래스에서 재정의하고 싶을 때 사용 메서드 정의 부분 (Function Signiture)은 동일하게 입력해야한다. 다르게 입력할 시 새로운 method를 정의하는 것처럼 해석된다. 사용법 @Override 를 Annotation으로 입력해준다. Annotation (주석) 컴파일러에게 특별한 정보를 제공해주는 역할을 한다. Override 재정의된 메서드라는 정보 제공 FuctionalInterface 함수형 인터페이스라는 정보 제공 Deprecated 이후 버전에서 사용되지 않을 수 있는 변수 메서드에서 사용된다. SuppressWarnings(“~”) 특정 경고가 나타나지 않도록함","link":"/08/12/20210812-Inheritance/"},{"title":"다형성(Polymorphism)","text":"다형성 하나의 코드가 여러 자료형으로 구현되어 실행 되는 것 같은 코드에서 여러가지 실행 결과가 나오는 것 유연하고 확장성있고, 유지보수가 편리함 프로그램을 만들 수 있다. 개념 하위 클래스들을 상위 클래스로 형변환한다. 이를 한번에 핸들링한다. 각 인스턴스별로 다른 실행 결과를 얻을 수 있다. 결합도가 높아진다. 예시 모든 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package polymorphismTest;import java.util.ArrayList;class Animal{ // 공통된 기능을 정의 할 때 상위 클래스인 Animal에 기능을 입력한다. public void move() { System.out.println(&quot;동물이 움직입니다.&quot;); } }class Human extends Animal { @Override public void move() { System.out.println(&quot;사람이 두 발로 걷습니다.&quot;); } public void readBook() { System.out.println(&quot;사람이 책을 읽습니다.&quot;); }}class Tiger extends Animal { @Override public void move() { System.out.println(&quot;호랑이가 네 발로 뜁니다.&quot;); } public void hunting() { System.out.println(&quot;호랑이가 사냥을 합니다.&quot;); }}class Eagle extends Animal { @Override public void move() { System.out.println(&quot;독수리가 하늘을 납니다.&quot;); } public void flying() { System.out.println(&quot;독수리가 양날개를 쭉 펴고 날아다닙니다.&quot;); }}public class AnimalTest { public static void main (String[] args) { // 형변환 (업캐스팅 : 상위 클래스의 타입으로 변환) Animal hAnimal = new Human(); Animal tAnimal = new Tiger(); Animal eAnimal = new Eagle(); AnimalTest test = new AnimalTest(); // 상위 클래스인 Animal로 형변환이 가능하다. // 각자의 가상 메서드 테이블을 갖게 된다. test.moveAnimal(hAnimal); test.moveAnimal(tAnimal); test.moveAnimal(eAnimal); // 세 동물을 ArrayList에 삽입하고 싶을 때 ArrayList&lt;Animal&gt; animalList = new ArrayList&lt;&gt;(); animalList.add(hAnimal); animalList.add(tAnimal); animalList.add(eAnimal); // enhanced for문을 통한 출력 for (Animal a : animalList) { a.move(); } } public void moveAnimal(Animal animal) { animal.move(); }} 사용하는 이유 상속과 메서드의 재정의를 활용하여 확장성 있는 프로그램을 만들 수 있다. 위 예시로 보았을 때 동물을 추가하고 싶을 때 편하게 추가할 수 있다. 상위 클래스에 공통된 기능과 하위 클래스에 특정한 기능을 구분하여 코딩할 수 있다.","link":"/08/12/20210812-Polymorphism/"}],"tags":[{"name":"메모리 할당 알고리즘","slug":"메모리-할당-알고리즘","link":"/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"페이지 폴트","slug":"페이지-폴트","link":"/tags/%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8/"},{"name":"단편화","slug":"단편화","link":"/tags/%EB%8B%A8%ED%8E%B8%ED%99%94/"},{"name":"프로세스","slug":"프로세스","link":"/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/"},{"name":"스레드","slug":"스레드","link":"/tags/%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"name":"교착상태","slug":"교착상태","link":"/tags/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C/"},{"name":"메모리 계층","slug":"메모리-계층","link":"/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5/"},{"name":"가상메모리","slug":"가상메모리","link":"/tags/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"},{"name":"페이징","slug":"페이징","link":"/tags/%ED%8E%98%EC%9D%B4%EC%A7%95/"},{"name":"세그멘테이션","slug":"세그멘테이션","link":"/tags/%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98/"},{"name":"뮤텍스","slug":"뮤텍스","link":"/tags/%EB%AE%A4%ED%85%8D%EC%8A%A4/"},{"name":"세마포어","slug":"세마포어","link":"/tags/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"자바","slug":"자바","link":"/tags/%EC%9E%90%EB%B0%94/"},{"name":"Class 클래스","slug":"Class-클래스","link":"/tags/Class-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"race condition","slug":"race-condition","link":"/tags/race-condition/"},{"name":"system call","slug":"system-call","link":"/tags/system-call/"},{"name":"subroutine","slug":"subroutine","link":"/tags/subroutine/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"배열","slug":"배열","link":"/tags/%EB%B0%B0%EC%97%B4/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"Inner Class","slug":"Inner-Class","link":"/tags/Inner-Class/"},{"name":"내부 클래스","slug":"내부-클래스","link":"/tags/%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"Custom Exception","slug":"Custom-Exception","link":"/tags/Custom-Exception/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Stream","slug":"Stream","link":"/tags/Stream/"},{"name":"reduce","slug":"reduce","link":"/tags/reduce/"},{"name":"Log","slug":"Log","link":"/tags/Log/"},{"name":"로그","slug":"로그","link":"/tags/%EB%A1%9C%EA%B7%B8/"},{"name":"Basic","slug":"Basic","link":"/tags/Basic/"},{"name":"클래스 프레임워크","slug":"클래스-프레임워크","link":"/tags/%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Class Framework","slug":"Class-Framework","link":"/tags/Class-Framework/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"람다식","slug":"람다식","link":"/tags/%EB%9E%8C%EB%8B%A4%EC%8B%9D/"},{"name":"데코레이터 패턴","slug":"데코레이터-패턴","link":"/tags/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/"},{"name":"Decorator Pattern","slug":"Decorator-Pattern","link":"/tags/Decorator-Pattern/"},{"name":"Serialization","slug":"Serialization","link":"/tags/Serialization/"},{"name":"직렬화","slug":"직렬화","link":"/tags/%EC%A7%81%EB%A0%AC%ED%99%94/"},{"name":"IOStream","slug":"IOStream","link":"/tags/IOStream/"},{"name":"입출력 스트림","slug":"입출력-스트림","link":"/tags/%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%8A%A4%ED%8A%B8%EB%A6%BC/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"쓰레드","slug":"쓰레드","link":"/tags/%EC%93%B0%EB%A0%88%EB%93%9C/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"DesignPattern","slug":"DesignPattern","link":"/tags/DesignPattern/"},{"name":"gRPC","slug":"gRPC","link":"/tags/gRPC/"},{"name":"LINUX","slug":"LINUX","link":"/tags/LINUX/"},{"name":"M1","slug":"M1","link":"/tags/M1/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"REST","slug":"REST","link":"/tags/REST/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Object Mapper","slug":"Object-Mapper","link":"/tags/Object-Mapper/"},{"name":"IPC","slug":"IPC","link":"/tags/IPC/"},{"name":"POSIX","slug":"POSIX","link":"/tags/POSIX/"},{"name":"Pipe","slug":"Pipe","link":"/tags/Pipe/"},{"name":"서버 자동화","slug":"서버-자동화","link":"/tags/%EC%84%9C%EB%B2%84-%EC%9E%90%EB%8F%99%ED%99%94/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"singleton","slug":"singleton","link":"/tags/singleton/"},{"name":"디자인 패턴","slug":"디자인-패턴","link":"/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"},{"name":"어탭터 패턴","slug":"어탭터-패턴","link":"/tags/%EC%96%B4%ED%83%AD%ED%84%B0-%ED%8C%A8%ED%84%B4/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"servlet","slug":"servlet","link":"/tags/servlet/"},{"name":"validation","slug":"validation","link":"/tags/validation/"},{"name":"filter","slug":"filter","link":"/tags/filter/"},{"name":"annotation","slug":"annotation","link":"/tags/annotation/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"method","slug":"method","link":"/tags/method/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"interceptor","slug":"interceptor","link":"/tags/interceptor/"},{"name":"session","slug":"session","link":"/tags/session/"},{"name":"비동기","slug":"비동기","link":"/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"name":"docker registry","slug":"docker-registry","link":"/tags/docker-registry/"},{"name":"Controller","slug":"Controller","link":"/tags/Controller/"},{"name":"Entity Listener","slug":"Entity-Listener","link":"/tags/Entity-Listener/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"큐","slug":"큐","link":"/tags/%ED%81%90/"},{"name":"State Pattern","slug":"State-Pattern","link":"/tags/State-Pattern/"},{"name":"리스트","slug":"리스트","link":"/tags/%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"트리","slug":"트리","link":"/tags/%ED%8A%B8%EB%A6%AC/"},{"name":"이진트리","slug":"이진트리","link":"/tags/%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"name":"JPA Annotation","slug":"JPA-Annotation","link":"/tags/JPA-Annotation/"},{"name":"계수정렬","slug":"계수정렬","link":"/tags/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/"},{"name":"퀵정렬","slug":"퀵정렬","link":"/tags/%ED%80%B5%EC%A0%95%EB%A0%AC/"},{"name":"AVL트리","slug":"AVL트리","link":"/tags/AVL%ED%8A%B8%EB%A6%AC/"},{"name":"spring security","slug":"spring-security","link":"/tags/spring-security/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"깊이 우선 탐색","slug":"깊이-우선-탐색","link":"/tags/%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"너비 우선 탐색","slug":"너비-우선-탐색","link":"/tags/%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"},{"name":"해시","slug":"해시","link":"/tags/%ED%95%B4%EC%8B%9C/"},{"name":"그래프","slug":"그래프","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"},{"name":"순차 탐색","slug":"순차-탐색","link":"/tags/%EC%88%9C%EC%B0%A8-%ED%83%90%EC%83%89/"},{"name":"이진 탐색","slug":"이진-탐색","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89/"},{"name":"우선순위","slug":"우선순위","link":"/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84/"},{"name":"이진 탐색 트리","slug":"이진-탐색-트리","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC/"},{"name":"이진 트리","slug":"이진-트리","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC/"},{"name":"프림 알고리즘","slug":"프림-알고리즘","link":"/tags/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Prim&#39;s Algorithm","slug":"Prim-s-Algorithm","link":"/tags/Prim-s-Algorithm/"},{"name":"추상 클래스","slug":"추상-클래스","link":"/tags/%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"AbstractClass","slug":"AbstractClass","link":"/tags/AbstractClass/"},{"name":"다운캐스팅","slug":"다운캐스팅","link":"/tags/%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85/"},{"name":"DownCasting","slug":"DownCasting","link":"/tags/DownCasting/"},{"name":"가상메서드","slug":"가상메서드","link":"/tags/%EA%B0%80%EC%83%81%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"VirtualMethod","slug":"VirtualMethod","link":"/tags/VirtualMethod/"},{"name":"자바 기초","slug":"자바-기초","link":"/tags/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88/"},{"name":"상속","slug":"상속","link":"/tags/%EC%83%81%EC%86%8D/"},{"name":"Inheritance","slug":"Inheritance","link":"/tags/Inheritance/"},{"name":"다형성","slug":"다형성","link":"/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"PolyMorphism","slug":"PolyMorphism","link":"/tags/PolyMorphism/"}],"categories":[{"name":"Interview","slug":"Interview","link":"/categories/Interview/"},{"name":"OS","slug":"Interview/OS","link":"/categories/Interview/OS/"},{"name":"Network","slug":"Interview/Network","link":"/categories/Interview/Network/"},{"name":"Basic","slug":"Basic","link":"/categories/Basic/"},{"name":"Java","slug":"Basic/Java","link":"/categories/Basic/Java/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Spring","slug":"Basic/Spring","link":"/categories/Basic/Spring/"},{"name":"gRPC","slug":"gRPC","link":"/categories/gRPC/"},{"name":"LINUX","slug":"Basic/LINUX","link":"/categories/Basic/LINUX/"},{"name":"Web &amp; Network","slug":"Basic/Web-Network","link":"/categories/Basic/Web-Network/"},{"name":"OS","slug":"Basic/OS","link":"/categories/Basic/OS/"},{"name":"JPA","slug":"Basic/JPA","link":"/categories/Basic/JPA/"},{"name":"Trouble Shooting","slug":"Trouble-Shooting","link":"/categories/Trouble-Shooting/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"자료구조","slug":"자료구조","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"Spring Security","slug":"Basic/Spring-Security","link":"/categories/Basic/Spring-Security/"}]}