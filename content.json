{"pages":[],"posts":[{"title":"자바의 클래스","text":"Java의 유용한 클래스들Object Class 모든 클래스의 최상위 클래스 모든 class는 Object클래스를 상속받는다. 메서드 중 일부는 필요에 의해 재정의 할 수 있다. java.lang 패키지 안에 포함되어 있다. java.lang 프로그래밍 시 자동으로 import된다 많이 사용하는 기본 클래스들이 속한 패키지 String, Integer, System 등 toString() 메서드 객체의 정보를 String으로 바꾸어서 사용할 때 쓰인다. 재정의하여 참조변수가 멤버 변수 값을 return하게 할 수 있다. 예제 코드 확인하기 1234567891011121314151617181920212223class Book{ private String title; private String author; public Book(String title, String author){ this.title = title; this.author = author; } @Override public String toString() { return title + &quot;,&quot; + author; }}public class BookTest {public static void main(String[] args){Book book = new Book(&quot;데미안&quot;, &quot;헤르만 헤세&quot;);System.out.println(book);}} equals(), hashCode() 메서드 equals() 메서드와 hashCode() 메서드는 짝을 이룬다. equals()를 overriding하면 객체가 반환하는 hash값도 overriding해줘야 한다. equals에서 사용한 멤버 변수를 hashCode 값으로 반환해주면 된다. equals() 메서드 두 인스턴스의 주소 값을 비교하여 true/false를 반환 인스턴스가 다르더라도 논리적으로 동일한 경우 true를 반환하도록 재정의 할 수 있다. 두 객체가 논리적으로 같다라고 하면 반환하는 Hash Code 값이 같아야한다. Java에서 주소 값은 Hash Code(해쉬 값)이라고 한다. heap 메모리를 관리하는 방식이 Hash방식이다. hashCode() 메서드 인스턴스의 저장 주소를 반환한다. hash : 정보를 저장, 검색하는 자료 구조 자료의 특정 값(key)에 대한 저장 위치를 반환해주는 hash함수를 사용한다. index(저장위치) = hash(key) Overriding 코드 확인하기 12345678910111213141516171819202122232425262728293031323334package ch02;public class Student {private int studentNum;private String studentName; public Student(int StudentNum, String studentName){ this.studentNum = studentNum; this.studentName = studentName; } @Override public String toString(){ return studentNum + &quot;,&quot; + studentName; } @Override public boolean equals(Object obj) { if (obj instanceof Student) { // 다운캐스팅 Student std = (Student)obj; if (this.studentNum == std.studentNum){ return true; } } return false; } @Override public int hashCode() { return studentNum; }} 예제 코드 확인하기 1234567891011121314151617181920package ch02;public class EqualsTest {public static void main(String[] args){ Student std1 = new Student(200, &quot;Lee&quot;); Student std2 = new Student(200, &quot;Lee&quot;); System.out.println(std1==std2); //false System.out.println(std1.equals(std2)); //true // hashCode() 가 studentNum을 return하도록 overriding하였음. System.out.println(std1.hashCode()); System.out.println(std2.hashCode()); // 원래 hashCode값 출력하는 방법 System.out.println(System.identityHashCode(std1)); System.out.println(System.identityHashCode(std2)); }} clone() 메서드 객체를 생성자를 통해 생성할 때, clone()을 사용하면 원본 객체와 원본을 복제하는데 사용한다. 생성자 : 초기값을 가지고 생성이 된다. clone() : 중간에 멤버변수가 변하면 변한 값을 그대로 복제한다. private까지 모두 복제가 되어 객체 보호의 관점에서 위배할 수 있다. 명시적으로 clone() 메서드의 사용을 허용한다는 의미로 Cloneable interface를 명시해준다. public class A implements Cloneable {~} A 클래스 내에서 clone() 메서드를 Override한다.1234@Overrideprotected Object clone() throws CloneNotSupportedException {return super.clone();} 클론 코드 Student copyStd = (Student)std1.clone();","link":"/08/19/JavaClasses/"},{"title":"String 관련 Class","text":"String 관련 ClassString 클래스선언 String str = new String(“abc”); 힙 메모리에 생성된다. String str2 = “abc”; 상수 pool의 abc라는 String에 address가 생성된다. 두 개의 인스턴스는 다르다. 힙 메모리는 생성될 때마다 다른 주소값을 가지지만, 상수 pool의 문자열은 모두 같은 주소를 가진다. 메모리 한번 생성된 String은 immutable(불변)이다. String을 연결하면 기존의 String에 연결되는 것이 아닌 새로운 문자열을 위한 메모리가 생성된다. 예제 코드 확인하기 12345678String java = new String(“java”); String android = new String(“android”); java = java.concat(android) // 위 2가지 문자열을 합해주고 java가 가리키게 한다.// 문자열 java, android, javaandroid을 위한 메모리가 계속해서 할당되어 있고, java는 “java”가 아닌 “javaandroid”를 가리킨다.// 기존 메모리에 덮어쓰는 것이 아닌 새로운 메모리를 할당한다. StringBuilder, StringBuffer 위 메모리 낭비를 해결하기 위해 StringBuilder, StringBuffer를 활용한다. 내부적으로 가변적인 char[]를 멤버 변수를 가진다. 새로운 인스턴스를 생성하지 않고, char[]를 변경한다. 문자열을 연결, 변경할 때 유용하게 사용할 수 있다.차이점 StringBuilder : 단일 쓰레드에서 사용한다. StringBuffer : 멀티 쓰레드 프로그래밍에서 동기화를 보장한다. 두 개 이상의 쓰레드가 같은 메모리에 접근할 때 순서를 가지게 된다. 예제 코드 확인하기 12345678910111213141516171819package ch03;public class StringBuilderTest {public static void main(String[] args) {String java = new String(&quot;java&quot;);String android = new String(&quot;android&quot;); // 매개변수로 String을 받는다. StringBuilder buffer = new StringBuilder(java); System.out.println(System.identityHashCode(buffer)); // 문자열을 추가, 변경해도 메모리값은 변하지 않는다. buffer.append(android); System.out.println(System.identityHashCode(buffer)); System.out.println(buffer.toString()); }} Text Block 사용하기 Java 13 이상부터 제공한다. 하나의 string을 연결해서 사용할 때 사용한다. 서블릿 등 서버사이드에서 클라이언트 쪽으로 데이터를 html, json 프로토콜로 요청할 때 유용하다. “”” “”” 안에 string을 넣어 사용한다. 예제 코드 확인하기 1234567891011121314package ch03;public class TextBlockTest {public static void main(String[] args) { String textBlocks = &quot;&quot;&quot; Hello, hi, how r u &quot;&quot;&quot;; System.out.println(textBlocks); }}","link":"/08/19/String/"},{"title":"예외처리","text":"예외처리 (Exception)특징 Java에서 발생하는 문제는 오류(Error)와 예외(Exception)로 구분할 수 있다. 오류 (Error) 시스템 오류(Error) : 가상머신에서 발생하고, 개발자가 처리할 수 없는 오류 동적 메모리가 없는 경우, 스택 오버플로우 등 컴파일 오류 (Compile Error) 프로그램 코드 작성 중 발생하는 문법적인 오류 IDE에서 컴파일 오류를 detection할 수 있다. 실행 오류 (Runtime Error) 실행 중인 프로그램이 중단되거나 의도하지 않은 동작(bug)을 하는 오류 예외 (Exception) 프로그램에서 제어할 수 있는 오류 DB, Network Connection 등 중요성 프로그램의 비정상적인 종료를 피할 수 있다. log를 적절하게 남기고, 분석을 통해 원인을 파악하고 bug를 수정하여야 한다. 상세하게 level별로 남겨야한다. 예외 클래스 https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html 예외 처리try-catch문12345try{ 예외가 발생할 수 있는 코드} catch (처리할 예외 타입) { try 블록 안에서 예외가 발생했을 때 예외처리 코드} 예제코드 확인하기 12345678910111213141516171819package ch08;public class ArrayindexExceptionTest { public static void main(String[] args) { int[] arr = {1,2,3,4,5}; try{ for (int i = 0 ; i &lt;=5 ; i++){ System.out.println(arr[i]); } } catch(ArrayIndexOutOfBoundsException e){ System.out.println(e.getMessage()); System.out.println(e.toString()); } }} try-catch-finally문 try()블럭이 수행되면 finally() 블럭은 항상 수행된다. return이 포함되어 있어도 수행된다. 예제 코드 확인하기 123456789101112131415161718192021222324252627282930package ch08;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileExceptionHandling { public static void main(String[] args) { FileInputStream fis = null ; try { fis = new FileInputStream(&quot;a.txt&quot;); System.out.println(&quot;read&quot;); } catch (FileNotFoundException e) { System.out.println(e); return; } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } System.out.println(&quot;finally&quot;); } System.out.println(&quot;end&quot;); }} try-with-resource문 java7 이후로 FileInputStream클래스가 AutoCloseable 인터페이스를 implement하여 close를 하지 않아도 자동으로 해제된다. java9부터 리소스는 try() 외부에서 선언하고 try(var)와 같이 사용할 수 있다.1234FileInputStream fis = new FileInputStream(&quot;a.text&quot;);try(fis){...} 예제 코드 확인하기 12345678910111213141516171819202122package ch08;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileExceptionHandling { public static void main(String[] args) { // 자동으로 close가 된다. try (FileInputStream fis = new FileInputStream(&quot;a.txt&quot;)){ System.out.println(&quot;read&quot;); // file을 불러올 때 생길 수 있는 에러 } catch (FileNotFoundException e) { e.printStackTrace(); // file을 close할 때 생길 수 있는 에러 } catch (IOException e) { e.printStackTrace(); } System.out.println(&quot;end&quot;); }} 예외처리 미루기 main함수에서 throws를 하게되면 VM으로 넘어가서 abort된다. throws를 이용하여 예외를 발생시키는 문장에서 예외를 처리하게 미룰 수 있다. catch(Exception e) 구문을 통하여 default 처리를 할 수 있다. catch 구문 중 가장 아랫줄에 작성해야 다른 exception을 개별 처리할 수 있다. 예제 코드 확인하기 12345678910111213141516171819202122232425262728293031package ch08;import java.io.FileInputStream;import java.io.FileNotFoundException;public class ThrowsException { // throws하여 메서드를 사용할 때 Exception을 처리하도록 한다. public Class loadClass(String fileName, String className) throws ClassNotFoundException, FileNotFoundException { FileInputStream fis = new FileInputStream(fileName); Class c = Class.forName(className); return c; } public static void main(String[] args) { ThrowsException test = new ThrowsException(); try { test.loadClass(&quot;a.txt&quot;, &quot;abc&quot;); } catch (ClassNotFoundException e) { System.out.println(e); } catch (FileNotFoundException e) { System.out.println(e); } catch (Exception e) { System.out.println(&quot;default Exception&quot;); } System.out.println(&quot;end&quot;); }} 사용자 정의 예외클래스 자바에서 제공되는 exception 외 필요한 exception을 생성할 수 있다. 기존 클래스 중 가장 유사한 클래스를 상속을 받거나, Exception 클래스를 상속받는다. Exception을 정의하고, 필요한 순간에 어떠한 exception이 어느 순간에 불려야하는지 구현한다. throws 예외를 호출하는 메서드에게 전가하는 것 메서드에서 상위 메서드로 예외를 던진다. throw exception을 실제로 던지는 것 메서드 내에서 상위 블럭으로 예외를 던진다. Exception 정의하기 12345678package ch10;public class PassWordException extends Exception{ public PassWordException(String message){ super(message); }} 사용자 정의 Exception 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package ch10;public class PassWordTest { private String password; public String getPassword() { return password; } public void setPassword(String password) throws PassWordException { if(password == null) { throw new PassWordException(&quot;비밀번호는 null이 될 수 없습니다.&quot;); } else if (password.length() &lt; 5 ) { throw new PassWordException(&quot;비밀번호는 5자 이상이어야 합니다..&quot;); } else if (password.matches(&quot;[a-zA-Z]+&quot;)){ throw new PassWordException(&quot;비밀번호는 숫자나 특수문자를 포함해야 합니다.&quot;); } this.password = password; } public static void main(String[] args) { PassWordTest test = new PassWordTest(); String password = null; try { test.setPassword(password); System.out.println(&quot;오류없음1&quot;); } catch (PassWordException e) { System.out.println(e.getMessage()); } password = &quot;abc&quot;; try { test.setPassword(password); System.out.println(&quot;오류없음2&quot;); } catch (PassWordException e) { System.out.println(e.getMessage()); } password = &quot;abcde&quot;; try { test.setPassword(password); System.out.println(&quot;오류없음3&quot;); } catch (PassWordException e) { System.out.println(e.getMessage()); } password = &quot;abcde1#&quot;; try { test.setPassword(password); System.out.println(&quot;오류없음4&quot;); } catch (PassWordException e) { System.out.println(e.getMessage()); } }}","link":"/08/25/Exception/"},{"title":"자바 배열 구현","text":"Array 구현 jdk 클래스 : ArrayList, Vector구현 함수 배열은 크기를 미리 정해주어야 한다. ARRAY_SIZE = 배열의 크기 count = 배열 내 요소 개수 addElement = 요소 추가 함수 insertElement = 요소 삽입 함수 removeElement = 요소 제거 함수 getSize = 배열의 크기 getElement = 검색 함수 printAll = 모든 요소 출력 removeAll = 모든 요소 삭제 예제코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class Test { int[] intArr; int count; public int ARRAY_SIZE; public static final int ERROR_NUM = -999999999; public Test() { count = 0; ARRAY_SIZE = 10; intArr = new int[ARRAY_SIZE]; } public Test(int size) { count = 0; ARRAY_SIZE = size; intArr = new int[ARRAY_SIZE]; } public void addElement(int num) { if (count &gt;= ARRAY_SIZE) { System.out.println(&quot;Not enough Memory&quot;); return; } intArr[count++] = num; } public void insertElement(int index, int num) { int i = count - 1; if (count &gt;= ARRAY_SIZE) { System.out.println(&quot;Not enough Memory&quot;); return; } if (index &lt; 0 || index &gt; count) { System.out.println(&quot;Insert Error&quot;); return; } while (i &gt; index) { intArr[i + 1] = intArr[i]; i--; } intArr[index] = num; count++; } public int removeElement(int index) { int ret = ERROR_NUM; if (isEmpty()) { System.out.println(&quot;There is no element&quot;); return ret; } if (index &lt; 0 || index &gt;= count){ System.out.println(&quot;index Error&quot;); return ret; } ret = intArr[index]; for (int i = index; i&lt;count-1; i++){ intArr[i] = intArr[i+1]; } count--; return ret; } private boolean isEmpty() { if (count == 0) { return true; } else return false; } public int getSize(){ return count; } public int getElement(int index){ if (index &lt; 0 || index &gt; count-1){ System.out.println(&quot;검색 위치 오류입니다. 현재 리스트의 개수는 &quot; + count + &quot;입니다.&quot;); return ERROR_NUM; } return intArr[index]; } public void printAll(){ if (count == 0) { System.out.println(&quot;출력할 값이 없습니다.&quot;); return; } for (int i = 0 ; i &lt; count; i++){ System.out.println(intArr[i]); } } public void removeAll(){ for (int i = 0; i &lt; count; i++){ intArr[i] = 0; } count = 0; }}","link":"/08/20/JavaArray/"},{"title":"람다식 (Lambda Expression)","text":"람다식 (Lambda Expression)특징 java8부터 함수형 프로그래밍 방식을 지원하고, 이를 람다식이라고 한다. 함수형 프로그래밍 매개 변수만을 사용하여 만드는 함수인 순수 함수를 구현 외부 자료를 사용하지 않으므로 side effect가 없다 여러 자료를 동시에 처리하는 병렬처리가 가능하다. 함수의 기능이 자료에 독립적이다. 문법 익명 함수 만들기 매개변수와 매개변수를 이용한 실행문으로 구현된다. java는 OOP언어이기 때문에 람다식, 함수로만 클래스를 구성할 수 없다. interface의 메소드를 구현하는 방식으로 한다. 1234567package ch02;@FunctionalInterfacepublic interface Add { int add(int x, int y);} 123456789package ch02;public class AddTest { public static void main(String[] args) { Add add = (x, y) -&gt; {return x+y;}; System.out.println(add.add(2, 3)); }} 람다식과 OOP 방식 비교 람다식에서는 FunctionalInterface 익명 내부 클래스가 생성된다. OOP 방식에서는 Interface를 implement하여 구현하고, 메서드를 호출한다. 123456789101112131415161718192021222324package ch04;public class StringConcatTest { public static void main(String[] args) { String s1 = &quot;Hello&quot;; String s2 = &quot;World&quot;; // OOP 방식 StringConcatImp strImp = new StringConcatImp(); strImp.makeString(s1, s2); // 1. 람다식 구현 방식 StringConcat concat = (s,v)-&gt; System.out.println(s+&quot;,&quot;+v); concat.makeString(s1,s2); // 2. 람다식 구현 방식 StringConcat concat2 = new StringConcat() { @Override public void makeString(String s1, String s2) { System.out.println(s1+&quot;,&quot;+s2); } }; }}","link":"/08/25/Lambda/"},{"title":"Class 클래스","text":"Class 클래스 사용하기 자바의 모든 클래스와 인터페이스는 컴파일 후 class파일이 생성된다. 클래스 내의 메서드, 생성자 배열 등 모든 정보가 들어있다. 컴파일 된 class 파일을 로드하여 객체를 동적으로 로드하고, 정보를 가져오는 메서드가 제공된다. 클래스 동적 로딩Class.forName(“클래스 이름”) Class c = Class.forName(&quot;java.lang.String&quot;) 동적 로딩 일반적으로 Class가 Local에 있는지 살펴보고 binding되어 type으로 정의하여 변수가 사용된다. Compile 할 때가 아닌, 실질적으로 실행할 때 필요한 클래스를 binding하는 방법 ex) JDBC 드라이버에서 실행 전까지 DB의 라이브러리가 어떤 것인지 모르고, property파일 등을 읽을 때 변수로 갖고 있다가 Oracle 드라이버 이름을 String변수에 넣어준다. 장점 : 동적으로 원하는 클래스를 로딩할 수 있다. 단점 : 로딩할 때 Local에 class나 라이브러리가 없는 등 오류가 발생하면 시스템이 다운될 수 있다. 사용 방법 주로 remote에 있는 class를 호출할 때 사용한다. Local에 클래스가 없을 때 아래 코드를 reflection 프로그래밍이라고 한다. 예제 코드 확인하기 1234567891011121314151617181920212223package ch04;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class StringTest { public static void main(String[] args) throws ClassNotFoundException { Class c = Class.forName(&quot;java.lang.String&quot;); // Constructor의 목록을 배열로 가져온다. Constructor[] cons = c.getConstructors(); for (Constructor co : cons) { System.out.println(co); } // 메소드의 목록을 가져온다. Method[] m = c.getMethods(); for (Method mth : m) { System.out.println(mth); } }} 인스턴스 생성 reflection 프로그래밍 Class 클래스를 사용하여 클래스의 정보 등을 알 수 있고, 인스턴스를 생성, 메서드를 호출하는 방식의 프로그래밍 로컬 메모리에 객체가 없는 경우 원격 프로그래밍 (서로 다른 프로세스) 객체의 타입을 알 수 없는 경우 java.lang.reflect 패키지의 클래스를 활용하여 사용 자료형을 알고 있는 경우에는 사용하지 않음 예제 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536package ch04;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public class ClassTest { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { // 1. Class 이름으로 invoke(호출)하기 Class c1 = Class.forName(&quot;ch04.Person&quot;); // Person 타입으로 Casting Person person = (Person)c1.newInstance(); person.setName(&quot;Lee&quot;); System.out.println(person); // 2. 이미 생성된 객체로 invoke Class c2 = person.getClass(); // 2-1. 인스턴스화, Person타입으로 Casting Person person2 = (Person)c2.newInstance(); person2.setName(&quot;Kim&quot;); System.out.println(person2); // 3. 생성자를 호출하여 객체 생성 Class[] classArray = {String.class}; Constructor cons = c2.getConstructor(classArray); // 3-1. Object 배열 형태 Object[] initargs = {&quot;Jeong&quot;}; // Line23에서 불러온 생성자로 객체 생성 Person person3 = (Person)cons.newInstance(initargs); System.out.println(person3); }}","link":"/08/19/Class/"},{"title":"내부 클래스","text":"내부 클래스종류인스턴스(instance) 내부 클래스 인스턴스 변수와 생성 위치, 방법, Scope가 동일하다. 내부적으로 사용할 클래스를 선언 (private으로 선언하는 것을 권장) 외부 클래스가 생성된 후 생성됨 private이 아닌 내부 클래스는 다른 외부 클래스에서 생성할 수 있다. 문법적으로는 가능하지만 잘 사용하지 않는다. 예제 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839package ch01;class OutClass{ private int num = 10; private static int sNum = 20; private InClass inClass; public OutClass(){ inClass = new InClass(); } class InClass{ int iNum = 100; void inTest() { System.out.println(&quot;OutClass num = &quot; +num + &quot;(외부 클래스의 인스턴스 변수)&quot;); System.out.println(&quot;OutClass sNum = &quot; + sNum + &quot;(외부 클래스의 스태틱 변수)&quot;); System.out.println(&quot;InClass inNum = &quot; + iNum + &quot;(내부 클래스의 인스턴스 변수)&quot;); } } public void usingClass(){ inClass.inTest(); }}public class InnerTest { public static void main(String[] args) { OutClass outClass = new OutClass(); outClass.usingClass(); System.out.println(&quot;=========&quot;); OutClass.InClass inner = outClass.new InClass(); inner.inTest(); }} 정적(static) 내부 클래스 정적 변수와 정적 메서드를 사용한다. 내부 클래스의 인스턴스, 스태틱 변수, 외부 클래스의 스태틱 변수를 사용할 수 있다. 외부 클래스 생성과 무관하게 사용할 수 있다. 외부 클래스가 생성되지 않아도 사용할 수 있기 때문에 정적 내부 클래스에서 외부 클래스의 인스턴스 변수를 사용할 수 없다. 정적 내부 클래스의 정적 메서드는 스태틱 변수만 사용할 수 있다. 예제 코드 확인하기 123456789101112131415static class InStaticClass{ int iNum = 100; static int sInNum = 200; void inTest() { System.out.println(&quot;inClass num = &quot; +iNum + &quot;(외부 클래스의 인스턴스 변수)&quot;); System.out.println(&quot;OutClass sNum = &quot; + sNum + &quot;(외부 클래스의 스태틱 변수)&quot;); System.out.println(&quot;InClass inNum = &quot; + sInNum + &quot;(내부 클래스의 인스턴스 변수)&quot;); } static void sTest(){ System.out.println(&quot;OutClass sNum = &quot; + sNum + &quot;(외부 클래스의 스태틱 변수)&quot;); System.out.println(&quot;InClass inNum = &quot; + sInNum + &quot;(내부 클래스의 인스턴스 변수)&quot;); } } 지역(local) 내부 클래스 지역 변수와 같이 메서드 내부에서 정의하여 사용한다. 메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라짐 메서드 호출 이후 반환이 되어도 메서드의 지역 변수를 클래스를 통해 사용할 수 있으므로 final로 처리한다. 예제 코드 확인하기 1234567891011121314151617181920212223242526272829303132333435363738class Outer2{ int outNum = 100; static int sNum = 200; // 메서드 Runnable getRunnable(final int i){ final int num = 10; // 지역 내부 클래스 class MyRunnable implements Runnable{ int localNum = 1000; // 재정의 @Override public void run() { System.out.println(&quot;i =&quot; + i); System.out.println(&quot;num = &quot; +num); System.out.println(&quot;localNum = &quot; +localNum); System.out.println(&quot;outNum = &quot; + outNum + &quot;(외부 클래스 인스턴스 변수)&quot;); System.out.println(&quot;Outter.sNum = &quot; + Outer2.sNum + &quot;(외부 클래스 정적 변수)&quot;); } } return new MyRunnable(); }}public class AnonymousInnerTest { public static void main(String[] args) { Outer2 out = new Outer2(); // 메서드가 Runnable한 값을 runner에 return해주고 해제되었다. Runnable runner = out.getRunnable(100); // 해제된 이후 지역 내부 클래스의 메서드 사용 // final로 선언해주었기 때문에 runner.run(); }} 익명(Anonymous) 내부 클래스 이름이 없는 클래스 지역 내부 클래스의 예시코드에서 클래스 이름 MyRunnable은 실제로 호출되지 않으므로 이를 생략한다. 하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환한다. 예제 코드 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package ch01;class Outer2{ int outNum = 100; static int sNum = 200; // 메서드 Runnable getRunnable(final int i){ final int num = 10; // 익명 내부 클래스 (바로 return값을 입력) return new Runnable(){ int localNum = 1000; // 재정의 @Override public void run() { System.out.println(&quot;i =&quot; + i); System.out.println(&quot;num = &quot; +num); System.out.println(&quot;localNum = &quot; +localNum); System.out.println(&quot;outNum = &quot; + outNum + &quot;(외부 클래스 인스턴스 변수)&quot;); System.out.println(&quot;Outter.sNum = &quot; + Outer2.sNum + &quot;(외부 클래스 정적 변수)&quot;); } }; } // runnable을 생성해서 바로 구현 Runnable runnable = new Runnable() { @Override public void run() { System.out.println(&quot;Runnable class&quot;); } };}public class AnonymousInnerTest { public static void main(String[] args) { Outer2 out = new Outer2(); Runnable runner = out.getRunnable(100); runner.run(); out.runnable.run(); }}","link":"/08/24/InnerClass/"},{"title":"클래스 프레임워크","text":"컬렉션 프레임워크특징 프로그램 구현에 필요한 자료구조를 구현해 놓은 JDK 라이브러리 java.util 패키지에 구현되어 있다. 종류Collection 인터페이스 하나의 요소를 관리할 때 사용한다. 하위에 List와 Set 인터페이스가 있다.Iterator 컬렉션 프레임워크에 저장된 요소를 하나씩 차례로 참조한다. List 인터페이스 : 순서가 정해져 있으므로 get(I)를 사용하여 참조 또한 가능하다. Set 인터페이스 : get(I) 메서드가 제공되지 않으므로 Iterator를 활용하여 객체를 순회한다. Iterator 함수를 호출하면 iterator가 반환이 된다. hasNext() : 이후에 요소가 더 있는지를 체크하는 메서드 E.next() : 다음에 있는 요소를 반환 구현 코드 확인하기 1234567891011Iterator&lt;Member&gt; ir = arrayList.iterator();while (ir.hasNext()){ Member member = ir.next(); int tempId = member.getMemberId(); if (tempId == memberId){ arrayList.remove(member); return true; }}System.out.println(memberId + &quot;가 존재하지 않습니다.&quot;);return false; List 객체를 순서에 따라 저장 및 관리할 때 필요한 메서드가 선언된 인터페이스 리스트 자료구조의 구현을 위한 인터페이스 객체의 중복을 허용한다. ArrayList, Vector, Queue, Stack, LinkedList 등 ArrayList 구현 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445package ch10;import java.util.ArrayList;public class MemberArrayList { private ArrayList&lt;Member&gt; arrayList; public MemberArrayList(){ arrayList = new ArrayList&lt;&gt;(); } public MemberArrayList(int size){ arrayList = new ArrayList&lt;&gt;(size); } public void addMember(Member member){ arrayList.add(member); } public boolean removeMember(int memberId){ // 중복이 가능하므로 어떤 요소를 삭제할 것인지 먼저 retrieve for (int i = 0; i &lt; arrayList.size(); i++){ Member member = arrayList.get(i); int tempId = member.getMemberId(); if (tempId == memberId){ arrayList.remove(i); return true; } } System.out.println(memberId + &quot;가 존재하지 않습니다.&quot;); return false; } public void showAllMember(){ for (Member i :arrayList){ System.out.println(i); } System.out.println(); }} Set 아이디, 주민번호, 사번 등 유일한 값들의 집합을 관리할 때 사용한다. 저정된 순서와 출력 순서가 달라질 수 있다. HashSet 검색을 위한 알고리즘인 Hash 방식으로 구성되어 있고, key 순서와 관계가 없다. 멤버의 중복 여부를 체크하기 위해 인스턴스의 동일성을 확인해야 한다. 동일성 구현을 위해 필요에 따라 equals()와 hashCode() 메서드를 재정의함 hashCode는 객체를 구분하기 위한 unique한 값을 return하게 해준다. Override 코드 확인하기 1234567891011121314151617@Override public int hashCode() { return memberId; } @Override public boolean equals(Object obj) { if (obj instanceof Member) { Member member = (Member)obj; if (this.memberId == member.memberId) { return true; } else return false; } return false; } TreeSet 객체의 정렬에 사용하는 클래스 (중복을 허용하지 않는다.) 내부적으로 Binary Search Tree가 구현이 되어있다. (In-order traversal) Java에서는 balance를 위해 레드-블랙 트리를 사용한다. 비교하기 위한 요소를 구현하여야한다. 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 정렬하기 위해 element를 추가할 때마다 어떻게 비교할 지 comparable, comparator인터페이스를 구현하여야한다. Comparable 코드 확인하기 123456789101112// Comparable 인터페이스를 implement하여 compareTo 메서드를 오버라이딩 public class Member implements Comparable&lt;Member&gt; { ... @Override public int compareTo(Member member) { // this = 삽입되는 값 // this가 크면 양수를 반환하여 오른쪽으로 이동하게 구현되어 있다. // 값이 같으면 (중복되면) 0을 반환하여 삽입되지 않는다. // 내림 차순은 양수, 음수를 바꿔주면 된다. return (this.memberId - member.memberId); }} Comparator 코드 확인하기 123456789101112131415161718192021// 1. Comparator 인터페이스를 implement하여 compare 메서드 오버라이딩.public class Member implements Comparator&lt;Member&gt; { ... @Override public int compare(Member o1, Member o2) { return (o1.memberId - o2.memberId); }}// 2. Comparator를 사용할 때// TreeSet의 constructor(생성자)에 comparator를 구현한 객체를 지정해주어야한다.public MemberTreeSet(){ treeSet = new TreeSet&lt;Member&gt;(new Member());}// 3. 객체에 default constructor가 있어야 사용할 수 있다.public Member(){} Comparator 활용하기 이미 Comparable이 구현된 경우 Comparator로 비교 로직을 다시 구현할 수 있음 String이 제공하는 compare 메서드는 오름차순으로 정렬이 된다. return값에 -1을 곱하여 내림차순으로 수정한다. 기존 코드 12345678TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;(); set.add(&quot;Park&quot;); set.add(&quot;Kim&quot;); set.add(&quot;Lee&quot;); System.out.println(set); // 결과 : [Kim, Lee, Park] Comparator 활용 코드 1234567891011121314151617// 기존 String 클래스의 class MyCompare implements Comparator&lt;String&gt;{ @Override public int compare(String o1, String o2) { return o1.compareTo(o2)*-1; }}// TreeSet을 생성할 때 매개변수로 Comparator를 정의한 클래스를 넣어준다.TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;(new MyCompare()); set.add(&quot;Park&quot;); set.add(&quot;Kim&quot;); set.add(&quot;Lee&quot;); System.out.println(set); Map Key와 value의 pair를 관리할 때 사용한다. Key값은 유일하여, 중복이 허용되지 않는다. HashMap Key를 이용하여 값을 저장하고, 값을 꺼내온다. key가 되는 객체는 중복될 수 없고, 객체의 유일성을 비교하기 위해 equals(), hashCode() 메서드를 구현하여야 한다. Key는 중복이 될 수 없으므로 Set과 같은 개념 Value는 중복이 될 수 있으므로 Collection과 같은 개념으로 보면 된다. 다른 키값이라도 hash함수를 통해 같은 index가 도출될 수 있다. Collision이 발생하며 오버헤드가 발생할 수 있다. Java에서는 hash table의 Load Balance를 약 75%로 산정하여, 이를 방지한다. 100개가 들어갈 수 있는 테이블에 약 75개의 데이터를 수용함 예제 코드 확인하기 1234567HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(1001, &quot;Kim&quot;); hashMap.put(1002, &quot;Lee&quot;); hashMap.put(1003, &quot;Park&quot;); hashMap.put(1004, &quot;Hong&quot;); System.out.println(hashMap); 새로운 객체 HashMap 생성 12345678910111213141516171819202122232425262728293031323334353637import java.util.HashMap;import java.util.Iterator;public class MemberHashMap { private HashMap&lt;Integer, Member&gt; hashMap; public MemberHashMap(){ hashMap = new HashMap&lt;&gt;(); } public void addMember(Member member){ hashMap.put(member.getMemberId(), member); } public boolean removeMember(int memberId){ if (hashMap.containsKey(memberId)){ hashMap.remove(memberId); } System.out.println(&quot;no element&quot;); return false; } public void showAll(){ Iterator&lt;Integer&gt; ir = hashMap.keySet().iterator(); while (ir.hasNext()){ int key = ir.next(); Member member = hashMap.get(key); System.out.println(member); } }} TreeMap 키로 정렬이 되고, tree를 사용한다. TreeSet과 HashMap의 개념을 합한 클래스 key, value 페어 key값을 기준으로 정렬 key에 해당되는 class에 comparable, comparator 정렬 key가 Integer, String이면 기존 메서드 활용하고, 아니면 오버라이딩하여 사용한다.","link":"/08/24/ClassFramework/"},{"title":"reduce 메서드","text":"reduce 메서드reduce() 연산 기존에 정의된 연산이 아닌 직접 구현한 연산을 적용한다.1T reduce(T identify, BinaryOperator&lt;T&gt; accumulator) 최종 연산으로 스트림을 요소를 소모하여 연산을 수행한다. 예시123456789101112131415161718192021222324252627282930313233343536package ch06;import java.util.Arrays;import java.util.function.BinaryOperator;// parameter BinaryOperator&lt;T&gt;를 구현하여 사용class CompareString implements BinaryOperator&lt;String&gt;{ @Override public String apply(String s1, String s2) { if (s1.getBytes().length &gt;= s2.getBytes().length) return s1; else return s2; }}public class ReduceTest { public static void main(String[] args) { String greetings[] = {&quot;안녕히계세요~~~&quot;, &quot;hello&quot;, &quot;Goood morning&quot;, &quot;반갑습니다&quot;}; // 1. 직접 작성 System.out.println(Arrays.stream(greetings).reduce(&quot;&quot;, (s1,s2)-&gt; {if (s1.getBytes().length &gt;= s2.getBytes().length) return s1; else return s2;} )); // 2. BinaryOperator&lt;T&gt;의 메서드 implement // 새로운 클래스로 생성하여 사용한다. String str = Arrays.stream(greetings).reduce(new CompareString()).get(); System.out.println(str); }}","link":"/08/25/reduce/"},{"title":"이진 트리","text":"이진트리 (Binary Tree)특징 일반적인 트리는 한 개의 노드가 여러 개의 자식 노드를 가질 수 있다. 이진 트리는 노드 1개 당 최대 2개의 자식 노드를 가질 수 있다. 종류포화 이진트리 (Full Binary Tree) 리프 노드(최하단 노드)를 제외한 모든 노드가 2개의 자식 노드를 가진 구조. 완전 이진트리 (Complete Binary Tree) 왼쪽 노드부터 점진적으로 채워진 구조 높이 균형 트리 (Height Balanced Tree) 왼쪽, 오른쪽 트리의 높이의 차이가 1이하인 트리 구현순회 전, 중, 후를 root의 순서로 보면 이해하기 쉽다. 전위순회 (Preorder) 순서 : root -&gt; 왼쪽 노드-&gt; 오른쪽 노드 중위순회 (Inorder) 순서 : 왼쪽 노드 -&gt; root -&gt; 오른쪽 노드 후위순회 (Postorder) 순서 : 왼쪽 노드 -&gt; 오른쪽 노드 -&gt; root","link":"/08/04/20210804-BinaryTree/"},{"title":"연결리스트","text":"연결리스트 (Linked List)특징 데이터를 선형적으로 저장 및 처리한다. 삽입과 삭제가 많은 경우 효율적이다. 리스트의 중간 지점에 노드의 추가/삭제가 가능하여야 한다. 메모리 공간을 미리 할당하는 배열을 보완하여 공간 낭비를 감소시킨다. ✚ 배열 기반의 리스트 장점 : 즉시 접근이 가능하다. 단점 : 삽입 삭제가 비효율적이며 메모리 공간을 미리 할당한다. 종류단일 연결리스트 단일 연결리스트는 가장 앞의 노드를 가르키는 HEAD를 갖는다. 각 노드별로 동적 메모리를 할당하여야 하며, 각 노드를 연결시켜주어야 한다. ####︎︎ 노드 삽입 HEAD 다음에 노드를 삽입한다고 가정 ‘HEAD의 *next’가 ‘삽입 노드의 값’을 가리키게 한다. ‘삽입 노드의 *next’가 ‘기존 노드의 값’을 가리키게 한다. 노드 삭제 HEAD 다음에 위치한 노드를 삭제한다고 가정 ‘HEAD의 *next’가 ‘삭제될 노드의 다음 값’을 가리키게 한다. 삭제된 노드의 동적 메모리를 해제하여 메모리 누수를 방지한다.","link":"/07/30/20210730-til1/"},{"title":"선택 및 삽입 정렬","text":"선택 정렬 (Selection Sort)특징 가장 작은 것을 선택해서 앞으로 보냄 시간복잡도 : 가장 작은 데이터 선택 (N) * 앞으로 보내기 (N) = O(N^2) 삽입 정렬특징 각 숫자를 적절한 위치에 삽입 일반적으로 선택 정렬보다 빠르게 동작한다. 시간복잡도 : 들어갈 위치를 선택 (N) * 데이터를 선택하는 횟수 (N) = O(N^2)","link":"/08/04/20210804-til3/"},{"title":"스트림","text":"스트림 (Stream)특징 배열, collection 자료가 모여있을 때 연산의 처리를 일관성 있게 한다. 자료 처리에 대한 추상화가 구현되었다고 한다. 일관성 있는 연산으로 자료의 처리를 쉽고 간단하게 한다. 한번 생성하고 사용한 스트림은 재사용 할 수 없다. 다른 연산을 수행하기 위해서는 스트림을 다시 생성해야 한다. 123456789101112131415161718192021222324package ch06;import java.util.Arrays;import java.util.stream.IntStream;public class IntArrayStreamTest { public static void main(String[] args) { int[] arr = {1, 2, 3, 4, 5}; for (int num : arr) { System.out.println(num); } System.out.println(&quot;========&quot;); // 모든 Array는 Arrays 클래스를 활용할 수 있다. IntStream is = Arrays.stream(arr); is.forEach(n -&gt; System.out.println(n)); //is는 한번 소모하였으니 다시 사용할 수 없다. // 재사용하고 싶을 때 재생성 int sum = Arrays.stream(arr).sum(); System.out.println(sum); }} 연산 스트림의 연산은 중간 연산과 최종 연산으로 구분된다. 중간 연산은 여러 개의 연산이 적용될 수 있지만 최종 연산은 마지마게 한 번만 적용된다. 지연 연산 최종 연산이 호출되어야 중간 연산에 대한 수행이 이루어지고 결과가 만들어진다. 중간연산 filter() : 조건에 맞는 요소를 추출 map() : 조건에 맞는 요소를 변환 sorted() : 정렬 최종연산 forEach() : 요소를 하나씩 꺼내옴 count() : 요소의 개수 반환 sum() : 요소들의 합 예제 코드 확인하기 1234567891011121314151617181920212223242526272829303132package ch06;import java.util.ArrayList;import java.util.List;import java.util.stream.Stream;public class ArrayListStreamTest { public static void main(String[] args) { List&lt;String&gt; sList = new ArrayList&lt;String&gt;(); sList.add(&quot;Thomas&quot;); sList.add(&quot;Edward&quot;); sList.add(&quot;Jack&quot;); Stream&lt;String&gt; stream = sList.stream(); stream.forEach(s-&gt;System.out.println(s)); sList.stream().sorted().forEach(s-&gt;System.out.print(s + &quot;\\t&quot;)); System.out.println(); sList.stream().map(s-&gt;s.length()).forEach(n-&gt;System.out.print(n + &quot;\\t&quot;)); System.out.println(); sList.stream().filter(s-&gt;s.length()&gt;=5).forEach(s-&gt;System.out.print(s + &quot;\\t&quot;)); }}// 결과//Thomas//Edward//Jack//Edward Jack Thomas//6 6 4//Thomas Edward","link":"/08/25/Stream/"},{"title":"계수 및 기수 정렬","text":"계수 정렬 (Counting Sort)특징 데이터의 크기가 한정적일 때 사용한다. 데이터를 읽어나가면서 바로 정렬한다 시간복잡도 : O(N) 기수 정렬 (Radix Sort)특징 자리 수를 기준으로 차례대로 데이터를 정렬한다. 자리 수는 가장 큰 값의 자리수를 기준으로 한다. 예시 ) 가장 큰 값 : 345 (1, 10, 100의 자리)","link":"/08/04/20210804-til5/"},{"title":"AVL트리","text":"AVL 트리특징 ‘AVL 트리’는 균형이 갖춰진 이진 트리이다. 균형을 갖추기 위해 회전(Rotation)을 통해 재구성할 수 있다. 균형 균형 인수가 -1, 0, +1 인 상태 균형 인수 왼쪽 자식의 높이 - 오른쪽 자식의 높이 불균형 상태LL 형식 노드가 Left1-Left2로 편향되어 있는 상태재구성 결과적으로 편향된 노드들을 가진 노드(2)를 root가 된다. 노드(2)가 가지고있던 오른쪽 자식 노드들을 root(1)의 왼쪽 자식 노드로 설정한다. 기존의 root(1)는 노드(2)의 오른쪽 자식 노드로 설정한다. RR 형식 노드가 Right1-Right2로 편향되어 있는 상태재구성 LL형식의 재구성 방식을 반대로 수행한다. 편향된 노드의 왼쪽 자식 노드를 root의 오른쪽 노드로 설정한다. 편향된 노드의 왼쪽 자식 노드를 root로 설정한다. LR 형식 노드가 Left1-Right1로 편향되어 있는 상태 편향된 노드에 RR회전을 수행하여 불균형 노드를 왼쪽으로 몰아 넣는다. 몰아넣은 노드에 LL회전을 수행한다. RL 형식 노드가 Right1-Left1로 편향되어 있는 상태 편향된 노드에 LL회전을 수행하여 불균형 노드를 오른쪽으로 몰아 넣는다. 몰아넣은 노드에 RR회전을 수행한다.","link":"/08/05/20210805-AVLtree/"},{"title":"이진 탐색 트리","text":"이진 탐색 트리 (Binary Search Tree)특징 이진 탐색 트리에서 부모 노드는 왼쪽 자식 노드보다는 크고 오른쪽 자식 노드보다는 작다 값의 크기 비교 : 왼쪽 자식 노드 &lt; 부모 노드 &lt; 오른쪽 자식 노드 탐색 속도를 극대화할 수 있는 구조이다. 한 번 확인할 때 마다 탐색할 노드의 개수가 절반씩 줄어든다. 완전 이진 탐색 트리에서 실행할 경우 O(logN)의 시간복잡도를 가진다. 탐색 트리 내의 데이터를 탐색한다. 탐색하고 싶은 노드를 부모 노드와 비교한다. 부모 노드보다 클 경우 오른쪽 자식 노드에 포함되므로 오른쪽으로 이동한다. 부모 노드보다 작을 경우 왼쪽 자식 노드에 포함되므로 왼쪽으로 이동한다. 삽입 삽입하고 싶은 데이터를 부모 노드와 비교하여 탐색 프로세스와 같이 이동하며 적절한 위치에 값을 삽입한다. 삭제 자식 노드가 없는 노드의 삭제 데이터를 탐색하여 삭제한다. 1개의 자식 노드가 있는 노드의 삭제 삭제할 노드의 자리에 자식 노드를 삽입한다. 2개의 자식 노드가 있는 노드의 삭제 삭제할 노드 다음으로 큰 노드를 삭제할 노드의 위치에 삽입한다.","link":"/08/05/20210805-BinarySearchTree/"},{"title":"큐","text":"큐 (Queue)특징 데이터가 뒤(rear)로 들어가서 앞(front)으로 나오는 자료 FIFO (First In First Out) 스케줄링, 탐색 알고리즘 등에서 사용된다. 구현배열로 구현선언 배열은 사전에 배열의 크기를 지정해줘야한다. front와 rear를 선언해준다. 1234567#include &lt;stdio.h&gt;#define SIZE 10000#define INF 99999999int queue[SIZE];int front = 0;int rear = 0; 삽입 큐는 한 쪽으로만 데이터가 들어간다. 큐의 마지막인 rear에 1을 추가하여 데이터를 삽입해준다. 배열의 크기를 초과했을 때는 큐 오버플로우를 선언해준다. 1234567void push(int data) { if (rear &gt;= SIZE) { printf(&quot;큐 오버플로우가 발생했습니다. \\n&quot;); return; } queue[rear++] = data;} 삭제 큐는 삽입과 같이 한 쪽에서만 데이터가 나온다. 큐의 front++를 return함으로써 front를 제거한다. 큐가 비어있을 때 시도하면 언더플로우를 선언한다. 1234567void pop() { if (front == rear) { printf(&quot;큐 언더플로우가 발생했습니다. \\n&quot;); return -INF; } return queue[front++];} 모든 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#define SIZE 10000#define INF 99999999int queue[SIZE];int front = 0;int rear = 0;void push(int data) { if (rear &gt;= SIZE) { printf(&quot;큐 오버플로우가 발생했습니다. \\n&quot;); return; } queue[rear++] = data;}void pop() { if (front == rear) { printf(&quot;큐 언더플로우가 발생했습니다. \\n&quot;); return -INF; } return queue[front++];}void show() { printf(&quot;---큐의 앞--- \\n&quot;); for (int i = front; i &lt; rear; i++) { printf(&quot;%d\\n&quot;, queue[i]); } printf(&quot;---큐의 뒤--- \\n&quot;);}int main(void) { push(7); push(5); push(1); pop(); show(); system(&quot;pause&quot;); return 0;} 연결리스트로 구현선언 data와 노드와 다음 데이터를 연결하는 next를 구조에 포함한다. 데이터가 나오는 front, 들어가는 node, 데이터 수를 담을 count를 선언한다. 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INF 99999999typedef struct { int data; struct Node* next;}Node;typedef struct { Node* front; Node* rear; int count;}Queue; 삽입 새로운 node를 동적메모리에 할당해준다. node에 데이터를 담고, next는 NULL로 초기화해준다. 조건문을 통해 큐에 데이터가 없을 시 front로 선언한다. 데이터가 존재할 시 큐의 rear가 node를 가리키게 한다. 큐의 rear를 node로 지정하고, count를 추가해준다. 12345678910111213void push(Queue* queue, int data) { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; node-&gt;next = NULL; if (queue-&gt;count == 0) { queue-&gt;front = node; } else { queue-&gt;rear-&gt;next = node; } queue-&gt;rear = node; queue-&gt;count++;} 삭제 큐에 데이터가 없을 시 실행하면 언더플로우를 선언해준다. 큐의 front를 담을 노드를 생성하고, 데이터도 담아준다. 큐의 front를 위 노드의 next로 선언한다. 기존의 front 다음의 데이터가 front가 되는 것 원래의 front를 담고 있던 node를 해제해주고, count를 감소시킨다. 12345678910111213void pop(Queue* queue) { if (queue-&gt;count == 0) { printf(&quot;큐 언더플로우가 발생하였습니다. \\n&quot;); return -INF; } Node* node = queue-&gt;front; int data = node-&gt;data; queue-&gt;front = node-&gt;next; free(node); queue-&gt;count--; return data;} 모든 코드 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INF 99999999typedef struct { int data; struct Node* next;}Node;typedef struct { Node* front; Node* rear; int count;}Queue;void push(Queue* queue, int data) { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; node-&gt;next = NULL; if (queue-&gt;count == 0) { queue-&gt;front = node; } else { queue-&gt;rear-&gt;next = node; } queue-&gt;rear = node; queue-&gt;count++;}void pop(Queue* queue) { if (queue-&gt;count == 0) { printf(&quot;큐 언더플로우가 발생하였습니다. \\n&quot;); return -INF; } Node* node = queue-&gt;front; int data = node-&gt;data; queue-&gt;front = node-&gt;next; free(node); queue-&gt;count--; return data;}void show(Queue* queue) { Node* cur = queue-&gt;front; printf(&quot;---큐의 앞---\\n&quot;); while (cur != NULL) { printf(&quot;%d\\n&quot;, cur-&gt;data); cur = cur-&gt;next; } printf(&quot;---큐의 뒤---&quot;);}int main(void) { Queue queue; queue.front = queue.rear = NULL; queue.count = 0; push(&amp;queue, 7); push(&amp;queue, 5); push(&amp;queue, 4); pop(&amp;queue); push(&amp;queue, 6); pop(&amp;queue); show(&amp;queue); system(&quot;pause&quot;); return 0;}","link":"/08/03/20210803-til2-md/"},{"title":"그래프 탐색","text":"그래프 탐색깊이 우선 탐색 (Depth First Search)특징 깊은 것을 우선적으로 탐색한다. 전체 노드를 탐색하며, 모든 경우의 수를 탐색한다. 스택 자료구조에 기초하며, O(N)이 소요된다. 구현 모든 노드는 탐색되지 않은 상태임을 가정 스택에 삽입되면 탐색이 완료된 것으로 간주한다. 탐색을 시작할 노드를 스택에 삽입(탐색)한다. 시작 노드와 인접한 노드를 순차적으로 스택에 삽입(탐색)한다. 더이상 인접한 노드가 없을 때는 스택에서 순차적으로 노드를 꺼낸다. 너비 우선 탐색 (Breadth First Search)특징 너비를 우선으로 하여 탐색을 수행한다. 전체 노드를 탐색하고, DFS보다 빠르다. 큐 자료구조에 기초하며, O(N)이 소요된다. 고급 그래프 탐색 알고리즘에서 자주 활용된다. 구현 모든 노드는 탐색되지 않은 상태임을 가정 스택에 삽입되면 탐색이 완료된 것으로 간주한다. 탐색을 시작할 노드를 큐에 삽입한다. 삽입한 노드를 꺼내고, 인접 노드를 삽입한다. 2를 더이상 수행할 수 없을 때까지 반복한다.","link":"/08/05/20210805-DFS/"},{"title":"해시","text":"해시 (Hash)특징 해시를 이용하면 메모리를 많이 소요하지만 최대 빠른 속도로 관리할 수 있다. DB 소프트웨어에서 많이 사용된다. 수학적 연산을 통한 키를 이용하여 값에 접근한다. 나머지를 사용하는 방법이 보편적이다. 테이블 크기를 소수로 설정하여야 충돌 확률이 낮다. 키가 중복이 생길 경우 충돌이 생긴다고 표현하는데 이를 해결하는 방법에는 2가지가 있다. 충돌 해결충돌 시 다른 위치에 저장하기 선형 조사법 키가 중복이 생기면 해당 키의 다음 인덱스에 데이터를 저장한다. 다시 중복이 생기면 인덱스+1을 해나가며 저장한다. 단점 충돌이 발생하기 시작하면 유사한 값을 가지는 데이터가 밀집되는 집중 결합 문제가 발생한다. 테이블의 크기가 매우 크면, 충돌은 적어지고, 데이터에 빠르게 접근할 수 있다. 이차 조사법 키 값이 중복되면 완전 제곱수를 더해 나가며 저장한다. 인덱스+1, 인덱스+4 … 선형 조사법 및 이차 조사법에서 데이터의 수가 테이블 인덱스를 초과하게 되면 크기를 확장하여 유지할 수 있도록 설정하여야 한다. 충돌 시 하나의 bucket에 여러 데이터 저장하기 체이닝 기법 연결리스트를 활용하여 동일한 키를 가지는 인덱스들을 연결하여 저장한다. 연결리스트를 사용하기 때문에 삽입 삭제가 용이하다. 테이블 크기는 동적 메모리할당을 통해 해결이 가능하지만 추가적인 메모리 공간이 요구된다.","link":"/08/05/20210805-hash/"},{"title":"프림 알고리즘","text":"프림 알고리즘 (Prim’s Algorithm)개요프림 알고리즘 가중치가 있는 연결된 무향 그래프의 모든 꼭짓점을 포함하면서 각 변의 비용의 합이 최소가 되는 부분 그래프인 트리, 즉 최소 신장트리 를 찾는 알고리즘이다최소 신장트리 (Minimum Spanning Tree, MST) 신장 트리 중에서 간선의 가중치 합이 가장 작은 트리 신장트리 특정한 그래프에서 모든 정점을 포함하는 그래프 프림 알고리즘 처음에 트리는 비어있다고 가정한다. 그래프에서 정점 하나를 선택하여 트리에 포함시킨다. 1에서 포함된 정점과 인접한 노드의 간선 중에서 가중치가 가장 작은 간선을 찾아 포함시킨다. 2번을 모든 노드가 포함될 때까지 반복한다. 동작 과정 이미지 삽입 예정 구현 모든 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#define NODE_MAX 1001#define EDGE_MAX 200001 // 양방향 간선이므로 100,000개// 구조체 정의typedef struct {int cost;int node;} Edge;// 데이터 위치 변환을 위한 함수 구현void swap(Edge *a, Edge *b) {Edge temp;temp.cost = a-&gt;cost;temp.node = a-&gt;node;a-&gt;cost = b-&gt;cost;a-&gt;node = b-&gt;node;b-&gt;cost = temp.cost;b-&gt;node = temp.node;}// 우선순위 큐 정의typedef struct {Edge *heap[EDGE_MAX];int count;} priorityQueue;// 데이터 삽입 함수void push(priorityQueue *pq, Edge *edge) { if (pq-&gt;count &gt;= EDGE_MAX) return; pq-&gt;heap[pq-&gt;count] = edge; int now = pq-&gt;count; int parent = (pq-&gt;count - 1) / 2; // 새 원소를 삽입한 이후에 상향식으로 힙을 구성한다. while (now &gt; 0 &amp;&amp; pq-&gt;heap[now]-&gt;cost &lt; pq-&gt;heap[parent]-&gt;cost) { swap(pq-&gt;heap[now], pq-&gt;heap[parent]); now = parent; parent = (parent - 1) / 2; } pq-&gt;count++;}// 데이터 추출함수 구현Edge* pop(priorityQueue *pq) {if (pq-&gt;count &lt;= 0) return NULL;Edge *res = pq-&gt;heap[0];pq-&gt;count--;pq-&gt;heap[0] = pq-&gt;heap[pq-&gt;count];int now = 0, leftChild = 1, rightChild = 2;int target = now;// 새 원소를 추출한 이후에 하향식으로 힙을 구성합니다.while (leftChild &lt; pq-&gt;count) { if (pq-&gt;heap[target]-&gt;cost &gt; pq-&gt;heap[leftChild]-&gt;cost) target = leftChild; if (pq-&gt;heap[target]-&gt;cost &gt; pq-&gt;heap[rightChild]-&gt;cost &amp;&amp; rightChild &lt; pq-&gt;count) target = rightChild; if (target == now) break; // 더 이상 내려가지 않아도 될 때 종료 else { swap(pq-&gt;heap[now], pq-&gt;heap[target]); now = target; leftChild = now * 2 + 1; rightChild = now * 2 + 2; } } return res;}// 데이터 연결리스트 구현typedef struct Node {Edge *data;struct Node *next;} Node;Node** adj;int d[NODE_MAX];// 노드 추가를 위한 함수void addNode(Node** target, int index, Edge* edge) { if (target[index] == NULL) { target[index] = (Node*)malloc(sizeof(Node)); target[index]-&gt;data = edge; target[index]-&gt;next = NULL; } else { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = edge; node-&gt;next = target[index]; target[index] = node; }}// 알고리즘 실행int main(void) { int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); // 큐 초기화 adj = (Node**)malloc(sizeof(Node*) * (n + 1)); for (int i = 1; i &lt;= n; i++) { adj[i] = NULL;}priorityQueue *pq;pq = (priorityQueue*)malloc(sizeof(priorityQueue));pq-&gt;count = 0;for (int i = 0; i &lt; m; i++) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); Edge *edge1 = (Edge*)malloc(sizeof(Edge)); edge1-&gt;node = b; edge1-&gt;cost = c; addNode(adj, a, edge1); Edge *edge2 = (Edge*)malloc(sizeof(Edge)); edge2-&gt;node = a; edge2-&gt;cost = c; addNode(adj, b, edge2);}","link":"/08/05/20210805-prims/"},{"title":"퀵 정렬","text":"퀵 정렬 (Quick Sort)특징 C++ Algorithm 라이브러리에서 sort()를 통해 사용할 수 있다. 피벗을 기준으로 큰 값, 작은 값을 교체한다. 완전 이진 트리와 흡사한 형태를 가진다. 퀵정렬을 통한 오름차순 구현순서 피벗 : 가장 왼쪽에 위치한 값이라 가정 start : 피벗 다음에 위치한 값 end : 가장 오른쪽에 위치한 값 start : 앞에서부터 뒤로 이동하며 피벗보다 큰 값을 찾음 end : 뒤에서 앞으로 이동하며 피벗보다 작은 값을 찾음 start와 end가 엇갈리는 시점에서 작은 값과 피벗을 교체함 피벗을 기준으로 왼쪽, 오른쪽에서 다시 퀵정렬을 수행한다.","link":"/08/04/20210804-til4/"},{"title":"우선순위 큐","text":"우선순위 큐 (Priority Queue)특징 우선 순위를 가진 데이터를 저장하는 큐 데이터 추출 시 우선순위가 높은 데이터가 추출된다. OS의 스케줄링, 정렬, 네트워크 관리 등에 이용된다. 비교큐 (Queue) 선형구조 및 FIFO 구조를 가진다. 우선순위 큐 (Priority Queue) 트리 구조와 유사하며, 최대 힙으로 구현한다. 최대힙 구조 힙은 항상 완전 이진 트리 구조여야 한다. 부모 노드가 항상 자식노드보다 큰 값을 가진 구조 root가 최대 값을 가진다. 데이터 삽입 전체 트리가 최대힙 구조를 유지하도록 코딩할 수 있다. 삽입하는 원소는 완전 이진 트리를 유지하는 형태로 삽입한다. 삽입 후에 자식 노드보다 크고, 부모 노드보다 작을 때 까지 상향식 이동을 한다. 데이터 삭제 데이터를 삭제할 때는 root를 삭제해준다. 마지막에 위치하던 노드를 root로 이동시킨다. 삭제 후에 부모 노드보다 작고, 자식 노드보다 클 때 까지 하향식으로 이동한다.","link":"/08/05/20210805-priorityQueue/"},{"title":"탐색","text":"탐색 (Search)종류순차 탐색 (Sequential Search) 특정한 원소를 찾기위해 순차적으로 탐색을 수행한다. 이진 탐색 (Binary Search) 배열의 내부 데이터가 이미 정렬되어 있는 상황에서 사용한다. 탐색 범위를 절반씩 좁혀가며 탐색을 수행한다.구성 start (가장 앞에 위치한 원소) mid (중간에 위치한 원소) end (가장 뒤에 위치한 원소)","link":"/08/05/20210805-search/"},{"title":"자바란 ?","text":"자바 (Java)특징 C, C++에 비해 안정적이다. 객체 지향적 언어로 객체 간의 협력을 할 수 있다. 플랫폼에 영향을 받지 않는다. Java의 소스코드를 컴파일러가 바이트 코드로 변환하여 JVM에서 플랫폼에 맞게 다시 변환하고 실행한다. 웹 서버, 안드로이드, 게임 프로그래밍에 사용된다. Convention Class 선언 : Class는 대문자로 시작한다. Hot key Ctrl + D : 삭제 Ctrl + F11 : Run 자료형정수 byte (1byte) 1바이트 단위인 음악 동영상, 실행파일 등의 자료처리를 할 때 사용된다. short (2byte) C/C++과 호환 시 사용된다. int (4byte) 자바에서 정수의 기본형으로 사용된다. 프로그램에서 사용하는 모든 숫자(리터럴)는 int로 표현된다. long (8byte) int의 범위를 넘어선 -2의 63승 ~ 2의 63승 -1까지 표현 숫자의 뒤에 L 또는 l을 사용하여 long자료형임을 표시한다. 실수 float (4byte) double (8byte) 자바에서 실수의 기본형으로 사용된다.표현 실수는 가수, 밑수, 지수로 나뉘어 부동 소수점 방식으로 값이 표현된다. 컴퓨터에서는 밑수를 2로 사용한다.정규화 가수가 밑수보다 작은 한자리까지 가수로 표현 되는 것 예시 : 컴퓨터에서는 밑수가 2로 표현되므로, 정규화를 수행하면 가수부분의 첫 번째 자리 숫자는 항상 1로 표현된다.오류 부동 소수점 방식으로는 지수가 0을 표현할 수 없기 때문에 약간의 오차가 발생할 수 있다. 문자 컴퓨터에서는 문자를 표현하기 위해 문자세트(Charset)를 사용한다. 문자세트 : 각 문자를 어떠한 숫자로 표현할 것인지 코드표로 나타낸 세트 종류 : ASKII, euc-kr, uft-8, utf-16 등 자바에서는 문자를 나타내기 위해 세계 표준인 UNICODE를 사용한다. utf-16 인코딩을 사용하여 모든 문자를 2바이트로 표시한다.","link":"/08/10/20210810-java/"},{"title":"그래프","text":"그래프 (Graph) 사물을 정점(Vertex)과 간선(Edge)로 나타내는 구조 종류 E : Edge (간선)V : Vertex (정점) 무방향 비가중치 그래프 모든 노드의 연결여부를 확인하여야한다. 2차원 Matrix를 이용하여 확인하므로 O(V^2)이 소요되고, 값은 바로 확인할 수 있기 때문에 O(1)이 소요된다.인접 행렬(Adjacency Matrix)을 이용한 구현 방향 가중치 그래프 모든 간선이 방향을 가지고, 가중치를 가진 그래프 연결된 간선의 정보만 저장하기 때문에 공간은 O(E)가 소요되고, 노드만 확인하여 값을 확인하므로 O(V)가 소요된다.인접 리스트(Adjacency List)를 이용한 구현","link":"/08/05/20210805-graph/"},{"title":"다운캐스팅(DownCasting)","text":"다운캐스팅 (DownCasting)의미 업캐스팅된 클래스를 원래의 타입으로 다시 형변환하는 것 하위 클래스로의 형변환(다운캐스팅)은 명시적으로 해야한다. 클래스B가 클래스A에게 상속받는 경우12A instance = new B(); // 묵시적B instanceB = (B)instance; //명시적 유의 사항 클래스 B와 C가 클래스 A에게 상속 받는 경우1234567// A의 타입으로 B, C의 인스턴스를 생성해준다.A ins1 = new B();A ins2 = new C();// C타입을 B타입인 ins3로 생성을 시도한다.// 실행전까지는 에러가 나지 않지만 실행 시 에러가 발생한다.B ins3 = (B)ins2; 아래와 같은 방어 코드로 에러를 방지할 수 있다. instanceof : in2가 B클래스로 생성된 인스턴스인지 확인한다123if ( in2 instanceof B ){B ins3 = (B)ins2;}","link":"/08/12/20210812-DownCasting/"},{"title":"추상 클래스 (Abstract Class)","text":"추상 클래스 (Abstract Class)의미 구현 코드없이 메서드의 선언만 있는 추상 메서드를 포함한 클래스 메서드를 생성할 때 반환값, 메서드 이름, 매개변수로 구성되어있다. 구현은 상속받은 자식 클래스가 한다. 추상 클래스는 인스턴스화(new 로 생성) 할 수 없다. 기능이 완벽하지 않기 때문 일반 클래스도 abstract 라고 명시하면 이를 생성할 수 없다. 자식클래스에서 추상 메서드 중 하나라도 구현하지 않으면 자식클래스도 추상클래스가 된다. 구체적(Concrete)과 반대되는 말로, 구현부를 작성하지 않은 클래스라고 생각할 수 있다. 추상 클래스를 생성하는 것은 선언이라고 한다. 어떤 기능을 할지 구현부를 작성하면 메서드를 정의한다고 한다. 다이어그램으로 나타낼 때 추상 메서드와 클래스는 Italic체로 작성한다.1234int add(int a, intb); //선언 (추상 메서드)int add(int a, intb){ //정의 구현할 기능ㅔ}","link":"/08/12/20210812-Abstract/"},{"title":"상속(Inheritance)","text":"Java 상속, 형변환, 재정의상속 구현되어 있는 기능, 속성을 확장하여 재사용하는 것 class B extends A{ } extends 뒤에는 하나의 클래스만 올 수 있다. 자바는 안정성을 위해 단일 상속만을 지원한다. 상속 하는 클래스 : 상위 클래스, parent class, child class 상속 받는 클래스 : 하위, child, sub 상속을 사용하는 경우 객체 지향 프로그래밍에서는 크게 2가지 방법을 사용할 수 있다. IS-A 관계 (is a relationship : inheritance), HAS-A관계(composition) IS-A관계에서 상속을 사용한다. IS-A 관계 예시 : 포유류 - 인간, 호랑이, 사자 등 일반적인 개념과 구체적인 개념의 관계 뼈대를 구축하고 이를 확장해서 사용할 때 자주 사용된다. 상속은 클래스간의 결합도가 높은 설계이다. 계층구조가 복잡하거나 hiearchy가 높으면 좋지 않다. HAS-A 관계 예시 : Java의 ArrayList 클래스를 사용하는 경우 클래스가 다른 클래스를 포함하는 관계 (변수로 선언) 코드 재사용의 가장 일반적인 방법 상속을 구현하는 경우 일반적인 클래스로부터 보다 구체적인 클래스를 생성하고 싶을 때 사용한다. 직업 (일반 클래스) - 개발자 (구체적인 클래스) 하위 클래스가 생성되는 과정 extends로 하위클래스를 생성하면 상위 클래스가 먼저 생성된다. 하위 클래스의 생성자가 상위 클래스의 생성자를 호출하게 된다. 컴파일러가 하위 클래스의 생성자 내에 super()를 자동으로 입력하여 default 생성자를 호출한다. 생성자에 매개 변수가 존재할 경우, super(매개변수)를 이용하여 명시적으로 호출해주어야 한다. 형변환 상위 클래스로 변수를 생성하고 하위 클래스의 생성자로 인스턴스를 생성 상위 클래스 타입의 변수에 하위 클래스의 변수가 대입 (업 캐스팅) 메서드의 인자에 하위 클래스 타입을 넣어도 상위 클래스 타입으로 형변환이 가능하다. 하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 묵시적 형변환이 가능하다. 12345class B extends A {}A instanceA = new B();method(instanceB);type method(A instanceA){} 하위 클래스로 생성이 되었지만 type이 상위 클래스의 type이므로 하위 클래스에서 생성한 method 등에는 접근할 수 없다. 재정의 (Overriding) 상위 클래스에서 정의한 method를 하위 클래스에서 재정의하고 싶을 때 사용 메서드 정의 부분 (Function Signiture)은 동일하게 입력해야한다. 다르게 입력할 시 새로운 method를 정의하는 것처럼 해석된다. 사용법 @Override 를 Annotation으로 입력해준다. Annotation (주석) 컴파일러에게 특별한 정보를 제공해주는 역할을 한다. Override 재정의된 메서드라는 정보 제공 FuctionalInterface 함수형 인터페이스라는 정보 제공 Deprecated 이후 버전에서 사용되지 않을 수 있는 변수 메서드에서 사용된다. SuppressWarnings(“~”) 특정 경고가 나타나지 않도록함","link":"/08/12/20210812-Inheritance/"},{"title":"자바 기초","text":"자바 기초객체 지향 프로그래밍 (OOP; Object Oriented Programming) Java는 객체 지향 프로그래밍 언어 중 하나이다. 객체 : 구체적, 추상적 데이터의 단위 (사람, 사물, 주문 등) 객체 지향 프로그래밍 언어는 협력을 통해 기능을 수행할 수 있다. 클래스로 객체를 정의한다. 객체의 속성을 클래스 내부의 멤버 변수로 넣는다. 역할과 책임 등을 기능으로 구현한다. 클래스 간의 협력을 통해 실행한다. 함수 (Function) 함수는 기능을 수행하는 단독 모듈이다. 함수를 호출하여 수행하고 반환할 수 있다. 기본형 &lt;접근 제어자&gt; &lt;static | final&gt; &lt;반환형&gt; &lt;함수명&gt; 접근 제어자 (Access Modifier) 어떠한 범위 내에서 함수, 클래스에 대해 접근을 통제할 것인지 정의합니다. public : 어디서든 접근 가능 private : 동일한 클래스 내에서만 접근 가능 public으로 구현된 메서드를 통해 접근이 가능하다. protected : 동일한 패키지 내, 이를 상속받은 자식 클래스 내에서 접근 가능 default : 같은 패키지 내에서 접근 가능 접근제어자를 입력하지 않았을 때 default가 적용된다. Static | Final static 이 메서드를 공용으로 사용할 것인지 아닌지를 결정한다. static을 삽입하면 공용으로 사용할 수 있다. static으로 지정하면 static메모리 공간에 저장되어 프로그램의 시작부터 종료 시 까지 저장된다. Final 상속, 제정의, 변경이 불가한 상태로 지정한다. 상수를 정의할 때도 사용된다. 반환형 (Return Type) 반환형에는 자료형을 삽입할 수 있다. 생성한 class를 반환형으로 사용할 수도 있다. 메서드 (Method) 클래스 안에서 멤버변수를 이용하여 수행한다. 메서드는 사용하는 객체에 맞게 작명하는 것이 중요하다. 생성자 (Constructor) 객체를 사용할 때 항상 생성자를 통해 생성한 후에 사용한다. 생성하면 heap메모리에 인스턴스가 생성된다. 생성자를 별도로 구현하지 않아도, default constructor가 생성된다. 기본 문법 &lt;ClassName&gt;([Argument]) { [Statements] } 생성자는 오버로딩이 가능하여, 1개 이상 존재할 수 있다. 오버로딩 (Overloading) 사용자의 편의성을 위해 주로 사용된다. 예시: 회원 가입 시 필수 질문만 작성할 수 있고, 추가 정보를 작성하여 가입할 수도 있다.","link":"/08/12/20210812-java2/"},{"title":"다형성(Polymorphism)","text":"다형성 하나의 코드가 여러 자료형으로 구현되어 실행 되는 것 같은 코드에서 여러가지 실행 결과가 나오는 것 유연하고 확장성있고, 유지보수가 편리함 프로그램을 만들 수 있다. 개념 하위 클래스들을 상위 클래스로 형변환한다. 이를 한번에 핸들링한다. 각 인스턴스별로 다른 실행 결과를 얻을 수 있다. 결합도가 높아진다. 예시 모든 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package polymorphismTest;import java.util.ArrayList;class Animal{ // 공통된 기능을 정의 할 때 상위 클래스인 Animal에 기능을 입력한다. public void move() { System.out.println(&quot;동물이 움직입니다.&quot;); } }class Human extends Animal { @Override public void move() { System.out.println(&quot;사람이 두 발로 걷습니다.&quot;); } public void readBook() { System.out.println(&quot;사람이 책을 읽습니다.&quot;); }}class Tiger extends Animal { @Override public void move() { System.out.println(&quot;호랑이가 네 발로 뜁니다.&quot;); } public void hunting() { System.out.println(&quot;호랑이가 사냥을 합니다.&quot;); }}class Eagle extends Animal { @Override public void move() { System.out.println(&quot;독수리가 하늘을 납니다.&quot;); } public void flying() { System.out.println(&quot;독수리가 양날개를 쭉 펴고 날아다닙니다.&quot;); }}public class AnimalTest { public static void main (String[] args) { // 형변환 (업캐스팅 : 상위 클래스의 타입으로 변환) Animal hAnimal = new Human(); Animal tAnimal = new Tiger(); Animal eAnimal = new Eagle(); AnimalTest test = new AnimalTest(); // 상위 클래스인 Animal로 형변환이 가능하다. // 각자의 가상 메서드 테이블을 갖게 된다. test.moveAnimal(hAnimal); test.moveAnimal(tAnimal); test.moveAnimal(eAnimal); // 세 동물을 ArrayList에 삽입하고 싶을 때 ArrayList&lt;Animal&gt; animalList = new ArrayList&lt;&gt;(); animalList.add(hAnimal); animalList.add(tAnimal); animalList.add(eAnimal); // enhanced for문을 통한 출력 for (Animal a : animalList) { a.move(); } } public void moveAnimal(Animal animal) { animal.move(); }} 사용하는 이유 상속과 메서드의 재정의를 활용하여 확장성 있는 프로그램을 만들 수 있다. 위 예시로 보았을 때 동물을 추가하고 싶을 때 편하게 추가할 수 있다. 상위 클래스에 공통된 기능과 하위 클래스에 특정한 기능을 구분하여 코딩할 수 있다.","link":"/08/12/20210812-Polymorphism/"},{"title":"가상메서드(VirtualMethod)","text":"가상 메서드메서드 (Method) 명령어의 집합 (set) Java에서 모든 메서드는 가상 메서드이다. 메서드의 이름은 주소값을 나타낸다. 메서드를 호출하면 이름과 mapping되어 있는 주소값이 호출된다.함수 호출 방식 프로그램이 로드되면 메서드 영역(코드 영역)에 명령어 set이 위치한다. 메서드가 호출되면 명령어 set이 위치한 주소를 찾아가 명령어가 실행된다. 이 때 메서드에 위치한 변수들은 stack메모리에 위치하게 된다. 서로 다른 인스턴스가 동일한 메서드를 호출하면 같은 method가 호출된다.인스턴스가 생성되면 변수는 heap메모리에 저장이 되지만, 메서드 명령어 set은 한 번만 로드된다. 가상 메서드 (Virtual Method) 클래스마다 가상 메서드 테이블(Virtual Method Table)에 메서드의 address를 가지고 있다. 메서드가 재정의되면 재정의된 클래스의 테이블에 address가 추가된다.","link":"/08/12/20210812-VirtualMethod/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"Custom Exception","slug":"Custom-Exception","link":"/tags/Custom-Exception/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"자바","slug":"자바","link":"/tags/%EC%9E%90%EB%B0%94/"},{"name":"배열","slug":"배열","link":"/tags/%EB%B0%B0%EC%97%B4/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"람다식","slug":"람다식","link":"/tags/%EB%9E%8C%EB%8B%A4%EC%8B%9D/"},{"name":"Class 클래스","slug":"Class-클래스","link":"/tags/Class-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Inner Class","slug":"Inner-Class","link":"/tags/Inner-Class/"},{"name":"내부 클래스","slug":"내부-클래스","link":"/tags/%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Basic","slug":"Basic","link":"/tags/Basic/"},{"name":"클래스 프레임워크","slug":"클래스-프레임워크","link":"/tags/%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"Class Framework","slug":"Class-Framework","link":"/tags/Class-Framework/"},{"name":"reduce","slug":"reduce","link":"/tags/reduce/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"트리","slug":"트리","link":"/tags/%ED%8A%B8%EB%A6%AC/"},{"name":"이진트리","slug":"이진트리","link":"/tags/%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"name":"리스트","slug":"리스트","link":"/tags/%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"Stream","slug":"Stream","link":"/tags/Stream/"},{"name":"계수정렬","slug":"계수정렬","link":"/tags/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/"},{"name":"AVL트리","slug":"AVL트리","link":"/tags/AVL%ED%8A%B8%EB%A6%AC/"},{"name":"이진 탐색 트리","slug":"이진-탐색-트리","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC/"},{"name":"이진 트리","slug":"이진-트리","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC/"},{"name":"큐","slug":"큐","link":"/tags/%ED%81%90/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"깊이 우선 탐색","slug":"깊이-우선-탐색","link":"/tags/%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"너비 우선 탐색","slug":"너비-우선-탐색","link":"/tags/%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"},{"name":"해시","slug":"해시","link":"/tags/%ED%95%B4%EC%8B%9C/"},{"name":"프림 알고리즘","slug":"프림-알고리즘","link":"/tags/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Prim&#39;s Algorithm","slug":"Prim-s-Algorithm","link":"/tags/Prim-s-Algorithm/"},{"name":"퀵정렬","slug":"퀵정렬","link":"/tags/%ED%80%B5%EC%A0%95%EB%A0%AC/"},{"name":"우선순위","slug":"우선순위","link":"/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84/"},{"name":"순차 탐색","slug":"순차-탐색","link":"/tags/%EC%88%9C%EC%B0%A8-%ED%83%90%EC%83%89/"},{"name":"이진 탐색","slug":"이진-탐색","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89/"},{"name":"그래프","slug":"그래프","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"},{"name":"다운캐스팅","slug":"다운캐스팅","link":"/tags/%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85/"},{"name":"DownCasting","slug":"DownCasting","link":"/tags/DownCasting/"},{"name":"추상 클래스","slug":"추상-클래스","link":"/tags/%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"AbstractClass","slug":"AbstractClass","link":"/tags/AbstractClass/"},{"name":"상속","slug":"상속","link":"/tags/%EC%83%81%EC%86%8D/"},{"name":"Inheritance","slug":"Inheritance","link":"/tags/Inheritance/"},{"name":"자바 기초","slug":"자바-기초","link":"/tags/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88/"},{"name":"다형성","slug":"다형성","link":"/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"PolyMorphism","slug":"PolyMorphism","link":"/tags/PolyMorphism/"},{"name":"가상메서드","slug":"가상메서드","link":"/tags/%EA%B0%80%EC%83%81%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"VirtualMethod","slug":"VirtualMethod","link":"/tags/VirtualMethod/"}],"categories":[{"name":"Basic","slug":"Basic","link":"/categories/Basic/"},{"name":"Java","slug":"Basic/Java","link":"/categories/Basic/Java/"},{"name":"자료구조","slug":"자료구조","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"}]}