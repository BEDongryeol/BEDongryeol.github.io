{"pages":[],"posts":[{"title":"이진 트리","text":"이진트리 (Binary Tree)특징 일반적인 트리는 한 개의 노드가 여러 개의 자식 노드를 가질 수 있다. 이진 트리는 노드 1개 당 최대 2개의 자식 노드를 가질 수 있다. 종류포화 이진트리 (Full Binary Tree) 리프 노드(최하단 노드)를 제외한 모든 노드가 2개의 자식 노드를 가진 구조. 완전 이진트리 (Complete Binary Tree) 왼쪽 노드부터 점진적으로 채워진 구조 높이 균형 트리 (Height Balanced Tree) 왼쪽, 오른쪽 트리의 높이의 차이가 1이하인 트리 구현순회 전, 중, 후를 root의 순서로 보면 이해하기 쉽다. 전위순회 (Preorder) 순서 : root -&gt; 왼쪽 노드-&gt; 오른쪽 노드 중위순회 (Inorder) 순서 : 왼쪽 노드 -&gt; root -&gt; 오른쪽 노드 후위순회 (Postorder) 순서 : 왼쪽 노드 -&gt; 오른쪽 노드 -&gt; root","link":"/2021/08/04/BinaryTree/"},{"title":"큐","text":"큐 (Queue)특징 데이터가 뒤(rear)로 들어가서 앞(front)으로 나오는 자료 FIFO (First In First Out) 스케줄링, 탐색 알고리즘 등에서 사용된다. 구현배열로 구현선언 배열은 사전에 배열의 크기를 지정해줘야한다. front와 rear를 선언해준다. 1234567#include &lt;stdio.h&gt;#define SIZE 10000#define INF 99999999int queue[SIZE];int front = 0;int rear = 0; 삽입 큐는 한 쪽으로만 데이터가 들어간다. 큐의 마지막인 rear에 1을 추가하여 데이터를 삽입해준다. 배열의 크기를 초과했을 때는 큐 오버플로우를 선언해준다. 1234567void push(int data) { if (rear &gt;= SIZE) { printf(&quot;큐 오버플로우가 발생했습니다. \\n&quot;); return; } queue[rear++] = data;} 삭제 큐는 삽입과 같이 한 쪽에서만 데이터가 나온다. 큐의 front++를 return함으로써 front를 제거한다. 큐가 비어있을 때 시도하면 언더플로우를 선언한다. 1234567void pop() { if (front == rear) { printf(&quot;큐 언더플로우가 발생했습니다. \\n&quot;); return -INF; } return queue[front++];} 모든 코드 확인하기 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#define SIZE 10000#define INF 99999999int queue[SIZE];int front = 0;int rear = 0;void push(int data) { if (rear &gt;= SIZE) { printf(&quot;큐 오버플로우가 발생했습니다. \\n&quot;); return; } queue[rear++] = data;}void pop() { if (front == rear) { printf(&quot;큐 언더플로우가 발생했습니다. \\n&quot;); return -INF; } return queue[front++];}void show() { printf(&quot;---큐의 앞--- \\n&quot;); for (int i = front; i &lt; rear; i++) { printf(&quot;%d\\n&quot;, queue[i]); } printf(&quot;---큐의 뒤--- \\n&quot;);}int main(void) { push(7); push(5); push(1); pop(); show(); system(&quot;pause&quot;); return 0;} 연결리스트로 구현선언 data와 노드와 다음 데이터를 연결하는 next를 구조에 포함한다. 데이터가 나오는 front, 들어가는 node, 데이터 수를 담을 count를 선언한다. 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INF 99999999typedef struct { int data; struct Node* next;}Node;typedef struct { Node* front; Node* rear; int count;}Queue; 삽입 새로운 node를 동적메모리에 할당해준다. node에 데이터를 담고, next는 NULL로 초기화해준다. 조건문을 통해 큐에 데이터가 없을 시 front로 선언한다. 데이터가 존재할 시 큐의 rear가 node를 가리키게 한다. 큐의 rear를 node로 지정하고, count를 추가해준다. 12345678910111213void push(Queue* queue, int data) { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; node-&gt;next = NULL; if (queue-&gt;count == 0) { queue-&gt;front = node; } else { queue-&gt;rear-&gt;next = node; } queue-&gt;rear = node; queue-&gt;count++;} 삭제 큐에 데이터가 없을 시 실행하면 언더플로우를 선언해준다. 큐의 front를 담을 노드를 생성하고, 데이터도 담아준다. 큐의 front를 위 노드의 next로 선언한다. 기존의 front 다음의 데이터가 front가 되는 것 원래의 front를 담고 있던 node를 해제해주고, count를 감소시킨다. 12345678910111213void pop(Queue* queue) { if (queue-&gt;count == 0) { printf(&quot;큐 언더플로우가 발생하였습니다. \\n&quot;); return -INF; } Node* node = queue-&gt;front; int data = node-&gt;data; queue-&gt;front = node-&gt;next; free(node); queue-&gt;count--; return data;} 모든 코드 확인하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INF 99999999typedef struct { int data; struct Node* next;}Node;typedef struct { Node* front; Node* rear; int count;}Queue;void push(Queue* queue, int data) { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; node-&gt;next = NULL; if (queue-&gt;count == 0) { queue-&gt;front = node; } else { queue-&gt;rear-&gt;next = node; } queue-&gt;rear = node; queue-&gt;count++;}void pop(Queue* queue) { if (queue-&gt;count == 0) { printf(&quot;큐 언더플로우가 발생하였습니다. \\n&quot;); return -INF; } Node* node = queue-&gt;front; int data = node-&gt;data; queue-&gt;front = node-&gt;next; free(node); queue-&gt;count--; return data;}void show(Queue* queue) { Node* cur = queue-&gt;front; printf(&quot;---큐의 앞---\\n&quot;); while (cur != NULL) { printf(&quot;%d\\n&quot;, cur-&gt;data); cur = cur-&gt;next; } printf(&quot;---큐의 뒤---&quot;);}int main(void) { Queue queue; queue.front = queue.rear = NULL; queue.count = 0; push(&amp;queue, 7); push(&amp;queue, 5); push(&amp;queue, 4); pop(&amp;queue); push(&amp;queue, 6); pop(&amp;queue); show(&amp;queue); system(&quot;pause&quot;); return 0;}","link":"/2021/08/03/til2-md/"},{"title":"선택 및 삽입 정렬","text":"선택 정렬 (Selection Sort)특징 가장 작은 것을 선택해서 앞으로 보냄 시간복잡도 : 가장 작은 데이터 선택 (N) * 앞으로 보내기 (N) = O(N^2) 삽입 정렬특징 각 숫자를 적절한 위치에 삽입 일반적으로 선택 정렬보다 빠르게 동작한다. 시간복잡도 : 들어갈 위치를 선택 (N) * 데이터를 선택하는 횟수 (N) = O(N^2)","link":"/2021/08/04/til3/"},{"title":"계수 및 기수 정렬","text":"계수 정렬 (Counting Sort)특징 데이터의 크기가 한정적일 때 사용한다. 데이터를 읽어나가면서 바로 정렬한다 시간복잡도 : O(N) 기수 정렬 (Radix Sort)특징 자리 수를 기준으로 차례대로 데이터를 정렬한다. 자리 수는 가장 큰 값의 자리수를 기준으로 한다. 예시 ) 가장 큰 값 : 345 (1, 10, 100의 자리)","link":"/2021/08/04/til5/"},{"title":"퀵 정렬","text":"퀵 정렬 (Quick Sort)특징 C++ Algorithm 라이브러리에서 sort()를 통해 사용할 수 있다. 피벗을 기준으로 큰 값, 작은 값을 교체한다. 완전 이진 트리와 흡사한 형태를 가진다. 퀵정렬을 통한 오름차순 구현순서 피벗 : 가장 왼쪽에 위치한 값이라 가정 start : 피벗 다음에 위치한 값 end : 가장 오른쪽에 위치한 값 start : 앞에서부터 뒤로 이동하며 피벗보다 큰 값을 찾음 end : 뒤에서 앞으로 이동하며 피벗보다 작은 값을 찾음 start와 end가 엇갈리는 시점에서 작은 값과 피벗을 교체함 피벗을 기준으로 왼쪽, 오른쪽에서 다시 퀵정렬을 수행한다.","link":"/2021/08/04/til4/"},{"title":"이진 탐색 트리","text":"이진 탐색 트리 (Binary Search Tree)특징 이진 탐색 트리에서 부모 노드는 왼쪽 자식 노드보다는 크고 오른쪽 자식 노드보다는 작다 값의 크기 비교 : 왼쪽 자식 노드 &lt; 부모 노드 &lt; 오른쪽 자식 노드 탐색 속도를 극대화할 수 있는 구조이다. 한 번 확인할 때 마다 탐색할 노드의 개수가 절반씩 줄어든다. 완전 이진 탐색 트리에서 실행할 경우 O(logN)의 시간복잡도를 가진다. 탐색 트리 내의 데이터를 탐색한다. 탐색하고 싶은 노드를 부모 노드와 비교한다. 부모 노드보다 클 경우 오른쪽 자식 노드에 포함되므로 오른쪽으로 이동한다. 부모 노드보다 작을 경우 왼쪽 자식 노드에 포함되므로 왼쪽으로 이동한다. 삽입 삽입하고 싶은 데이터를 부모 노드와 비교하여 탐색 프로세스와 같이 이동하며 적절한 위치에 값을 삽입한다. 삭제 자식 노드가 없는 노드의 삭제 데이터를 탐색하여 삭제한다. 1개의 자식 노드가 있는 노드의 삭제 삭제할 노드의 자리에 자식 노드를 삽입한다. 2개의 자식 노드가 있는 노드의 삭제 삭제할 노드 다음으로 큰 노드를 삭제할 노드의 위치에 삽입한다.","link":"/2021/08/05/BinarySearchTree/"},{"title":"AVL트리","text":"AVL 트리특징 ‘AVL 트리’는 균형이 갖춰진 이진 트리이다. 균형을 갖추기 위해 회전(Rotation)을 통해 재구성할 수 있다. 균형 균형 인수가 -1, 0, +1 인 상태 균형 인수 왼쪽 자식의 높이 - 오른쪽 자식의 높이 불균형 상태LL 형식 노드가 Left1-Left2로 편향되어 있는 상태재구성 결과적으로 편향된 노드들을 가진 노드(2)를 root가 된다. 노드(2)가 가지고있던 오른쪽 자식 노드들을 root(1)의 왼쪽 자식 노드로 설정한다. 기존의 root(1)는 노드(2)의 오른쪽 자식 노드로 설정한다. RR 형식 노드가 Right1-Right2로 편향되어 있는 상태재구성 LL형식의 재구성 방식을 반대로 수행한다. 편향된 노드의 왼쪽 자식 노드를 root의 오른쪽 노드로 설정한다. 편향된 노드의 왼쪽 자식 노드를 root로 설정한다. LR 형식 노드가 Left1-Right1로 편향되어 있는 상태 편향된 노드에 RR회전을 수행하여 불균형 노드를 왼쪽으로 몰아 넣는다. 몰아넣은 노드에 LL회전을 수행한다. RL 형식 노드가 Right1-Left1로 편향되어 있는 상태 편향된 노드에 LL회전을 수행하여 불균형 노드를 오른쪽으로 몰아 넣는다. 몰아넣은 노드에 RR회전을 수행한다.","link":"/2021/08/05/AVLtree/"},{"title":"그래프","text":"그래프 (Graph) 사물을 정점(Vertex)과 간선(Edge)로 나타내는 구조 종류 E : Edge (간선)V : Vertex (정점) 무방향 비가중치 그래프 모든 노드의 연결여부를 확인하여야한다. 2차원 Matrix를 이용하여 확인하므로 O(V^2)이 소요되고, 값은 바로 확인할 수 있기 때문에 O(1)이 소요된다.인접 행렬(Adjacency Matrix)을 이용한 구현 방향 가중치 그래프 모든 간선이 방향을 가지고, 가중치를 가진 그래프 연결된 간선의 정보만 저장하기 때문에 공간은 O(E)가 소요되고, 노드만 확인하여 값을 확인하므로 O(V)가 소요된다.인접 리스트(Adjacency List)를 이용한 구현","link":"/2021/08/05/graph/"},{"title":"우선순위 큐","text":"우선순위 큐 (Priority Queue)특징 우선 순위를 가진 데이터를 저장하는 큐 데이터 추출 시 우선순위가 높은 데이터가 추출된다. OS의 스케줄링, 정렬, 네트워크 관리 등에 이용된다. 비교큐 (Queue) 선형구조 및 FIFO 구조를 가진다. 우선순위 큐 (Priority Queue) 트리 구조와 유사하며, 최대 힙으로 구현한다. 최대힙 구조 힙은 항상 완전 이진 트리 구조여야 한다. 부모 노드가 항상 자식노드보다 큰 값을 가진 구조 root가 최대 값을 가진다. 데이터 삽입 전체 트리가 최대힙 구조를 유지하도록 코딩할 수 있다. 삽입하는 원소는 완전 이진 트리를 유지하는 형태로 삽입한다. 삽입 후에 자식 노드보다 크고, 부모 노드보다 작을 때 까지 상향식 이동을 한다. 데이터 삭제 데이터를 삭제할 때는 root를 삭제해준다. 마지막에 위치하던 노드를 root로 이동시킨다. 삭제 후에 부모 노드보다 작고, 자식 노드보다 클 때 까지 하향식으로 이동한다.","link":"/2021/08/05/priorityQueue/"},{"title":"연결리스트","text":"연결리스트 (Linked List)특징 데이터를 선형적으로 저장 및 처리한다. 삽입과 삭제가 많은 경우 효율적이다. 리스트의 중간 지점에 노드의 추가/삭제가 가능하여야 한다. 메모리 공간을 미리 할당하는 배열을 보완하여 공간 낭비를 감소시킨다. ✚ 배열 기반의 리스트 장점 : 즉시 접근이 가능하다. 단점 : 삽입 삭제가 비효율적이며 메모리 공간을 미리 할당한다. 종류단일 연결리스트 단일 연결리스트는 가장 앞의 노드를 가르키는 HEAD를 갖는다. 각 노드별로 동적 메모리를 할당하여야 하며, 각 노드를 연결시켜주어야 한다. ####︎︎ 노드 삽입 HEAD 다음에 노드를 삽입한다고 가정 ‘HEAD의 *next’가 ‘삽입 노드의 값’을 가리키게 한다. ‘삽입 노드의 *next’가 ‘기존 노드의 값’을 가리키게 한다. 노드 삭제 HEAD 다음에 위치한 노드를 삭제한다고 가정 ‘HEAD의 *next’가 ‘삭제될 노드의 다음 값’을 가리키게 한다. 삭제된 노드의 동적 메모리를 해제하여 메모리 누수를 방지한다.","link":"/2021/07/30/til1/"},{"title":"그래프 탐색","text":"그래프 탐색깊이 우선 탐색 (Depth First Search)특징 깊은 것을 우선적으로 탐색한다. 전체 노드를 탐색하며, 모든 경우의 수를 탐색한다. 스택 자료구조에 기초하며, O(N)이 소요된다. 구현 모든 노드는 탐색되지 않은 상태임을 가정 스택에 삽입되면 탐색이 완료된 것으로 간주한다. 탐색을 시작할 노드를 스택에 삽입(탐색)한다. 시작 노드와 인접한 노드를 순차적으로 스택에 삽입(탐색)한다. 더이상 인접한 노드가 없을 때는 스택에서 순차적으로 노드를 꺼낸다. 너비 우선 탐색 (Breadth First Search)특징 너비를 우선으로 하여 탐색을 수행한다. 전체 노드를 탐색하고, DFS보다 빠르다. 큐 자료구조에 기초하며, O(N)이 소요된다. 고급 그래프 탐색 알고리즘에서 자주 활용된다. 구현 모든 노드는 탐색되지 않은 상태임을 가정 스택에 삽입되면 탐색이 완료된 것으로 간주한다. 탐색을 시작할 노드를 큐에 삽입한다. 삽입한 노드를 꺼내고, 인접 노드를 삽입한다. 2를 더이상 수행할 수 없을 때까지 반복한다.","link":"/2021/08/05/DFS/"},{"title":"해시","text":"해시 (Hash)특징 해시를 이용하면 메모리를 많이 소요하지만 최대 빠른 속도로 관리할 수 있다. DB 소프트웨어에서 많이 사용된다. 수학적 연산을 통한 키를 이용하여 값에 접근한다. 나머지를 사용하는 방법이 보편적이다. 테이블 크기를 소수로 설정하여야 충돌 확률이 낮다. 키가 중복이 생길 경우 충돌이 생긴다고 표현하는데 이를 해결하는 방법에는 2가지가 있다. 충돌 해결충돌 시 다른 위치에 저장하기 선형 조사법 키가 중복이 생기면 해당 키의 다음 인덱스에 데이터를 저장한다. 다시 중복이 생기면 인덱스+1을 해나가며 저장한다. 단점 충돌이 발생하기 시작하면 유사한 값을 가지는 데이터가 밀집되는 집중 결합 문제가 발생한다. 테이블의 크기가 매우 크면, 충돌은 적어지고, 데이터에 빠르게 접근할 수 있다. 이차 조사법 키 값이 중복되면 완전 제곱수를 더해 나가며 저장한다. 인덱스+1, 인덱스+4 … 선형 조사법 및 이차 조사법에서 데이터의 수가 테이블 인덱스를 초과하게 되면 크기를 확장하여 유지할 수 있도록 설정하여야 한다. 충돌 시 하나의 bucket에 여러 데이터 저장하기 체이닝 기법 연결리스트를 활용하여 동일한 키를 가지는 인덱스들을 연결하여 저장한다. 연결리스트를 사용하기 때문에 삽입 삭제가 용이하다. 테이블 크기는 동적 메모리할당을 통해 해결이 가능하지만 추가적인 메모리 공간이 요구된다.","link":"/2021/08/05/hash/"},{"title":"탐색","text":"탐색 (Search)종류순차 탐색 (Sequential Search) 특정한 원소를 찾기위해 순차적으로 탐색을 수행한다. 이진 탐색 (Binary Search) 배열의 내부 데이터가 이미 정렬되어 있는 상황에서 사용한다. 탐색 범위를 절반씩 좁혀가며 탐색을 수행한다.구성 start (가장 앞에 위치한 원소) mid (중간에 위치한 원소) end (가장 뒤에 위치한 원소)","link":"/2021/08/05/search/"}],"tags":[{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"트리","slug":"트리","link":"/tags/%ED%8A%B8%EB%A6%AC/"},{"name":"이진트리","slug":"이진트리","link":"/tags/%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/"},{"name":"큐","slug":"큐","link":"/tags/%ED%81%90/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"계수정렬","slug":"계수정렬","link":"/tags/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/"},{"name":"퀵정렬","slug":"퀵정렬","link":"/tags/%ED%80%B5%EC%A0%95%EB%A0%AC/"},{"name":"이진 탐색 트리","slug":"이진-탐색-트리","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC/"},{"name":"이진 트리","slug":"이진-트리","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC/"},{"name":"AVL트리","slug":"AVL트리","link":"/tags/AVL%ED%8A%B8%EB%A6%AC/"},{"name":"그래프","slug":"그래프","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"},{"name":"우선순위","slug":"우선순위","link":"/tags/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84/"},{"name":"리스트","slug":"리스트","link":"/tags/%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"깊이 우선 탐색","slug":"깊이-우선-탐색","link":"/tags/%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"너비 우선 탐색","slug":"너비-우선-탐색","link":"/tags/%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89/"},{"name":"해시","slug":"해시","link":"/tags/%ED%95%B4%EC%8B%9C/"},{"name":"순차 탐색","slug":"순차-탐색","link":"/tags/%EC%88%9C%EC%B0%A8-%ED%83%90%EC%83%89/"},{"name":"이진 탐색","slug":"이진-탐색","link":"/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89/"}],"categories":[{"name":"자료구조","slug":"자료구조","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"}]}