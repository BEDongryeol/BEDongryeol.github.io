<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>예외처리</title>
      <link href="/08/25/Exception/"/>
      <url>/08/25/Exception/</url>
      
        <content type="html"><![CDATA[<h1 id="예외처리-Exception"><a href="#예외처리-Exception" class="headerlink" title="예외처리 (Exception)"></a>예외처리 (Exception)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>Java에서 발생하는 문제는 오류(Error)와 예외(Exception)로 구분할 수 있다.</li></ul><h2 id="오류-Error"><a href="#오류-Error" class="headerlink" title="오류 (Error)"></a>오류 (Error)</h2><ul><li>시스템 오류(Error) : 가상머신에서 발생하고, 개발자가 처리할 수 없는 오류<ul><li>동적 메모리가 없는 경우, 스택 오버플로우 등</li></ul></li></ul><h3 id="컴파일-오류-Compile-Error"><a href="#컴파일-오류-Compile-Error" class="headerlink" title="컴파일 오류 (Compile Error)"></a>컴파일 오류 (Compile Error)</h3><ul><li>프로그램 코드 작성 중 발생하는 문법적인 오류</li><li>IDE에서 컴파일 오류를 detection할 수 있다.</li></ul><h3 id="실행-오류-Runtime-Error"><a href="#실행-오류-Runtime-Error" class="headerlink" title="실행 오류 (Runtime Error)"></a>실행 오류 (Runtime Error)</h3><ul><li>실행 중인 프로그램이 중단되거나 의도하지 않은 동작(bug)을 하는 오류</li></ul><h2 id="예외-Exception"><a href="#예외-Exception" class="headerlink" title="예외 (Exception)"></a>예외 (Exception)</h2><ul><li>프로그램에서 제어할 수 있는 오류</li><li>DB, Network Connection 등</li></ul><h3 id="중요성"><a href="#중요성" class="headerlink" title="중요성"></a>중요성</h3><ul><li>프로그램의 비정상적인 종료를 피할 수 있다.</li><li>log를 적절하게 남기고, 분석을 통해 원인을 파악하고 bug를 수정하여야 한다.<ul><li>상세하게 level별로 남겨야한다.</li></ul></li></ul><h3 id="예외-클래스"><a href="#예외-클래스" class="headerlink" title="예외 클래스"></a>예외 클래스</h3><blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html">https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html</a></p></blockquote><h2 id="예외-처리"><a href="#예외-처리" class="headerlink" title="예외 처리"></a>예외 처리</h2><h3 id="try-catch문"><a href="#try-catch문" class="headerlink" title="try-catch문"></a>try-catch문</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    예외가 발생할 수 있는 코드</span><br><span class="line">&#125; <span class="keyword">catch</span> (처리할 예외 타입) &#123;</span><br><span class="line">    <span class="keyword">try</span> 블록 안에서 예외가 발생했을 때 예외처리 코드</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>예제코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayindexExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;=<span class="number">5</span> ; i++)&#123;</span><br><span class="line">                System.out.println(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="try-catch-finally문"><a href="#try-catch-finally문" class="headerlink" title="try-catch-finally문"></a>try-catch-finally문</h3><ul><li>try()블럭이 수행되면 finally() 블럭은 항상 수행된다.<ul><li>return이 포함되어 있어도 수행된다.</li></ul></li></ul><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExceptionHandling</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="try-with-resource문"><a href="#try-with-resource문" class="headerlink" title="try-with-resource문"></a>try-with-resource문</h3><ul><li>java7 이후로 <code>FileInputStream</code>클래스가 <code>AutoCloseable</code> 인터페이스를 implement하여 close를 하지 않아도 자동으로 해제된다.</li><li>java9부터 리소스는 try() 외부에서 선언하고 try(var)와 같이 사용할 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.text&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>(fis)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExceptionHandling</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 자동으로 close가 된다.</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="comment">// file을 불러올 때 생길 수 있는 에러</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        <span class="comment">// file을 close할 때 생길 수 있는 에러</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="예외처리-미루기"><a href="#예외처리-미루기" class="headerlink" title="예외처리 미루기"></a>예외처리 미루기</h3><ul><li>main함수에서 throws를 하게되면 VM으로 넘어가서 abort된다.</li><li>throws를 이용하여 예외를 발생시키는 문장에서 예외를 처리하게 미룰 수 있다.</li><li><code>catch(Exception e)</code> 구문을 통하여 default 처리를 할 수 있다.<ul><li>catch 구문 중 가장 아랫줄에 작성해야 다른 exception을 개별 처리할 수 있다.</li></ul></li></ul><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsException</span> </span>&#123;</span><br><span class="line">  <span class="comment">// throws하여 메서드를 사용할 때 Exception을 처리하도록 한다.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String fileName, String className)</span> <span class="keyword">throws</span> ClassNotFoundException, FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    Class c = Class.forName(className);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThrowsException test = <span class="keyword">new</span> ThrowsException();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      test.loadClass(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;default Exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="사용자-정의-예외클래스"><a href="#사용자-정의-예외클래스" class="headerlink" title="사용자 정의 예외클래스"></a>사용자 정의 예외클래스</h3><ul><li>자바에서 제공되는 exception 외 필요한 exception을 생성할 수 있다.</li><li>기존 클래스 중 가장 유사한 클래스를 상속을 받거나, Exception 클래스를 상속받는다.</li><li>Exception을 정의하고, 필요한 순간에 어떠한 exception이 어느 순간에 불려야하는지 구현한다.<blockquote><p>throws</p><ul><li>예외를 호출하는 메서드에게 전가하는 것</li><li>메서드에서 상위 메서드로 예외를 던진다.</li></ul><p>throw</p><ul><li>exception을 실제로 던지는 것</li><li>메서드 내에서 상위 블럭으로 예외를 던진다.</li></ul></blockquote></li></ul><details><summary>Exception 정의하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassWordException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PassWordException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>사용자 정의 Exception</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassWordTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> <span class="keyword">throws</span> PassWordException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(password == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PassWordException(<span class="string">&quot;비밀번호는 null이 될 수 없습니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (password.length() &lt; <span class="number">5</span> ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PassWordException(<span class="string">&quot;비밀번호는 5자 이상이어야 합니다..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (password.matches(<span class="string">&quot;[a-zA-Z]+&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PassWordException(<span class="string">&quot;비밀번호는 숫자나 특수문자를 포함해야 합니다.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PassWordTest test = <span class="keyword">new</span> PassWordTest();</span><br><span class="line"></span><br><span class="line">        String password = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.setPassword(password);</span><br><span class="line">            System.out.println(<span class="string">&quot;오류없음1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PassWordException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        password = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.setPassword(password);</span><br><span class="line">            System.out.println(<span class="string">&quot;오류없음2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PassWordException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        password = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.setPassword(password);</span><br><span class="line">            System.out.println(<span class="string">&quot;오류없음3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PassWordException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        password = <span class="string">&quot;abcde1#&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.setPassword(password);</span><br><span class="line">            System.out.println(<span class="string">&quot;오류없음4&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PassWordException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Exception </tag>
            
            <tag> Custom Exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>스트림</title>
      <link href="/08/25/Stream/"/>
      <url>/08/25/Stream/</url>
      
        <content type="html"><![CDATA[<h1 id="스트림-Stream"><a href="#스트림-Stream" class="headerlink" title="스트림 (Stream)"></a>스트림 (Stream)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>배열, collection 자료가 모여있을 때 연산의 처리를 일관성 있게 한다.<ul><li>자료 처리에 대한 추상화가 구현되었다고 한다.</li></ul></li><li>일관성 있는 연산으로 자료의 처리를 쉽고 간단하게 한다.</li><li>한번 생성하고 사용한 스트림은 재사용 할 수 없다.<ul><li>다른 연산을 수행하기 위해서는 스트림을 다시 생성해야 한다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntArrayStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">// 모든 Array는 Arrays 클래스를 활용할 수 있다.</span></span><br><span class="line">        IntStream is = Arrays.stream(arr);</span><br><span class="line">        is.forEach(n -&gt; System.out.println(n));</span><br><span class="line">        <span class="comment">//is는 한번 소모하였으니 다시 사용할 수 없다.</span></span><br><span class="line">        <span class="comment">// 재사용하고 싶을 때 재생성</span></span><br><span class="line">        <span class="keyword">int</span> sum = Arrays.stream(arr).sum();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="연산"><a href="#연산" class="headerlink" title="연산"></a>연산</h2><ul><li>스트림의 연산은 중간 연산과 최종 연산으로 구분된다.</li><li>중간 연산은 여러 개의 연산이 적용될 수 있지만 최종 연산은 마지마게 한 번만 적용된다.</li><li><code>지연 연산</code><ul><li>최종 연산이 호출되어야 중간 연산에 대한 수행이 이루어지고 결과가 만들어진다.</li></ul></li></ul><h3 id="중간연산"><a href="#중간연산" class="headerlink" title="중간연산"></a>중간연산</h3><ul><li><code>filter()</code> : 조건에 맞는 요소를 추출</li><li><code>map()</code> : 조건에 맞는 요소를 변환</li><li><code>sorted()</code> : 정렬</li></ul><h3 id="최종연산"><a href="#최종연산" class="headerlink" title="최종연산"></a>최종연산</h3><ul><li><code>forEach()</code> : 요소를 하나씩 꺼내옴</li><li><code>count()</code> : 요소의 개수 반환</li><li><code>sum()</code> : 요소들의 합</li></ul><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; sList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sList.add(<span class="string">&quot;Thomas&quot;</span>);</span><br><span class="line">        sList.add(<span class="string">&quot;Edward&quot;</span>);</span><br><span class="line">        sList.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = sList.stream();</span><br><span class="line">        stream.forEach(s-&gt;System.out.println(s));</span><br><span class="line"></span><br><span class="line">        sList.stream().sorted().forEach(s-&gt;System.out.print(s + <span class="string">&quot;\t&quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        sList.stream().map(s-&gt;s.length()).forEach(n-&gt;System.out.print(n + <span class="string">&quot;\t&quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        sList.stream().filter(s-&gt;s.length()&gt;=<span class="number">5</span>).forEach(s-&gt;System.out.print(s + <span class="string">&quot;\t&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="comment">//Thomas</span></span><br><span class="line"><span class="comment">//Edward</span></span><br><span class="line"><span class="comment">//Jack</span></span><br><span class="line"><span class="comment">//EdwardJackThomas</span></span><br><span class="line"><span class="comment">//6 64</span></span><br><span class="line"><span class="comment">//ThomasEdward</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reduce 메서드</title>
      <link href="/08/25/reduce/"/>
      <url>/08/25/reduce/</url>
      
        <content type="html"><![CDATA[<h1 id="reduce-메서드"><a href="#reduce-메서드" class="headerlink" title="reduce 메서드"></a>reduce 메서드</h1><h2 id="reduce-연산"><a href="#reduce-연산" class="headerlink" title="reduce() 연산"></a>reduce() 연산</h2><ul><li>기존에 정의된 연산이 아닌 직접 구현한 연산을 적용한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identify, BinaryOperator&lt;T&gt; accumulator)</span></span></span><br></pre></td></tr></table></figure></li><li>최종 연산으로 스트림을 요소를 소모하여 연산을 수행한다.</li><li>예시<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BinaryOperator;</span><br><span class="line"><span class="comment">// parameter BinaryOperator&lt;T&gt;를 구현하여 사용</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareString</span> <span class="keyword">implements</span> <span class="title">BinaryOperator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.getBytes().length &gt;= s2.getBytes().length) <span class="keyword">return</span> s1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReduceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String greetings[] = &#123;<span class="string">&quot;안녕히계세요~~~&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Goood morning&quot;</span>, <span class="string">&quot;반갑습니다&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 직접 작성</span></span><br><span class="line">        System.out.println(Arrays.stream(greetings).reduce(<span class="string">&quot;&quot;</span>, (s1,s2)-&gt;</span><br><span class="line">            &#123;<span class="keyword">if</span> (s1.getBytes().length &gt;= s2.getBytes().length) <span class="keyword">return</span> s1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> s2;&#125;</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. BinaryOperator&lt;T&gt;의 메서드 implement</span></span><br><span class="line">        <span class="comment">// 새로운 클래스로 생성하여 사용한다.</span></span><br><span class="line">        String str = Arrays.stream(greetings).reduce(<span class="keyword">new</span> CompareString()).get();</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>람다식 (Lambda Expression)</title>
      <link href="/08/25/Lambda/"/>
      <url>/08/25/Lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="람다식-Lambda-Expression"><a href="#람다식-Lambda-Expression" class="headerlink" title="람다식 (Lambda Expression)"></a>람다식 (Lambda Expression)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>java8부터 함수형 프로그래밍 방식을 지원하고, 이를 <code>람다식</code>이라고 한다.</li><li>함수형 프로그래밍<ul><li>매개 변수만을 사용하여 만드는 함수인 <code>순수 함수</code>를 구현</li><li>외부 자료를 사용하지 않으므로 side effect가 없다</li><li>여러 자료를 동시에 처리하는 병렬처리가 가능하다.<ul><li>함수의 기능이 자료에 독립적이다.</li></ul></li></ul></li></ul><h2 id="문법"><a href="#문법" class="headerlink" title="문법"></a>문법</h2><ul><li>익명 함수 만들기</li><li>매개변수와 매개변수를 이용한 실행문으로 구현된다.</li><li>java는 OOP언어이기 때문에 람다식, 함수로만 클래스를 구성할 수 없다.<ul><li>interface의 메소드를 구현하는 방식으로 한다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch02;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Add add = (x, y) -&gt; &#123;<span class="keyword">return</span> x+y;&#125;;</span><br><span class="line">        System.out.println(add.add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="람다식과-OOP-방식-비교"><a href="#람다식과-OOP-방식-비교" class="headerlink" title="람다식과 OOP 방식 비교"></a>람다식과 OOP 방식 비교</h2><ul><li>람다식에서는 FunctionalInterface 익명 내부 클래스가 생성된다.</li><li>OOP 방식에서는 Interface를 implement하여 구현하고, 메서드를 호출한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringConcatTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        <span class="comment">// OOP 방식    </span></span><br><span class="line">        StringConcatImp strImp = <span class="keyword">new</span> StringConcatImp();</span><br><span class="line">        strImp.makeString(s1, s2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 람다식 구현 방식</span></span><br><span class="line">        StringConcat concat = (s,v)-&gt; System.out.println(s+<span class="string">&quot;,&quot;</span>+v);</span><br><span class="line">        concat.makeString(s1,s2);</span><br><span class="line">        <span class="comment">// 2. 람다식 구현 방식</span></span><br><span class="line">        StringConcat concat2 = <span class="keyword">new</span> StringConcat() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                System.out.println(s1+<span class="string">&quot;,&quot;</span>+s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> 람다식 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>내부 클래스</title>
      <link href="/08/24/InnerClass/"/>
      <url>/08/24/InnerClass/</url>
      
        <content type="html"><![CDATA[<h1 id="내부-클래스"><a href="#내부-클래스" class="headerlink" title="내부 클래스"></a>내부 클래스</h1><h2 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h2><h3 id="인스턴스-instance-내부-클래스"><a href="#인스턴스-instance-내부-클래스" class="headerlink" title="인스턴스(instance) 내부 클래스"></a>인스턴스(instance) 내부 클래스</h3><ul><li>인스턴스 변수와 생성 위치, 방법, Scope가 동일하다.</li><li>내부적으로 사용할 클래스를 선언 (private으로 선언하는 것을 권장)</li><li><code>외부 클래스가 생성된 후 생성됨</code></li><li>private이 아닌 내부 클래스는 다른 외부 클래스에서 생성할 수 있다.<ul><li>문법적으로는 가능하지만 잘 사용하지 않는다.</li></ul></li></ul><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch01;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sNum = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> InClass inClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inClass = <span class="keyword">new</span> InClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iNum = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OutClass num = &quot;</span> +num + <span class="string">&quot;(외부 클래스의 인스턴스 변수)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;OutClass sNum = &quot;</span> + sNum + <span class="string">&quot;(외부 클래스의 스태틱 변수)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;InClass inNum = &quot;</span> + iNum + <span class="string">&quot;(내부 클래스의 인스턴스 변수)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usingClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inClass.inTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutClass outClass = <span class="keyword">new</span> OutClass();</span><br><span class="line">        outClass.usingClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">        OutClass.InClass inner = outClass.<span class="function">new <span class="title">InClass</span><span class="params">()</span></span>;</span><br><span class="line">        inner.inTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="정적-static-내부-클래스"><a href="#정적-static-내부-클래스" class="headerlink" title="정적(static) 내부 클래스"></a>정적(static) 내부 클래스</h3><ul><li>정적 변수와 정적 메서드를 사용한다.</li><li>내부 클래스의 인스턴스, 스태틱 변수, 외부 클래스의 스태틱 변수를 사용할 수 있다.</li><li><code>외부 클래스 생성과 무관하게 사용할 수 있다.</code></li></ul><blockquote><ul><li>외부 클래스가 생성되지 않아도 사용할 수 있기 때문에 정적 내부 클래스에서 외부 클래스의 인스턴스 변수를 사용할 수 없다.</li><li>정적 내부 클래스의 정적 메서드는 스태틱 변수만 사용할 수 있다.</li></ul></blockquote><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InStaticClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iNum = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> sInNum = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inClass num = &quot;</span> +iNum + <span class="string">&quot;(외부 클래스의 인스턴스 변수)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;OutClass sNum = &quot;</span> + sNum + <span class="string">&quot;(외부 클래스의 스태틱 변수)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;InClass inNum = &quot;</span> + sInNum + <span class="string">&quot;(내부 클래스의 인스턴스 변수)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OutClass sNum = &quot;</span> + sNum + <span class="string">&quot;(외부 클래스의 스태틱 변수)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;InClass inNum = &quot;</span> + sInNum + <span class="string">&quot;(내부 클래스의 인스턴스 변수)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><h3 id="지역-local-내부-클래스"><a href="#지역-local-내부-클래스" class="headerlink" title="지역(local) 내부 클래스"></a>지역(local) 내부 클래스</h3><ul><li>지역 변수와 같이 메서드 내부에서 정의하여 사용한다.</li><li>메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라짐<blockquote><p>메서드 호출 이후 반환이 되어도 메서드의 지역 변수를 클래스를 통해 사용할 수 있으므로 <code>final</code>로 처리한다. </p></blockquote></li></ul><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> outNum = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sNum = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 메서드</span></span><br><span class="line">    <span class="function">Runnable <span class="title">getRunnable</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 지역 내부 클래스</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> localNum = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">// 재정의</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;i =&quot;</span> + i);</span><br><span class="line">                System.out.println(<span class="string">&quot;num = &quot;</span> +num);</span><br><span class="line">                System.out.println(<span class="string">&quot;localNum = &quot;</span> +localNum);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;outNum = &quot;</span> + outNum + <span class="string">&quot;(외부 클래스 인스턴스 변수)&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Outter.sNum = &quot;</span> + Outer2.sNum + <span class="string">&quot;(외부 클래스 정적 변수)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Outer2 out = <span class="keyword">new</span> Outer2();</span><br><span class="line">        <span class="comment">// 메서드가 Runnable한 값을 runner에 return해주고 해제되었다.</span></span><br><span class="line">        Runnable runner = out.getRunnable(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 해제된 이후 지역 내부 클래스의 메서드 사용 </span></span><br><span class="line">        <span class="comment">// final로 선언해주었기 때문에</span></span><br><span class="line">        runner.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="익명-Anonymous-내부-클래스"><a href="#익명-Anonymous-내부-클래스" class="headerlink" title="익명(Anonymous) 내부 클래스"></a>익명(Anonymous) 내부 클래스</h3><ul><li>이름이 없는 클래스<ul><li>지역 내부 클래스의 예시코드에서 클래스 이름 <code>MyRunnable</code>은 실제로 호출되지 않으므로 이를 생략한다.</li><li>하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환한다.</li></ul></li></ul><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch01;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> outNum = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sNum = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 메서드</span></span><br><span class="line">    <span class="function">Runnable <span class="title">getRunnable</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 익명 내부 클래스 (바로 return값을 입력)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="keyword">int</span> localNum = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">// 재정의</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;i =&quot;</span> + i);</span><br><span class="line">                System.out.println(<span class="string">&quot;num = &quot;</span> +num);</span><br><span class="line">                System.out.println(<span class="string">&quot;localNum = &quot;</span> +localNum);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;outNum = &quot;</span> + outNum + <span class="string">&quot;(외부 클래스 인스턴스 변수)&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Outter.sNum = &quot;</span> + Outer2.sNum + <span class="string">&quot;(외부 클래스 정적 변수)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// runnable을 생성해서 바로 구현</span></span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Runnable class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Outer2 out = <span class="keyword">new</span> Outer2();</span><br><span class="line">    Runnable runner = out.getRunnable(<span class="number">100</span>);</span><br><span class="line">    runner.run();</span><br><span class="line"></span><br><span class="line">    out.runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Inner Class </tag>
            
            <tag> 내부 클래스 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>클래스 프레임워크</title>
      <link href="/08/24/ClassFramework/"/>
      <url>/08/24/ClassFramework/</url>
      
        <content type="html"><![CDATA[<h1 id="컬렉션-프레임워크"><a href="#컬렉션-프레임워크" class="headerlink" title="컬렉션 프레임워크"></a>컬렉션 프레임워크</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>프로그램 구현에 필요한 자료구조를 구현해 놓은 JDK 라이브러리</li><li><code>java.util</code> 패키지에 구현되어 있다.</li></ul><h2 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h2><h3 id="Collection-인터페이스"><a href="#Collection-인터페이스" class="headerlink" title="Collection 인터페이스"></a>Collection 인터페이스</h3><ul><li>하나의 요소를 관리할 때 사용한다.</li><li>하위에 List와 Set 인터페이스가 있다.<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4></li><li>컬렉션 프레임워크에 저장된 요소를 하나씩 차례로 참조한다.</li><li>List 인터페이스 : 순서가 정해져 있으므로 get(I)를 사용하여 참조 또한 가능하다.</li><li>Set 인터페이스 : get(I) 메서드가 제공되지 않으므로 Iterator를 활용하여 객체를 순회한다.</li><li>Iterator 함수를 호출하면 iterator가 반환이 된다.</li></ul><ul><li><code>hasNext()</code> : 이후에 요소가 더 있는지를 체크하는 메서드</li><li><code>E.next()</code> : 다음에 있는 요소를 반환</li></ul><details><summary>구현 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Member&gt; ir = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (ir.hasNext())&#123;</span><br><span class="line">    Member member = ir.next();</span><br><span class="line">    <span class="keyword">int</span> tempId = member.getMemberId();</span><br><span class="line">    <span class="keyword">if</span> (tempId == memberId)&#123;</span><br><span class="line">        arrayList.remove(member);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(memberId + <span class="string">&quot;가 존재하지 않습니다.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></details><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li>객체를 순서에 따라 저장 및 관리할 때 필요한 메서드가 선언된 인터페이스</li><li>리스트 자료구조의 구현을 위한 인터페이스</li><li>객체의 중복을 허용한다.</li><li>ArrayList, Vector, Queue, Stack, LinkedList 등</li></ul><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><details><summary>구현 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberArrayList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Member&gt; arrayList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemberArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemberArrayList</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMember</span><span class="params">(Member member)</span></span>&#123;</span><br><span class="line">        arrayList.add(member);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeMember</span><span class="params">(<span class="keyword">int</span> memberId)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 중복이 가능하므로 어떤 요소를 삭제할 것인지 먼저 retrieve</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class="line">            Member member = arrayList.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tempId = member.getMemberId();</span><br><span class="line">            <span class="keyword">if</span> (tempId == memberId)&#123;</span><br><span class="line">                arrayList.remove(i);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(memberId + <span class="string">&quot;가 존재하지 않습니다.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAllMember</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Member i :arrayList)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li>아이디, 주민번호, 사번 등 유일한 값들의 집합을 관리할 때 사용한다.</li><li>저정된 순서와 출력 순서가 달라질 수 있다.</li></ul><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ul><li>검색을 위한 알고리즘인 Hash 방식으로 구성되어 있고, key</li><li>순서와 관계가 없다.</li><li>멤버의 중복 여부를 체크하기 위해 인스턴스의 동일성을 확인해야 한다.<ul><li>동일성 구현을 위해 필요에 따라 <code>equals()</code>와 <code>hashCode()</code> 메서드를 재정의함</li><li>hashCode는 객체를 구분하기 위한 unique한 값을 return하게 해준다.</li></ul></li></ul><details><summary> Override 코드 확인하기 </summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memberId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Member) &#123;</span><br><span class="line">            Member member = (Member)obj;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.memberId == member.memberId) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><ul><li>객체의 정렬에 사용하는 클래스 (중복을 허용하지 않는다.)</li><li>내부적으로 Binary Search Tree가 구현이 되어있다. (In-order traversal)</li><li>Java에서는 balance를 위해 레드-블랙 트리를 사용한다.</li><li>비교하기 위한 요소를 구현하여야한다.<ul><li>작은 값은 왼쪽으로, 큰 값은 오른쪽으로 정렬하기 위해</li><li>element를 추가할 때마다 어떻게 비교할 지 <code>comparable</code>, <code>comparator</code>인터페이스를 구현하여야한다.</li></ul></li></ul><details><summary>Comparable 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparable 인터페이스를 implement하여 compareTo 메서드를 오버라이딩 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Member</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Member member)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this = 삽입되는 값</span></span><br><span class="line">    <span class="comment">// this가 크면 양수를 반환하여 오른쪽으로 이동하게 구현되어 있다.</span></span><br><span class="line">    <span class="comment">// 값이 같으면 (중복되면) 0을 반환하여 삽입되지 않는다.</span></span><br><span class="line">    <span class="comment">// 내림 차순은 양수, 음수를 바꿔주면 된다.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.memberId - member.memberId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary> Comparator 코드 확인하기 </summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Comparator 인터페이스를 implement하여 compare 메서드 오버라이딩.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Member</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Member o1, Member o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (o1.memberId - o2.memberId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Comparator를 사용할 때</span></span><br><span class="line"><span class="comment">// TreeSet의 constructor(생성자)에 comparator를 구현한 객체를 지정해주어야한다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemberTreeSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        treeSet = <span class="keyword">new</span> TreeSet&lt;Member&gt;(<span class="keyword">new</span> Member());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 객체에 default constructor가 있어야 사용할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h5 id="Comparator-활용하기"><a href="#Comparator-활용하기" class="headerlink" title="Comparator 활용하기"></a>Comparator 활용하기</h5><ul><li>이미 Comparable이 구현된 경우 Comparator로 비교 로직을 다시 구현할 수 있음</li><li>String이 제공하는 compare 메서드는 오름차순으로 정렬이 된다.</li><li>return값에 -1을 곱하여 내림차순으로 수정한다.</li></ul><details><summary>기존 코드</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;Park&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Kim&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 결과 : [Kim, Lee, Park]</span></span><br></pre></td></tr></table></figure></details><details><summary>Comparator 활용 코드</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 String 클래스의 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2)*-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeSet을 생성할 때 매개변수로 Comparator를 정의한 클래스를 넣어준다.</span></span><br><span class="line">TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> MyCompare());</span><br><span class="line">      set.add(<span class="string">&quot;Park&quot;</span>);</span><br><span class="line">              set.add(<span class="string">&quot;Kim&quot;</span>);</span><br><span class="line">              set.add(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"></span><br><span class="line">              System.out.println(set);</span><br></pre></td></tr></table></figure></details><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>Key와 value의 pair를 관리할 때 사용한다.</li><li>Key값은 유일하여, 중복이 허용되지 않는다.</li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li>Key를 이용하여 값을 저장하고, 값을 꺼내온다.</li><li>key가 되는 객체는 중복될 수 없고, 객체의 유일성을 비교하기 위해 <code>equals()</code>, <code>hashCode()</code> 메서드를 구현하여야 한다. </li><li>Key는 중복이 될 수 없으므로 Set과 같은 개념</li><li>Value는 중복이 될 수 있으므로 Collection과 같은 개념으로 보면 된다.<blockquote><p>다른 키값이라도 hash함수를 통해 같은 index가 도출될 수 있다. </p><ul><li>Collision이 발생하며 오버헤드가 발생할 수 있다.</li><li>Java에서는 hash table의 Load Balance를 약 75%로 산정하여, 이를 방지한다.<ul><li>100개가 들어갈 수 있는 테이블에 약 75개의 데이터를 수용함</li></ul></li></ul></blockquote></li></ul><details><summary>예제 코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       hashMap.put(<span class="number">1001</span>, <span class="string">&quot;Kim&quot;</span>);</span><br><span class="line">       hashMap.put(<span class="number">1002</span>, <span class="string">&quot;Lee&quot;</span>);</span><br><span class="line">       hashMap.put(<span class="number">1003</span>, <span class="string">&quot;Park&quot;</span>);</span><br><span class="line">       hashMap.put(<span class="number">1004</span>, <span class="string">&quot;Hong&quot;</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(hashMap);</span><br></pre></td></tr></table></figure></details><details><summary>새로운 객체 HashMap 생성</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Member&gt; hashMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemberHashMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMember</span><span class="params">(Member member)</span></span>&#123;</span><br><span class="line">        hashMap.put(member.getMemberId(), member);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeMember</span><span class="params">(<span class="keyword">int</span> memberId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(memberId))&#123;</span><br><span class="line">            hashMap.remove(memberId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;no element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterator&lt;Integer&gt; ir = hashMap.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ir.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> key = ir.next();</span><br><span class="line">            Member member = hashMap.get(key);</span><br><span class="line">            System.out.println(member);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul><li>키로 정렬이 되고,  tree를 사용한다.</li><li>TreeSet과 HashMap의 개념을 합한 클래스</li><li>key, value 페어 key값을 기준으로 정렬<ul><li><code>key</code>에 해당되는 class에 <code>comparable</code>, <code>comparator</code> 정렬</li><li>key가 Integer, String이면 기존 메서드 활용하고, 아니면 오버라이딩하여 사용한다.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Basic </tag>
            
            <tag> 클래스 프레임워크 </tag>
            
            <tag> Class Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>자바 배열 구현</title>
      <link href="/08/20/JavaArray/"/>
      <url>/08/20/JavaArray/</url>
      
        <content type="html"><![CDATA[<h1 id="Array-구현"><a href="#Array-구현" class="headerlink" title="Array 구현"></a>Array 구현</h1><ul><li>jdk 클래스 : ArrayList, Vector<h2 id="구현-함수"><a href="#구현-함수" class="headerlink" title="구현 함수"></a>구현 함수</h2></li><li>배열은 크기를 미리 정해주어야 한다.<blockquote><ul><li>ARRAY_SIZE = 배열의 크기 </li><li>count = 배열 내 요소 개수</li><li>addElement = 요소 추가 함수</li><li>insertElement = 요소 삽입 함수</li><li>removeElement = 요소 제거 함수</li><li>getSize = 배열의 크기</li><li>getElement = 검색 함수</li><li>printAll = 모든 요소 출력</li><li>removeAll = 모든 요소 삭제</li></ul></blockquote></li></ul><details><summary>예제코드 확인하기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] intArr;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ARRAY_SIZE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_NUM = -<span class="number">999999999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        ARRAY_SIZE = <span class="number">10</span>;</span><br><span class="line">        intArr = <span class="keyword">new</span> <span class="keyword">int</span>[ARRAY_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        ARRAY_SIZE = size;</span><br><span class="line">        intArr = <span class="keyword">new</span> <span class="keyword">int</span>[ARRAY_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= ARRAY_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Not enough Memory&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        intArr[count++] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertElement</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = count - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= ARRAY_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Not enough Memory&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; count) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Insert Error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt; index) &#123;</span><br><span class="line">            intArr[i + <span class="number">1</span>] = intArr[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        intArr[index] = num;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = ERROR_NUM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;There is no element&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= count)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;index Error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = intArr[index];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i&lt;count-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            intArr[i] = intArr[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; count-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;검색 위치 오류입니다. 현재 리스트의 개수는 &quot;</span> + count + <span class="string">&quot;입니다.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR_NUM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intArr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;출력할 값이 없습니다.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count; i++)&#123;</span><br><span class="line">            System.out.println(intArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            intArr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
            <tag> 자바 </tag>
            
            <tag> 배열 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class 클래스</title>
      <link href="/08/19/Class/"/>
      <url>/08/19/Class/</url>
      
        <content type="html"><![CDATA[<h1 id="Class-클래스-사용하기"><a href="#Class-클래스-사용하기" class="headerlink" title="Class 클래스 사용하기"></a>Class 클래스 사용하기</h1><ul><li><p>자바의 모든 클래스와 인터페이스는 컴파일 후 class파일이 생성된다.</p><ul><li>클래스 내의 메서드, 생성자 배열 등 모든 정보가 들어있다.</li></ul></li><li><p>컴파일 된 class 파일을 로드하여 객체를 동적으로 로드하고, 정보를 가져오는 메서드가 제공된다.</p></li></ul><h2 id="클래스-동적-로딩"><a href="#클래스-동적-로딩" class="headerlink" title="클래스 동적 로딩"></a>클래스 동적 로딩</h2><h3 id="Class-forName-“클래스-이름”"><a href="#Class-forName-“클래스-이름”" class="headerlink" title="Class.forName(“클래스 이름”)"></a>Class.forName(“클래스 이름”)</h3><ul><li><code>Class c = Class.forName(&quot;java.lang.String&quot;)</code><blockquote><p>동적 로딩</p><ul><li>일반적으로 Class가 Local에 있는지 살펴보고 binding되어 type으로 정의하여 변수가 사용된다.</li><li>Compile 할 때가 아닌, 실질적으로 실행할 때 필요한 클래스를 binding하는 방법</li><li>ex) JDBC 드라이버에서 실행 전까지 DB의 라이브러리가 어떤 것인지 모르고, property파일 등을 읽을 때 변수로 갖고 있다가 Oracle 드라이버 이름을 String변수에 넣어준다.</li></ul></blockquote></li><li>장점 : 동적으로  원하는 클래스를 로딩할 수 있다.</li><li>단점 : 로딩할 때 Local에 class나 라이브러리가 없는 등 오류가 발생하면 시스템이 다운될 수 있다.</li></ul><h2 id="사용-방법"><a href="#사용-방법" class="headerlink" title="사용 방법"></a>사용 방법</h2><ul><li>주로 remote에 있는 class를 호출할 때 사용한다.<ul><li><code>Local에 클래스가 없을 때</code></li></ul></li><li>아래 코드를 <code>reflection 프로그래밍</code>이라고 한다.<details><summary>예제 코드 확인하기</summary></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package ch04;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        Class c = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">        </span><br><span class="line">        // Constructor의 목록을 배열로 가져온다.</span><br><span class="line">        Constructor[] cons = c.getConstructors();</span><br><span class="line">        for (Constructor co : cons) &#123;</span><br><span class="line">            System.out.println(co);</span><br><span class="line">        &#125;</span><br><span class="line">        // 메소드의 목록을 가져온다.</span><br><span class="line">        Method[] m = c.getMethods();</span><br><span class="line">        for (Method mth : m) &#123;</span><br><span class="line">            System.out.println(mth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="인스턴스-생성"><a href="#인스턴스-생성" class="headerlink" title="인스턴스 생성"></a>인스턴스 생성</h2><ul><li><code>reflection 프로그래밍</code><ul><li>Class 클래스를 사용하여 클래스의 정보 등을 알 수 있고, 인스턴스를 생성, 메서드를 호출하는 방식의 프로그래밍<ol><li>로컬 메모리에 객체가 없는 경우</li><li>원격 프로그래밍 (서로 다른 프로세스)</li><li>객체의 타입을 알 수 없는 경우</li></ol></li><li><code>java.lang.reflect</code> 패키지의 클래스를 활용하여 사용</li><li>자료형을 알고 있는 경우에는 사용하지 않음</li></ul></li></ul><details><summary> 예제 코드 확인하기 </summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package ch04;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class ClassTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        // 1. Class 이름으로 invoke(호출)하기</span><br><span class="line">        Class c1 = Class.forName(&quot;ch04.Person&quot;);</span><br><span class="line">        // Person 타입으로 Casting</span><br><span class="line">        Person person = (Person)c1.newInstance();</span><br><span class="line"></span><br><span class="line">        person.setName(&quot;Lee&quot;);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 2. 이미 생성된 객체로 invoke</span><br><span class="line">        Class c2 = person.getClass();</span><br><span class="line">        // 2-1. 인스턴스화, Person타입으로 Casting</span><br><span class="line">        Person person2 = (Person)c2.newInstance();</span><br><span class="line">        person2.setName(&quot;Kim&quot;);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 3. 생성자를 호출하여 객체 생성</span><br><span class="line">        Class[] classArray = &#123;String.class&#125;;</span><br><span class="line">        Constructor cons = c2.getConstructor(classArray);</span><br><span class="line">        // 3-1. Object 배열 형태</span><br><span class="line">        Object[] initargs = &#123;&quot;Jeong&quot;&#125;;</span><br><span class="line">        // Line23에서 불러온 생성자로 객체 생성</span><br><span class="line">        Person person3 = (Person)cons.newInstance(initargs);</span><br><span class="line">        System.out.println(person3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 자바 </tag>
            
            <tag> Class 클래스 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>자바의 클래스</title>
      <link href="/08/19/JavaClasses/"/>
      <url>/08/19/JavaClasses/</url>
      
        <content type="html"><![CDATA[<h1 id="Java의-유용한-클래스들"><a href="#Java의-유용한-클래스들" class="headerlink" title="Java의 유용한 클래스들"></a>Java의 유용한 클래스들</h1><h2 id="Object-Class"><a href="#Object-Class" class="headerlink" title="Object Class"></a>Object Class</h2><ul><li>모든 클래스의 최상위 클래스</li><li>모든 class는 Object클래스를 상속받는다.</li><li>메서드 중 일부는 필요에 의해 재정의 할 수 있다.</li><li>java.lang 패키지 안에 포함되어 있다.</li></ul><h3 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h3><ul><li>프로그래밍 시 자동으로 import된다</li><li>많이 사용하는 기본 클래스들이 속한 패키지</li><li>String, Integer, System 등</li></ul><h3 id="toString-메서드"><a href="#toString-메서드" class="headerlink" title="toString() 메서드"></a>toString() 메서드</h3><ul><li>객체의 정보를 String으로 바꾸어서 사용할 때 쓰인다.</li><li>재정의하여 참조변수가 멤버 변수 값을 return하게 할 수 있다.<details><summary>예제 코드 확인하기</summary></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Book&#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public Book(String title, String author)&#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return title + &quot;,&quot; + author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BookTest &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Book book = new Book(&quot;데미안&quot;, &quot;헤르만 헤세&quot;);</span><br><span class="line">System.out.println(book);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h3 id="equals-hashCode-메서드"><a href="#equals-hashCode-메서드" class="headerlink" title="equals(), hashCode() 메서드"></a>equals(), hashCode() 메서드</h3><blockquote><p>equals() 메서드와 hashCode() 메서드는 짝을 이룬다.</p><ul><li>equals()를 overriding하면 객체가 반환하는 hash값도 overriding해줘야 한다.</li><li>equals에서 사용한 멤버 변수를 hashCode 값으로 반환해주면 된다.</li></ul></blockquote><h4 id="equals-메서드"><a href="#equals-메서드" class="headerlink" title="equals() 메서드"></a>equals() 메서드</h4><ul><li>두 인스턴스의 <code>주소 값을 비교</code>하여 true/false를 반환</li><li>인스턴스가 다르더라도 논리적으로 동일한 경우 true를 반환하도록 재정의 할 수 있다.</li><li>두 객체가 논리적으로 같다라고 하면 반환하는 Hash Code 값이 같아야한다.</li><li>Java에서 주소 값은 <code>Hash Code(해쉬 값)</code>이라고 한다.</li><li>heap 메모리를 관리하는 방식이 Hash방식이다.</li></ul><h4 id="hashCode-메서드"><a href="#hashCode-메서드" class="headerlink" title="hashCode() 메서드"></a>hashCode() 메서드</h4><ul><li>인스턴스의 저장 주소를 반환한다.</li><li>hash : 정보를 저장, 검색하는 자료 구조</li><li>자료의 특정 값(key)에 대한 저장 위치를 반환해주는 hash함수를 사용한다.</li><li><code>index(저장위치) = hash(key)</code></li></ul><details><summary> Overriding 코드 확인하기 </summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package ch02;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">private int studentNum;</span><br><span class="line">private String studentName;</span><br><span class="line"></span><br><span class="line">    public Student(int StudentNum, String studentName)&#123;</span><br><span class="line">        this.studentNum = studentNum;</span><br><span class="line">        this.studentName = studentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return studentNum + &quot;,&quot; + studentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        if (obj instanceof Student) &#123;</span><br><span class="line">            // 다운캐스팅</span><br><span class="line">            Student std = (Student)obj;</span><br><span class="line">            if (this.studentNum == std.studentNum)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return studentNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>예제 코드 확인하기</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package ch02;</span><br><span class="line"></span><br><span class="line">public class EqualsTest &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        Student std1 = new Student(200, &quot;Lee&quot;);</span><br><span class="line">        Student std2 = new Student(200, &quot;Lee&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(std1==std2); //false</span><br><span class="line">        System.out.println(std1.equals(std2)); //true</span><br><span class="line">        // hashCode() 가 studentNum을 return하도록 overriding하였음.</span><br><span class="line">        System.out.println(std1.hashCode());</span><br><span class="line">        System.out.println(std2.hashCode());</span><br><span class="line"></span><br><span class="line">        // 원래 hashCode값 출력하는 방법</span><br><span class="line">        System.out.println(System.identityHashCode(std1));</span><br><span class="line">        System.out.println(System.identityHashCode(std2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="clone-메서드"><a href="#clone-메서드" class="headerlink" title="clone() 메서드"></a>clone() 메서드</h3><ul><li>객체를 생성자를 통해 생성할 때, clone()을 사용하면 원본 객체와 원본을 복제하는데 사용한다.</li><li>생성자 : 초기값을 가지고 생성이 된다.</li><li>clone() : 중간에 멤버변수가 변하면 변한 값을 그대로 복제한다.</li><li>private까지 모두 복제가 되어 객체 보호의 관점에서 위배할 수 있다.</li><li>명시적으로 clone() 메서드의 사용을 허용한다는 의미로 <code>Cloneable</code> interface를 명시해준다.</li><li><code>public class A implements Cloneable &#123;~&#125;</code></li><li>A 클래스 내에서 clone() 메서드를 Override한다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">return super.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>클론 코드<ul><li><code>Student copyStd = (Student)std1.clone();</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String 관련 Class</title>
      <link href="/08/19/String/"/>
      <url>/08/19/String/</url>
      
        <content type="html"><![CDATA[<h1 id="String-관련-Class"><a href="#String-관련-Class" class="headerlink" title="String 관련 Class"></a>String 관련 Class</h1><h2 id="String-클래스"><a href="#String-클래스" class="headerlink" title="String 클래스"></a>String 클래스</h2><h3 id="선언"><a href="#선언" class="headerlink" title="선언"></a>선언</h3><ol><li><code>String str = new String(“abc”);</code><ul><li>힙 메모리에 생성된다.</li></ul></li><li><code>String str2 = “abc”;</code><ul><li>상수 pool의 abc라는 String에 address가 생성된다.</li></ul></li></ol><ul><li>두 개의 인스턴스는 다르다.</li><li>힙 메모리는 생성될 때마다 다른 주소값을 가지지만, 상수 pool의 문자열은 모두 같은 주소를 가진다.</li></ul><h3 id="메모리"><a href="#메모리" class="headerlink" title="메모리"></a>메모리</h3><ul><li>한번 생성된 String은 immutable(불변)이다.</li><li>String을 연결하면 기존의 String에 연결되는 것이 아닌 새로운 문자열을 위한 메모리가 생성된다.<details><summary>예제 코드 확인하기</summary></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String java = new String(“java”); </span><br><span class="line">String android = new String(“android”); </span><br><span class="line"></span><br><span class="line">java = java.concat(android) // 위 2가지 문자열을 합해주고 java가 가리키게 한다.</span><br><span class="line"></span><br><span class="line">// 문자열 java, android, javaandroid을 위한 메모리가 계속해서 할당되어 있고, java는 “java”가 아닌 “javaandroid”를 가리킨다.</span><br><span class="line"></span><br><span class="line">// 기존 메모리에 덮어쓰는 것이 아닌 새로운 메모리를 할당한다.</span><br></pre></td></tr></table></figure></details><h2 id="StringBuilder-StringBuffer"><a href="#StringBuilder-StringBuffer" class="headerlink" title="StringBuilder, StringBuffer"></a>StringBuilder, StringBuffer</h2><blockquote><p>위 메모리 낭비를 해결하기 위해 <code>StringBuilder</code>, <code>StringBuffer</code>를 활용한다.</p></blockquote><ul><li>내부적으로 가변적인 char[]를 멤버 변수를 가진다.</li><li>새로운 인스턴스를 생성하지 않고, char[]를 변경한다.</li><li>문자열을 연결, 변경할 때 유용하게 사용할 수 있다.<h3 id="차이점"><a href="#차이점" class="headerlink" title="차이점"></a>차이점</h3></li><li>StringBuilder : 단일 쓰레드에서 사용한다.</li><li>StringBuffer : 멀티 쓰레드 프로그래밍에서 동기화를 보장한다.</li><li>두 개 이상의 쓰레드가 같은 메모리에 접근할 때 순서를 가지게 된다.<details><summary> 예제 코드 확인하기 </summary></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package ch03;</span><br><span class="line"></span><br><span class="line">public class StringBuilderTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String java = new String(&quot;java&quot;);</span><br><span class="line">String android = new String(&quot;android&quot;);</span><br><span class="line"></span><br><span class="line">        // 매개변수로 String을 받는다.</span><br><span class="line">        StringBuilder buffer = new StringBuilder(java);</span><br><span class="line">        System.out.println(System.identityHashCode(buffer));</span><br><span class="line">        // 문자열을 추가, 변경해도 메모리값은 변하지 않는다.</span><br><span class="line">        buffer.append(android);</span><br><span class="line">        System.out.println(System.identityHashCode(buffer));</span><br><span class="line"></span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="Text-Block-사용하기"><a href="#Text-Block-사용하기" class="headerlink" title="Text Block 사용하기"></a>Text Block 사용하기</h2><ul><li>Java 13 이상부터 제공한다.</li><li>하나의 string을 연결해서 사용할 때 사용한다.</li><li>서블릿 등 서버사이드에서 클라이언트 쪽으로 데이터를 html, json 프로토콜로  요청할 때 유용하다.</li><li><code>“”” “”” </code> 안에 string을 넣어 사용한다.<details><summary> 예제 코드 확인하기 </summary></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package ch03;</span><br><span class="line"></span><br><span class="line">public class TextBlockTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String textBlocks = &quot;&quot;&quot;</span><br><span class="line">                Hello,</span><br><span class="line">                hi,</span><br><span class="line">                how r u</span><br><span class="line">                &quot;&quot;&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(textBlocks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>추상 클래스 (Abstract Class)</title>
      <link href="/08/12/20210812-Abstract/"/>
      <url>/08/12/20210812-Abstract/</url>
      
        <content type="html"><![CDATA[<h1 id="추상-클래스-Abstract-Class"><a href="#추상-클래스-Abstract-Class" class="headerlink" title="추상 클래스 (Abstract Class)"></a>추상 클래스 (Abstract Class)</h1><h2 id="의미"><a href="#의미" class="headerlink" title="의미"></a>의미</h2><blockquote><p>구현 코드없이 메서드의 선언만 있는 <code>추상 메서드를 포함한 클래스</code></p><ul><li>메서드를 생성할 때 반환값, 메서드 이름, 매개변수로 구성되어있다.</li></ul><p>구현은 상속받은 <code>자식 클래스</code>가 한다.</p><p>추상 클래스는 인스턴스화(new 로 생성) 할 수 없다.</p><ul><li>기능이 완벽하지 않기 때문</li><li>일반 클래스도 abstract 라고 명시하면 이를 생성할 수 없다.</li></ul></blockquote><ul><li>자식클래스에서 추상 메서드 중 하나라도 구현하지 않으면 자식클래스도 추상클래스가 된다.</li><li>구체적(Concrete)과 반대되는 말로, 구현부를 작성하지 않은 클래스라고 생각할 수 있다.</li><li><code>추상 클래스</code>를 생성하는 것은 <code>선언</code>이라고 한다.</li><li>어떤 기능을 할지 구현부를 작성하면 메서드를 <code>정의</code>한다고 한다.</li><li>다이어그램으로 나타낼 때 추상 메서드와 클래스는 Italic체로 작성한다.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, intb); //선언 (추상 메서드)</span><br><span class="line">int add(int a, intb)&#123; //정의</span><br><span class="line">구현할 기능ㅔ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 자바 </tag>
            
            <tag> 추상 클래스 </tag>
            
            <tag> AbstractClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>다형성(Polymorphism)</title>
      <link href="/08/12/20210812-Polymorphism/"/>
      <url>/08/12/20210812-Polymorphism/</url>
      
        <content type="html"><![CDATA[<h1 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h1><ul><li>하나의 코드가 여러 자료형으로 구현되어 실행 되는 것</li><li>같은 코드에서 여러가지 실행 결과가 나오는 것<blockquote><p>유연하고 확장성있고, 유지보수가 편리함 프로그램을 만들 수 있다.</p></blockquote></li></ul><h2 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h2><ul><li>하위 클래스들을 상위 클래스로 형변환한다.</li><li>이를 한번에 핸들링한다.</li><li>각 인스턴스별로 다른 실행 결과를 얻을 수 있다.</li><li>결합도가 높아진다.</li></ul><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2><details><summary> 모든 코드 확인하기 </summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package polymorphismTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">// 공통된 기능을 정의 할 때 상위 클래스인 Animal에 기능을 입력한다.</span><br><span class="line">public void move() &#123;</span><br><span class="line">System.out.println(&quot;동물이 움직입니다.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Human extends Animal &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void move() &#123;</span><br><span class="line">System.out.println(&quot;사람이 두 발로 걷습니다.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void readBook() &#123;</span><br><span class="line">System.out.println(&quot;사람이 책을 읽습니다.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tiger extends Animal &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void move() &#123;</span><br><span class="line">System.out.println(&quot;호랑이가 네 발로 뜁니다.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void hunting() &#123;</span><br><span class="line">System.out.println(&quot;호랑이가 사냥을 합니다.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Eagle extends Animal &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void move() &#123;</span><br><span class="line">System.out.println(&quot;독수리가 하늘을 납니다.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void flying() &#123;</span><br><span class="line">System.out.println(&quot;독수리가 양날개를 쭉 펴고 날아다닙니다.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AnimalTest &#123;</span><br><span class="line"> </span><br><span class="line">public static void main (String[] args) &#123;</span><br><span class="line">// 형변환 (업캐스팅 : 상위 클래스의 타입으로 변환)</span><br><span class="line">Animal hAnimal = new Human();</span><br><span class="line">Animal tAnimal = new Tiger();</span><br><span class="line">Animal eAnimal = new Eagle();</span><br><span class="line"></span><br><span class="line">AnimalTest test = new AnimalTest();</span><br><span class="line">// 상위 클래스인 Animal로 형변환이 가능하다.</span><br><span class="line">// 각자의 가상 메서드 테이블을 갖게 된다.</span><br><span class="line">test.moveAnimal(hAnimal);</span><br><span class="line">test.moveAnimal(tAnimal);</span><br><span class="line">test.moveAnimal(eAnimal);</span><br><span class="line"></span><br><span class="line">// 세 동물을 ArrayList에 삽입하고 싶을 때</span><br><span class="line">ArrayList&lt;Animal&gt; animalList = new ArrayList&lt;&gt;();</span><br><span class="line">animalList.add(hAnimal);</span><br><span class="line">animalList.add(tAnimal);</span><br><span class="line">animalList.add(eAnimal);</span><br><span class="line">// enhanced for문을 통한 출력</span><br><span class="line">for (Animal a : animalList) &#123;</span><br><span class="line">a.move();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void moveAnimal(Animal animal) &#123;</span><br><span class="line">animal.move();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="사용하는-이유"><a href="#사용하는-이유" class="headerlink" title="사용하는 이유"></a>사용하는 이유</h2><ul><li> 상속과 메서드의 재정의를 활용하여 확장성 있는 프로그램을 만들 수 있다.</li><li>위 예시로 보았을 때 동물을 추가하고 싶을 때 편하게 추가할 수 있다.</li><li>상위 클래스에 공통된 기능과 하위 클래스에 특정한 기능을 구분하여 코딩할 수 있다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 자바 </tag>
            
            <tag> 다형성 </tag>
            
            <tag> PolyMorphism </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>가상메서드(VirtualMethod)</title>
      <link href="/08/12/20210812-VirtualMethod/"/>
      <url>/08/12/20210812-VirtualMethod/</url>
      
        <content type="html"><![CDATA[<h1 id="가상-메서드"><a href="#가상-메서드" class="headerlink" title="가상 메서드"></a>가상 메서드</h1><h2 id="메서드-Method"><a href="#메서드-Method" class="headerlink" title="메서드 (Method)"></a>메서드 (Method)</h2><ul><li>명령어의 집합 (set)</li><li>Java에서 모든 메서드는 가상 메서드이다. </li><li><code>메서드의 이름</code>은 <code>주소값</code>을 나타낸다.</li><li>메서드를 호출하면 이름과 mapping되어 있는 주소값이 호출된다.<h3 id="함수-호출-방식"><a href="#함수-호출-방식" class="headerlink" title="함수 호출 방식"></a>함수 호출 방식</h3></li></ul><ol><li>프로그램이 로드되면 <code>메서드 영역(코드 영역)</code>에 <code>명령어 set</code>이 위치한다.</li><li>메서드가 호출되면 명령어 set이 위치한 주소를 찾아가 명령어가 실행된다.</li></ol><ul><li>이 때 메서드에 위치한 변수들은 stack메모리에 위치하게 된다.<blockquote><p>서로 다른 인스턴스가 동일한 메서드를 호출하면 같은 method가 호출된다.<br>인스턴스가 생성되면 변수는 heap메모리에 저장이 되지만, 메서드 명령어 set은 한 번만 로드된다.</p></blockquote></li></ul><h2 id="가상-메서드-Virtual-Method"><a href="#가상-메서드-Virtual-Method" class="headerlink" title="가상 메서드 (Virtual Method)"></a>가상 메서드 (Virtual Method)</h2><ul><li>클래스마다 가상 메서드 테이블(Virtual Method Table)에 메서드의 address를 가지고 있다.</li><li>메서드가 재정의되면 재정의된 클래스의 테이블에 address가 추가된다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 자바 </tag>
            
            <tag> 가상메서드 </tag>
            
            <tag> VirtualMethod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>상속(Inheritance)</title>
      <link href="/08/12/20210812-Inheritance/"/>
      <url>/08/12/20210812-Inheritance/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-상속-형변환-재정의"><a href="#Java-상속-형변환-재정의" class="headerlink" title="Java 상속, 형변환, 재정의"></a>Java 상속, 형변환, 재정의</h1><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><ul><li>구현되어 있는 기능, 속성을 <code>확장하여</code> 재사용하는 것 </li><li> class B extends A{ }</li><li>extends 뒤에는 하나의 클래스만 올 수 있다.</li><li>자바는 안정성을 위해 단일 상속만을 지원한다.</li><li>상속 하는 클래스 : 상위 클래스, parent class, child class</li><li>상속 받는 클래스 :  하위, child, sub</li></ul><h3 id="상속을-사용하는-경우"><a href="#상속을-사용하는-경우" class="headerlink" title="상속을 사용하는 경우"></a>상속을 사용하는 경우</h3><ul><li>객체 지향 프로그래밍에서는 크게 2가지 방법을 사용할 수 있다.</li><li><code>IS-A 관계 (is a relationship : inheritance)</code>, <code>HAS-A관계(composition)</code></li><li>IS-A관계에서 상속을 사용한다.</li></ul><ol><li>IS-A 관계</li></ol><ul><li>예시 : 포유류 - 인간, 호랑이, 사자 등</li><li>일반적인 개념과 구체적인 개념의 관계</li><li>뼈대를 구축하고 이를 <code>확장해서 사용할 때</code> 자주 사용된다.</li><li>상속은 클래스간의 결합도가 높은 설계이다.</li><li>계층구조가 복잡하거나 hiearchy가 높으면 좋지 않다.</li></ul><ol start="2"><li>HAS-A 관계</li></ol><ul><li>예시 : Java의 ArrayList 클래스를 사용하는 경우</li><li>클래스가 다른 클래스를 포함하는 관계 (변수로 선언)</li><li>코드 재사용의 가장 일반적인 방법</li></ul><h3 id="상속을-구현하는-경우"><a href="#상속을-구현하는-경우" class="headerlink" title="상속을 구현하는 경우"></a>상속을 구현하는 경우</h3><ul><li>일반적인 클래스로부터 보다 구체적인 클래스를 생성하고 싶을 때 사용한다.</li><li>직업 (일반 클래스) - 개발자 (구체적인 클래스)</li></ul><h3 id="하위-클래스가-생성되는-과정"><a href="#하위-클래스가-생성되는-과정" class="headerlink" title="하위 클래스가 생성되는 과정"></a>하위 클래스가 생성되는 과정</h3><ul><li>extends로 하위클래스를 생성하면 상위 클래스가 먼저 생성된다.</li><li>하위 클래스의 생성자가 상위 클래스의 생성자를 호출하게 된다.</li><li>컴파일러가  하위 클래스의 생성자 내에 <code>super()</code>를 자동으로 입력하여 <code>default 생성자</code>를 호출한다.<blockquote><p>생성자에 매개 변수가 존재할 경우, <code>super(매개변수)</code>를 이용하여 명시적으로 호출해주어야 한다.</p></blockquote></li></ul><h2 id="형변환"><a href="#형변환" class="headerlink" title="형변환"></a>형변환</h2><ul><li><p>상위 클래스로 변수를 생성하고 하위 클래스의 생성자로 인스턴스를 생성</p></li><li><p>상위 클래스 타입의 변수에 하위 클래스의 변수가 대입 (업 캐스팅)</p></li><li><p>메서드의 인자에 하위 클래스 타입을 넣어도 상위 클래스 타입으로 형변환이 가능하다.</p></li><li><p>하위 클래스는 상위 클래스의 타입을 내포하고 있으므로 묵시적 형변환이 가능하다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;&#125;</span><br><span class="line">A instanceA = new B();</span><br><span class="line">method(instanceB);</span><br><span class="line"></span><br><span class="line">type method(A instanceA)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>하위 클래스로 생성이 되었지만 type이 상위 클래스의 type이므로 하위 클래스에서 생성한 method 등에는 접근할 수 없다.</p></li></ul><h2 id="재정의-Overriding"><a href="#재정의-Overriding" class="headerlink" title="재정의 (Overriding)"></a>재정의 (Overriding)</h2><ul><li>상위 클래스에서 정의한 method를 하위 클래스에서 재정의하고 싶을 때 사용</li><li>메서드 정의 부분 (Function Signiture)은 동일하게 입력해야한다.</li><li>다르게 입력할 시 새로운 method를 정의하는 것처럼 해석된다.</li><li>사용법<blockquote><p><code>@Override</code> 를 Annotation으로 입력해준다.</p></blockquote><h4 id="Annotation-주석"><a href="#Annotation-주석" class="headerlink" title="Annotation (주석)"></a>Annotation (주석)</h4></li><li>컴파일러에게 특별한 정보를 제공해주는 역할을 한다.</li><li>Override</li><li>재정의된 메서드라는 정보 제공</li><li>FuctionalInterface</li><li>함수형 인터페이스라는 정보 제공</li><li>Deprecated</li><li>이후 버전에서 사용되지 않을 수 있는 변수</li><li>메서드에서 사용된다.</li><li>SuppressWarnings(“~”)</li><li>특정 경고가 나타나지 않도록함</li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 자바 </tag>
            
            <tag> 상속 </tag>
            
            <tag> Inheritance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>다운캐스팅(DownCasting)</title>
      <link href="/08/12/20210812-DownCasting/"/>
      <url>/08/12/20210812-DownCasting/</url>
      
        <content type="html"><![CDATA[<h1 id="다운캐스팅-DownCasting"><a href="#다운캐스팅-DownCasting" class="headerlink" title="다운캐스팅 (DownCasting)"></a>다운캐스팅 (DownCasting)</h1><h2 id="의미"><a href="#의미" class="headerlink" title="의미"></a>의미</h2><ul><li>업캐스팅된 클래스를 원래의 타입으로 다시 형변환하는 것</li><li>하위 클래스로의 형변환(다운캐스팅)은 명시적으로 해야한다.</li><li>클래스B가 클래스A에게 상속받는 경우<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A instance = new B(); // 묵시적</span><br><span class="line">B instanceB = (B)instance; //명시적</span><br></pre></td></tr></table></figure></li></ul><h2 id="유의-사항"><a href="#유의-사항" class="headerlink" title="유의 사항"></a>유의 사항</h2><ul><li>클래스 B와 C가 클래스 A에게 상속 받는 경우<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// A의 타입으로 B, C의 인스턴스를 생성해준다.</span><br><span class="line">A ins1 = new B();</span><br><span class="line">A ins2 = new C();</span><br><span class="line"></span><br><span class="line">// C타입을 B타입인 ins3로 생성을 시도한다.</span><br><span class="line">// 실행전까지는 에러가 나지 않지만 실행 시 에러가 발생한다.</span><br><span class="line">B ins3 = (B)ins2;</span><br></pre></td></tr></table></figure></li><li>아래와 같은 방어 코드로 에러를 방지할 수 있다.</li><li><code>instanceof</code> : in2가 B클래스로 생성된 인스턴스인지 확인한다<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( in2 instanceof B )&#123;</span><br><span class="line">B ins3 = (B)ins2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 자바 </tag>
            
            <tag> 다운캐스팅 </tag>
            
            <tag> DownCasting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>자바 기초</title>
      <link href="/08/12/20210812-java2/"/>
      <url>/08/12/20210812-java2/</url>
      
        <content type="html"><![CDATA[<h1 id="자바-기초"><a href="#자바-기초" class="headerlink" title="자바 기초"></a>자바 기초</h1><h2 id="객체-지향-프로그래밍-OOP-Object-Oriented-Programming"><a href="#객체-지향-프로그래밍-OOP-Object-Oriented-Programming" class="headerlink" title="객체 지향 프로그래밍 (OOP; Object Oriented Programming)"></a>객체 지향 프로그래밍 (OOP; Object Oriented Programming)</h2><ul><li>Java는 객체 지향 프로그래밍 언어 중 하나이다.<ul><li>객체 : 구체적, 추상적 데이터의 단위 (사람, 사물, 주문 등)</li></ul></li><li>객체 지향 프로그래밍 언어는 협력을 통해 기능을 수행할 수 있다.<blockquote><ol><li><p>클래스로 객체를 정의한다.</p></li><li><p>객체의 속성을 클래스 내부의 멤버 변수로 넣는다.</p></li><li><p>역할과 책임 등을 기능으로 구현한다.</p></li><li><p>클래스 간의 협력을 통해 실행한다.</p></li></ol></blockquote></li></ul><h2 id="함수-Function"><a href="#함수-Function" class="headerlink" title="함수 (Function)"></a>함수 (Function)</h2><ul><li>함수는 기능을 수행하는 단독 모듈이다.</li><li>함수를 호출하여 수행하고 반환할 수 있다.</li><li>기본형<ul><li><code>&lt;접근 제어자&gt; &lt;static | final&gt; &lt;반환형&gt; &lt;함수명&gt;</code></li></ul></li></ul><h3 id="접근-제어자-Access-Modifier"><a href="#접근-제어자-Access-Modifier" class="headerlink" title="접근 제어자 (Access Modifier)"></a>접근 제어자 (Access Modifier)</h3><ul><li><p>어떠한 범위 내에서 함수, 클래스에 대해 접근을 통제할 것인지 정의합니다.</p></li><li><p>public : 어디서든 접근 가능</p></li><li><p>private : 동일한 클래스 내에서만 접근 가능</p><ul><li>public으로 구현된 메서드를 통해 접근이 가능하다.</li></ul></li><li><p>protected : 동일한 패키지 내, 이를 상속받은 자식 클래스 내에서 접근 가능</p></li><li><p>default : 같은 패키지 내에서 접근 가능</p><ul><li>접근제어자를 입력하지 않았을 때 default가 적용된다.</li></ul></li></ul><h3 id="Static-Final"><a href="#Static-Final" class="headerlink" title="Static | Final"></a>Static | Final</h3><ul><li>static<ul><li>이 메서드를 공용으로 사용할 것인지 아닌지를 결정한다.</li><li>static을 삽입하면 공용으로 사용할 수 있다.</li><li>static으로 지정하면 static메모리 공간에 저장되어 프로그램의 시작부터 종료 시 까지 저장된다.</li></ul></li><li>Final<ul><li>상속, 제정의, 변경이 불가한 상태로 지정한다.</li><li>상수를 정의할 때도 사용된다.</li></ul></li></ul><h3 id="반환형-Return-Type"><a href="#반환형-Return-Type" class="headerlink" title="반환형 (Return Type)"></a>반환형 (Return Type)</h3><ul><li>반환형에는 자료형을 삽입할 수 있다.</li><li>생성한 class를 반환형으로 사용할 수도 있다.</li></ul><h2 id="메서드-Method"><a href="#메서드-Method" class="headerlink" title="메서드 (Method)"></a>메서드 (Method)</h2><ul><li><code>클래스</code> 안에서 <code>멤버변수</code>를 이용하여 수행한다.</li><li>메서드는 사용하는 객체에 맞게 작명하는 것이 중요하다.</li></ul><h2 id="생성자-Constructor"><a href="#생성자-Constructor" class="headerlink" title="생성자 (Constructor)"></a>생성자 (Constructor)</h2><ul><li>객체를 사용할 때 항상 생성자를 통해 생성한 후에 사용한다.</li><li>생성하면 <code>heap메모리</code>에 인스턴스가 생성된다.</li><li>생성자를 별도로 구현하지 않아도, default constructor가 생성된다.</li><li>기본 문법<ul><li>&lt;ClassName&gt;([Argument]) {<br>  [Statements]<br>  }</li></ul></li><li>생성자는 오버로딩이 가능하여, 1개 이상 존재할 수 있다.</li></ul><h3 id="오버로딩-Overloading"><a href="#오버로딩-Overloading" class="headerlink" title="오버로딩 (Overloading)"></a>오버로딩 (Overloading)</h3><ul><li>사용자의 편의성을 위해 주로 사용된다.<ul><li>예시: 회원 가입 시 필수 질문만 작성할 수 있고, 추가 정보를 작성하여 가입할 수도 있다.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 자바 </tag>
            
            <tag> 자바 기초 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>자바란 ?</title>
      <link href="/08/10/20210810-java/"/>
      <url>/08/10/20210810-java/</url>
      
        <content type="html"><![CDATA[<h1 id="자바-Java"><a href="#자바-Java" class="headerlink" title="자바 (Java)"></a>자바 (Java)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>C, C++에 비해 안정적이다.</li><li>객체 지향적 언어로 객체 간의 협력을 할 수 있다.</li><li>플랫폼에 영향을 받지 않는다.<blockquote><p>Java의 소스코드를 컴파일러가 바이트 코드로 변환하여 JVM에서 플랫폼에 맞게 다시 변환하고 실행한다.</p></blockquote></li><li>웹 서버, 안드로이드, 게임 프로그래밍에 사용된다.</li></ul><h2 id="Convention"><a href="#Convention" class="headerlink" title="Convention"></a>Convention</h2><ul><li>Class 선언 : Class는 대문자로 시작한다.</li></ul><h2 id="Hot-key"><a href="#Hot-key" class="headerlink" title="Hot key"></a>Hot key</h2><ul><li>Ctrl + D : 삭제</li><li>Ctrl + F11 : Run</li></ul><h2 id="자료형"><a href="#자료형" class="headerlink" title="자료형"></a>자료형</h2><h3 id="정수"><a href="#정수" class="headerlink" title="정수"></a>정수</h3><ul><li>byte (1byte)<ul><li>1바이트 단위인 음악 동영상, 실행파일 등의 자료처리를 할 때 사용된다.</li></ul></li><li>short (2byte)<ul><li>C/C++과 호환 시 사용된다.</li></ul></li><li>int (4byte)<ul><li>자바에서 정수의 기본형으로 사용된다.</li><li>프로그램에서 사용하는 모든 숫자(리터럴)는 int로 표현된다.</li></ul></li><li>long (8byte)<ul><li>int의 범위를 넘어선 -2의 63승 ~ 2의 63승 -1까지 표현</li><li>숫자의 뒤에 L 또는 l을 사용하여 long자료형임을 표시한다.</li></ul></li></ul><h3 id="실수"><a href="#실수" class="headerlink" title="실수"></a>실수</h3><ul><li>float (4byte)</li><li>double (8byte)<ul><li>자바에서 실수의 기본형으로 사용된다.<h4 id="표현"><a href="#표현" class="headerlink" title="표현"></a>표현</h4></li></ul></li><li>실수는 가수, 밑수, 지수로 나뉘어  부동 소수점 방식으로 값이 표현된다.</li><li>컴퓨터에서는 밑수를 2로 사용한다.<h4 id="정규화"><a href="#정규화" class="headerlink" title="정규화"></a>정규화</h4></li><li>가수가 밑수보다 작은 한자리까지 가수로 표현 되는 것</li><li>예시 : 컴퓨터에서는 밑수가 2로 표현되므로, 정규화를 수행하면 가수부분의 첫 번째 자리 숫자는 항상 1로 표현된다.<h4 id="오류"><a href="#오류" class="headerlink" title="오류"></a>오류</h4></li><li>부동 소수점 방식으로는 지수가 0을 표현할 수 없기 때문에 약간의 오차가 발생할 수 있다.</li></ul><h3 id="문자"><a href="#문자" class="headerlink" title="문자"></a>문자</h3><ul><li>컴퓨터에서는 문자를 표현하기 위해 <code>문자세트(Charset)</code>를 사용한다.<ul><li>문자세트 : 각 문자를 어떠한 숫자로 표현할 것인지 코드표로 나타낸 세트</li><li>종류 : ASKII, euc-kr, uft-8, utf-16 등</li></ul></li><li>자바에서는 문자를 나타내기 위해 세계 표준인 UNICODE를 사용한다.<ul><li>utf-16 인코딩을 사용하여 모든 문자를 2바이트로 표시한다.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 자바 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>프림 알고리즘</title>
      <link href="/08/05/20210805-prims/"/>
      <url>/08/05/20210805-prims/</url>
      
        <content type="html"><![CDATA[<h1 id="프림-알고리즘-Prim’s-Algorithm"><a href="#프림-알고리즘-Prim’s-Algorithm" class="headerlink" title="프림 알고리즘 (Prim’s Algorithm)"></a>프림 알고리즘 (Prim’s Algorithm)</h1><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><h3 id="프림-알고리즘"><a href="#프림-알고리즘" class="headerlink" title="프림 알고리즘"></a>프림 알고리즘</h3><ul><li>가중치가 있는 연결된 무향 그래프의 모든 꼭짓점을 포함하면서 각 변의 비용의 합이 최소가 되는 부분 그래프인 트리, 즉 <code>최소 신장트리</code> 를 찾는 알고리즘이다<h3 id="최소-신장트리-Minimum-Spanning-Tree-MST"><a href="#최소-신장트리-Minimum-Spanning-Tree-MST" class="headerlink" title="최소 신장트리 (Minimum Spanning Tree, MST)"></a>최소 신장트리 (Minimum Spanning Tree, MST)</h3></li><li>신장 트리 중에서 간선의 가중치 합이 가장 작은 트리 <blockquote><p>신장트리</p><ul><li>특정한 그래프에서 모든 정점을 포함하는 그래프</li></ul></blockquote></li></ul><h2 id="프림-알고리즘-1"><a href="#프림-알고리즘-1" class="headerlink" title="프림 알고리즘"></a>프림 알고리즘</h2><blockquote><ol start="0"><li>처음에 트리는 비어있다고 가정한다.</li><li>그래프에서 정점 하나를 선택하여 트리에 포함시킨다.</li><li>1에서 포함된 정점과 인접한 노드의 간선 중에서 가중치가 가장 작은 간선을 찾아 포함시킨다.</li><li>2번을 모든 노드가 포함될 때까지 반복한다.</li></ol></blockquote><h2 id="동작-과정"><a href="#동작-과정" class="headerlink" title="동작 과정"></a>동작 과정</h2><blockquote><p>이미지 삽입 예정</p></blockquote><h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><details><summary>모든 코드 확인하기</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#define NODE_MAX 1001</span><br><span class="line">#define EDGE_MAX 200001 // 양방향 간선이므로 100,000개</span><br><span class="line"></span><br><span class="line">// 구조체 정의</span><br><span class="line">typedef struct &#123;</span><br><span class="line">int cost;</span><br><span class="line">int node;</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line">// 데이터 위치 변환을 위한 함수 구현</span><br><span class="line">void swap(Edge *a, Edge *b) &#123;</span><br><span class="line">Edge temp;</span><br><span class="line">temp.cost = a-&gt;cost;</span><br><span class="line">temp.node = a-&gt;node;</span><br><span class="line">a-&gt;cost = b-&gt;cost;</span><br><span class="line">a-&gt;node = b-&gt;node;</span><br><span class="line">b-&gt;cost = temp.cost;</span><br><span class="line">b-&gt;node = temp.node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 우선순위 큐 정의</span><br><span class="line">typedef struct &#123;</span><br><span class="line">Edge *heap[EDGE_MAX];</span><br><span class="line">int count;</span><br><span class="line">&#125; priorityQueue;</span><br><span class="line"></span><br><span class="line">// 데이터 삽입 함수</span><br><span class="line">void push(priorityQueue *pq, Edge *edge) &#123;</span><br><span class="line">    if (pq-&gt;count &gt;= EDGE_MAX) return;</span><br><span class="line">    pq-&gt;heap[pq-&gt;count] = edge;</span><br><span class="line">    int now = pq-&gt;count;</span><br><span class="line">    int parent = (pq-&gt;count - 1) / 2;</span><br><span class="line">    </span><br><span class="line">    // 새 원소를 삽입한 이후에 상향식으로 힙을 구성한다.</span><br><span class="line">    while (now &gt; 0 &amp;&amp; pq-&gt;heap[now]-&gt;cost &lt; pq-&gt;heap[parent]-&gt;cost) &#123;</span><br><span class="line">        swap(pq-&gt;heap[now], pq-&gt;heap[parent]);</span><br><span class="line">        now = parent;</span><br><span class="line">        parent = (parent - 1) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    pq-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 데이터 추출함수 구현</span><br><span class="line">Edge* pop(priorityQueue *pq) &#123;</span><br><span class="line">if (pq-&gt;count &lt;= 0) return NULL;</span><br><span class="line">Edge *res = pq-&gt;heap[0];</span><br><span class="line">pq-&gt;count--;</span><br><span class="line">pq-&gt;heap[0] = pq-&gt;heap[pq-&gt;count];</span><br><span class="line">int now = 0, leftChild = 1, rightChild = 2;</span><br><span class="line">int target = now;</span><br><span class="line"></span><br><span class="line">// 새 원소를 추출한 이후에 하향식으로 힙을 구성합니다.</span><br><span class="line">while (leftChild &lt; pq-&gt;count) &#123;</span><br><span class="line">    if (pq-&gt;heap[target]-&gt;cost &gt; pq-&gt;heap[leftChild]-&gt;cost) target = leftChild;</span><br><span class="line">    if (pq-&gt;heap[target]-&gt;cost &gt; pq-&gt;heap[rightChild]-&gt;cost &amp;&amp; rightChild &lt; pq-&gt;count) target = rightChild;</span><br><span class="line">    if (target == now) break; // 더 이상 내려가지 않아도 될 때 종료</span><br><span class="line">    else &#123;</span><br><span class="line">        swap(pq-&gt;heap[now], pq-&gt;heap[target]);</span><br><span class="line">        now = target;</span><br><span class="line">        leftChild = now * 2 + 1;</span><br><span class="line">        rightChild = now * 2 + 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 데이터 연결리스트 구현</span><br><span class="line">typedef struct Node &#123;</span><br><span class="line">Edge *data;</span><br><span class="line">struct Node *next;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node** adj;</span><br><span class="line">int d[NODE_MAX];</span><br><span class="line"></span><br><span class="line">// 노드 추가를 위한 함수</span><br><span class="line">void addNode(Node** target, int index, Edge* edge) &#123;</span><br><span class="line">    if (target[index] == NULL) &#123;</span><br><span class="line">        target[index] = (Node*)malloc(sizeof(Node));</span><br><span class="line">        target[index]-&gt;data = edge;</span><br><span class="line">        target[index]-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Node* node = (Node*)malloc(sizeof(Node));</span><br><span class="line">        node-&gt;data = edge;</span><br><span class="line">        node-&gt;next = target[index];</span><br><span class="line">        target[index] = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 알고리즘 실행</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span><br><span class="line">    // 큐 초기화</span><br><span class="line">    adj = (Node**)malloc(sizeof(Node*) * (n + 1));</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    adj[i] = NULL;</span><br><span class="line">&#125;</span><br><span class="line">priorityQueue *pq;</span><br><span class="line">pq = (priorityQueue*)malloc(sizeof(priorityQueue));</span><br><span class="line">pq-&gt;count = 0;</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    Edge *edge1 = (Edge*)malloc(sizeof(Edge));</span><br><span class="line">    edge1-&gt;node = b;</span><br><span class="line">    edge1-&gt;cost = c;</span><br><span class="line">    addNode(adj, a, edge1);</span><br><span class="line">    Edge *edge2 = (Edge*)malloc(sizeof(Edge));</span><br><span class="line">    edge2-&gt;node = a;</span><br><span class="line">    edge2-&gt;cost = c;</span><br><span class="line">    addNode(adj, b, edge2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 프림 알고리즘 </tag>
            
            <tag> Prim&#39;s Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>해시</title>
      <link href="/08/05/20210805-hash/"/>
      <url>/08/05/20210805-hash/</url>
      
        <content type="html"><![CDATA[<h1 id="해시-Hash"><a href="#해시-Hash" class="headerlink" title="해시 (Hash)"></a>해시 (Hash)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>해시를 이용하면 메모리를 많이 소요하지만 최대 빠른 속도로 관리할 수 있다.</li><li>DB 소프트웨어에서 많이 사용된다.</li><li>수학적 연산을 통한 키를 이용하여 값에 접근한다.<ul><li>나머지를 사용하는 방법이 보편적이다.</li><li>테이블 크기를 소수로 설정하여야 충돌 확률이 낮다.</li></ul></li><li>키가 중복이 생길 경우 충돌이 생긴다고 표현하는데 이를 해결하는 방법에는 2가지가 있다.</li></ul><h2 id="충돌-해결"><a href="#충돌-해결" class="headerlink" title="충돌 해결"></a>충돌 해결</h2><h3 id="충돌-시-다른-위치에-저장하기"><a href="#충돌-시-다른-위치에-저장하기" class="headerlink" title="충돌 시 다른 위치에 저장하기"></a>충돌 시 다른 위치에 저장하기</h3><ol><li>선형 조사법</li></ol><ul><li>키가 중복이 생기면 해당 키의 다음 인덱스에 데이터를 저장한다.</li><li>다시 중복이 생기면 <code>인덱스+1</code>을 해나가며 저장한다.</li><li>단점 <ul><li>충돌이 발생하기 시작하면 유사한 값을 가지는 데이터가 밀집되는 집중 결합 문제가 발생한다.</li><li>테이블의 크기가 매우 크면, 충돌은 적어지고, 데이터에 빠르게 접근할 수 있다.</li></ul></li></ul><ol start="2"><li>이차 조사법</li></ol><ul><li>키 값이 중복되면 완전 제곱수를 더해 나가며 저장한다.</li><li><code>인덱스+1</code>, <code>인덱스+4</code> …</li></ul><blockquote><p>선형 조사법 및 이차 조사법에서 데이터의 수가 테이블 인덱스를 초과하게 되면 크기를 확장하여 유지할 수 있도록 설정하여야 한다.</p></blockquote><h3 id="충돌-시-하나의-bucket에-여러-데이터-저장하기"><a href="#충돌-시-하나의-bucket에-여러-데이터-저장하기" class="headerlink" title="충돌 시 하나의 bucket에 여러 데이터 저장하기"></a>충돌 시 하나의 bucket에 여러 데이터 저장하기</h3><ol><li>체이닝 기법</li></ol><ul><li>연결리스트를 활용하여 동일한 키를 가지는 인덱스들을 연결하여 저장한다.</li><li>연결리스트를 사용하기 때문에 삽입 삭제가 용이하다.</li><li>테이블 크기는 동적 메모리할당을 통해 해결이 가능하지만 추가적인 메모리 공간이 요구된다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 해시 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL트리</title>
      <link href="/08/05/20210805-AVLtree/"/>
      <url>/08/05/20210805-AVLtree/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL-트리"><a href="#AVL-트리" class="headerlink" title="AVL 트리"></a>AVL 트리</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>‘AVL 트리’는 균형이 갖춰진 이진 트리이다.</li><li>균형을 갖추기 위해 회전(Rotation)을 통해 재구성할 수 있다.<blockquote><p>균형 </p><ul><li>균형 인수가 -1, 0, +1 인 상태</li></ul></blockquote></li></ul><blockquote><p>균형 인수</p><ul><li>왼쪽 자식의 높이 - 오른쪽 자식의 높이</li></ul></blockquote><h2 id="불균형-상태"><a href="#불균형-상태" class="headerlink" title="불균형 상태"></a>불균형 상태</h2><h3 id="LL-형식"><a href="#LL-형식" class="headerlink" title="LL 형식"></a>LL 형식</h3><ul><li>노드가 Left1-Left2로 편향되어 있는 상태<h4 id="재구성"><a href="#재구성" class="headerlink" title="재구성"></a>재구성</h4></li><li>결과적으로 편향된 노드들을 가진 노드(2)를 root가 된다.</li></ul><ol><li>노드(2)가 가지고있던 오른쪽 자식 노드들을 root(1)의 왼쪽 자식 노드로 설정한다.</li><li>기존의 root(1)는 노드(2)의 오른쪽 자식 노드로 설정한다.</li></ol><h3 id="RR-형식"><a href="#RR-형식" class="headerlink" title="RR 형식"></a>RR 형식</h3><ul><li>노드가 Right1-Right2로 편향되어 있는 상태<h4 id="재구성-1"><a href="#재구성-1" class="headerlink" title="재구성"></a>재구성</h4></li><li>LL형식의 재구성 방식을 반대로 수행한다.</li></ul><ol><li>편향된 노드의 왼쪽 자식 노드를 root의 오른쪽 노드로 설정한다.</li><li>편향된 노드의 왼쪽 자식 노드를 root로 설정한다.</li></ol><h3 id="LR-형식"><a href="#LR-형식" class="headerlink" title="LR 형식"></a>LR 형식</h3><ul><li>노드가 Left1-Right1로 편향되어 있는 상태</li></ul><ol><li>편향된 노드에 RR회전을 수행하여 불균형 노드를 왼쪽으로 몰아 넣는다.</li><li>몰아넣은 노드에 LL회전을 수행한다.</li></ol><h3 id="RL-형식"><a href="#RL-형식" class="headerlink" title="RL 형식"></a>RL 형식</h3><ul><li>노드가 Right1-Left1로 편향되어 있는 상태</li></ul><ol><li>편향된 노드에 LL회전을 수행하여 불균형 노드를 오른쪽으로 몰아 넣는다.</li><li>몰아넣은 노드에 RR회전을 수행한다.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> AVL트리 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>이진 탐색 트리</title>
      <link href="/08/05/20210805-BinarySearchTree/"/>
      <url>/08/05/20210805-BinarySearchTree/</url>
      
        <content type="html"><![CDATA[<h1 id="이진-탐색-트리-Binary-Search-Tree"><a href="#이진-탐색-트리-Binary-Search-Tree" class="headerlink" title="이진 탐색 트리 (Binary Search Tree)"></a>이진 탐색 트리 (Binary Search Tree)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>이진 탐색 트리에서 부모 노드는 왼쪽 자식 노드보다는 크고 오른쪽 자식 노드보다는 작다<blockquote><p>값의 크기 비교 : 왼쪽 자식 노드 &lt; 부모 노드 &lt; 오른쪽 자식 노드</p></blockquote></li><li>탐색 속도를 극대화할 수 있는 구조이다.</li><li>한 번 확인할 때 마다 탐색할 노드의 개수가 절반씩 줄어든다.</li><li>완전 이진 탐색 트리에서 실행할 경우 O(logN)의 시간복잡도를 가진다.</li></ul><h2 id="탐색"><a href="#탐색" class="headerlink" title="탐색"></a>탐색</h2><ul><li>트리 내의 데이터를 탐색한다.</li><li>탐색하고 싶은 노드를 부모 노드와 비교한다.<blockquote><p>부모 노드보다 클 경우 </p><ul><li>오른쪽 자식 노드에 포함되므로 오른쪽으로 이동한다.</li></ul></blockquote></li></ul><blockquote><p>부모 노드보다 작을 경우 </p><ul><li>왼쪽 자식 노드에 포함되므로 왼쪽으로 이동한다.</li></ul></blockquote><h2 id="삽입"><a href="#삽입" class="headerlink" title="삽입"></a>삽입</h2><ul><li>삽입하고 싶은 데이터를 부모 노드와 비교하여 탐색 프로세스와 같이 이동하며 적절한 위치에 값을 삽입한다.</li></ul><h2 id="삭제"><a href="#삭제" class="headerlink" title="삭제"></a>삭제</h2><ol><li>자식 노드가 없는 노드의 삭제</li></ol><ul><li>데이터를 탐색하여 삭제한다.</li></ul><ol start="2"><li>1개의 자식 노드가 있는 노드의 삭제</li></ol><ul><li>삭제할 노드의 자리에 자식 노드를 삽입한다.</li></ul><ol start="3"><li>2개의 자식 노드가 있는 노드의 삭제</li></ol><ul><li>삭제할 노드 다음으로 큰 노드를 삭제할 노드의 위치에 삽입한다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 이진 탐색 트리 </tag>
            
            <tag> 이진 트리 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>그래프 탐색</title>
      <link href="/08/05/20210805-DFS/"/>
      <url>/08/05/20210805-DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="그래프-탐색"><a href="#그래프-탐색" class="headerlink" title="그래프 탐색"></a>그래프 탐색</h1><h2 id="깊이-우선-탐색-Depth-First-Search"><a href="#깊이-우선-탐색-Depth-First-Search" class="headerlink" title="깊이 우선 탐색 (Depth First Search)"></a>깊이 우선 탐색 (Depth First Search)</h2><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li>깊은 것을 우선적으로 탐색한다. </li><li>전체 노드를 탐색하며, 모든 경우의 수를 탐색한다.</li><li>스택 자료구조에 기초하며, O(N)이 소요된다.</li></ul><h3 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h3><ul><li>모든 노드는 탐색되지 않은 상태임을 가정</li><li>스택에 삽입되면 탐색이 완료된 것으로 간주한다.</li></ul><ol><li>탐색을 시작할 노드를 스택에 삽입(탐색)한다.</li><li>시작 노드와 인접한 노드를 순차적으로 스택에 삽입(탐색)한다.</li><li>더이상 인접한 노드가 없을 때는 스택에서 순차적으로 노드를 꺼낸다.</li></ol><h2 id="너비-우선-탐색-Breadth-First-Search"><a href="#너비-우선-탐색-Breadth-First-Search" class="headerlink" title="너비 우선 탐색 (Breadth First Search)"></a>너비 우선 탐색 (Breadth First Search)</h2><h3 id="특징-1"><a href="#특징-1" class="headerlink" title="특징"></a>특징</h3><ul><li>너비를 우선으로 하여 탐색을 수행한다.</li><li>전체 노드를 탐색하고, DFS보다 빠르다.</li><li>큐 자료구조에 기초하며, O(N)이 소요된다.</li><li>고급 그래프 탐색 알고리즘에서 자주 활용된다.  </li></ul><h3 id="구현-1"><a href="#구현-1" class="headerlink" title="구현"></a>구현</h3><ul><li>모든 노드는 탐색되지 않은 상태임을 가정</li><li>스택에 삽입되면 탐색이 완료된 것으로 간주한다.</li></ul><ol><li>탐색을 시작할 노드를 큐에 삽입한다.</li><li>삽입한 노드를 꺼내고, 인접 노드를 삽입한다.</li><li>2를 더이상 수행할 수 없을 때까지 반복한다.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> DFS </tag>
            
            <tag> 깊이 우선 탐색 </tag>
            
            <tag> BFS </tag>
            
            <tag> 너비 우선 탐색 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>그래프</title>
      <link href="/08/05/20210805-graph/"/>
      <url>/08/05/20210805-graph/</url>
      
        <content type="html"><![CDATA[<h1 id="그래프-Graph"><a href="#그래프-Graph" class="headerlink" title="그래프 (Graph)"></a>그래프 (Graph)</h1><ul><li>사물을 정점(Vertex)과 간선(Edge)로 나타내는 구조</li></ul><h2 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h2><blockquote><p>E : Edge (간선)<br>V : Vertex (정점)</p></blockquote><h3 id="무방향-비가중치-그래프"><a href="#무방향-비가중치-그래프" class="headerlink" title="무방향 비가중치 그래프"></a>무방향 비가중치 그래프</h3><ul><li>모든 노드의 연결여부를 확인하여야한다.</li><li>2차원 Matrix를 이용하여 확인하므로 O(V^2)이 소요되고, 값은 바로 확인할 수 있기 때문에 O(1)이 소요된다.<h4 id="인접-행렬-Adjacency-Matrix-을-이용한-구현"><a href="#인접-행렬-Adjacency-Matrix-을-이용한-구현" class="headerlink" title="인접 행렬(Adjacency Matrix)을 이용한 구현"></a>인접 행렬(Adjacency Matrix)을 이용한 구현</h4></li></ul><h3 id="방향-가중치-그래프"><a href="#방향-가중치-그래프" class="headerlink" title="방향 가중치 그래프"></a>방향 가중치 그래프</h3><ul><li>모든 간선이 방향을 가지고, 가중치를 가진 그래프</li><li>연결된 간선의 정보만 저장하기 때문에 공간은 O(E)가 소요되고, 노드만 확인하여 값을 확인하므로 O(V)가 소요된다.<h4 id="인접-리스트-Adjacency-List-를-이용한-구현"><a href="#인접-리스트-Adjacency-List-를-이용한-구현" class="headerlink" title="인접 리스트(Adjacency List)를 이용한 구현"></a>인접 리스트(Adjacency List)를 이용한 구현</h4></li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 그래프 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>탐색</title>
      <link href="/08/05/20210805-search/"/>
      <url>/08/05/20210805-search/</url>
      
        <content type="html"><![CDATA[<h1 id="탐색-Search"><a href="#탐색-Search" class="headerlink" title="탐색 (Search)"></a>탐색 (Search)</h1><h2 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h2><h3 id="순차-탐색-Sequential-Search"><a href="#순차-탐색-Sequential-Search" class="headerlink" title="순차 탐색 (Sequential Search)"></a>순차 탐색 (Sequential Search)</h3><ul><li>특정한 원소를 찾기위해 순차적으로 탐색을 수행한다.</li></ul><h3 id="이진-탐색-Binary-Search"><a href="#이진-탐색-Binary-Search" class="headerlink" title="이진 탐색 (Binary Search)"></a>이진 탐색 (Binary Search)</h3><ul><li>배열의 내부 데이터가 이미 정렬되어 있는 상황에서 사용한다.</li><li>탐색 범위를 절반씩 좁혀가며 탐색을 수행한다.<h4 id="구성"><a href="#구성" class="headerlink" title="구성"></a>구성</h4></li><li>start (가장 앞에 위치한 원소)</li><li>mid (중간에 위치한 원소)</li><li>end (가장 뒤에 위치한 원소)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 순차 탐색 </tag>
            
            <tag> 이진 탐색 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>우선순위 큐</title>
      <link href="/08/05/20210805-priorityQueue/"/>
      <url>/08/05/20210805-priorityQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="우선순위-큐-Priority-Queue"><a href="#우선순위-큐-Priority-Queue" class="headerlink" title="우선순위 큐 (Priority Queue)"></a>우선순위 큐 (Priority Queue)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>우선 순위를 가진 데이터를 저장하는 큐</li><li>데이터 추출 시 우선순위가 높은 데이터가 추출된다.</li><li>OS의 스케줄링, 정렬, 네트워크 관리 등에 이용된다.</li></ul><h2 id="비교"><a href="#비교" class="headerlink" title="비교"></a>비교</h2><h3 id="큐-Queue"><a href="#큐-Queue" class="headerlink" title="큐 (Queue)"></a>큐 (Queue)</h3><ul><li>선형구조 및 FIFO 구조를 가진다.</li></ul><h3 id="우선순위-큐-Priority-Queue-1"><a href="#우선순위-큐-Priority-Queue-1" class="headerlink" title="우선순위 큐 (Priority Queue)"></a>우선순위 큐 (Priority Queue)</h3><ul><li>트리 구조와 유사하며, 최대 힙으로 구현한다.</li></ul><blockquote><p>최대힙 구조</p><ul><li>힙은 항상 완전 이진 트리 구조여야 한다.</li><li>부모 노드가 항상 자식노드보다 큰 값을 가진 구조</li><li>root가 최대 값을 가진다.</li></ul></blockquote><h2 id="데이터-삽입"><a href="#데이터-삽입" class="headerlink" title="데이터 삽입"></a>데이터 삽입</h2><ul><li>전체 트리가 최대힙 구조를 유지하도록 코딩할 수 있다.</li><li>삽입하는 원소는 완전 이진 트리를 유지하는 형태로 삽입한다.</li><li>삽입 후에 자식 노드보다 크고, 부모 노드보다 작을 때 까지 상향식 이동을 한다.</li></ul><h2 id="데이터-삭제"><a href="#데이터-삭제" class="headerlink" title="데이터 삭제"></a>데이터 삭제</h2><ul><li>데이터를 삭제할 때는 root를 삭제해준다.</li><li>마지막에 위치하던 노드를 root로 이동시킨다.</li><li>삭제 후에 부모 노드보다 작고, 자식 노드보다 클 때 까지 하향식으로 이동한다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 큐 </tag>
            
            <tag> 우선순위 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>이진 트리</title>
      <link href="/08/04/20210804-BinaryTree/"/>
      <url>/08/04/20210804-BinaryTree/</url>
      
        <content type="html"><![CDATA[<h1 id="이진트리-Binary-Tree"><a href="#이진트리-Binary-Tree" class="headerlink" title="이진트리 (Binary Tree)"></a>이진트리 (Binary Tree)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>일반적인 트리는 한 개의 노드가 여러 개의 자식 노드를 가질 수 있다.</li><li>이진 트리는 노드 1개 당 최대 2개의 자식 노드를 가질 수 있다.</li></ul><h2 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h2><h3 id="포화-이진트리-Full-Binary-Tree"><a href="#포화-이진트리-Full-Binary-Tree" class="headerlink" title="포화 이진트리 (Full Binary Tree)"></a>포화 이진트리 (Full Binary Tree)</h3><ul><li>리프 노드(최하단 노드)를 제외한 모든 노드가 2개의 자식 노드를 가진 구조.</li></ul><h3 id="완전-이진트리-Complete-Binary-Tree"><a href="#완전-이진트리-Complete-Binary-Tree" class="headerlink" title="완전 이진트리 (Complete Binary Tree)"></a>완전 이진트리 (Complete Binary Tree)</h3><ul><li>왼쪽 노드부터 점진적으로 채워진 구조</li></ul><h3 id="높이-균형-트리-Height-Balanced-Tree"><a href="#높이-균형-트리-Height-Balanced-Tree" class="headerlink" title="높이 균형 트리 (Height Balanced Tree)"></a>높이 균형 트리 (Height Balanced Tree)</h3><ul><li>왼쪽, 오른쪽 트리의 높이의 차이가 1이하인 트리</li></ul><h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><h2 id="순회"><a href="#순회" class="headerlink" title="순회"></a>순회</h2><ul><li>전, 중, 후를 root의 순서로 보면 이해하기 쉽다.</li></ul><h3 id="전위순회-Preorder"><a href="#전위순회-Preorder" class="headerlink" title="전위순회 (Preorder)"></a>전위순회 (Preorder)</h3><ul><li>순서 : root -&gt; 왼쪽 노드-&gt; 오른쪽 노드</li></ul><h3 id="중위순회-Inorder"><a href="#중위순회-Inorder" class="headerlink" title="중위순회 (Inorder)"></a>중위순회 (Inorder)</h3><ul><li>순서 : 왼쪽 노드 -&gt; root -&gt; 오른쪽 노드</li></ul><h3 id="후위순회-Postorder"><a href="#후위순회-Postorder" class="headerlink" title="후위순회 (Postorder)"></a>후위순회 (Postorder)</h3><ul><li>순서 : 왼쪽 노드 -&gt; 오른쪽 노드 -&gt; root</li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 트리 </tag>
            
            <tag> 이진트리 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>계수 및 기수 정렬</title>
      <link href="/08/04/20210804-til5/"/>
      <url>/08/04/20210804-til5/</url>
      
        <content type="html"><![CDATA[<h1 id="계수-정렬-Counting-Sort"><a href="#계수-정렬-Counting-Sort" class="headerlink" title="계수 정렬 (Counting Sort)"></a>계수 정렬 (Counting Sort)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>데이터의 크기가 한정적일 때 사용한다.</li><li>데이터를 읽어나가면서 바로 정렬한다</li><li>시간복잡도 : O(N)</li></ul><h1 id="기수-정렬-Radix-Sort"><a href="#기수-정렬-Radix-Sort" class="headerlink" title="기수 정렬 (Radix Sort)"></a>기수 정렬 (Radix Sort)</h1><h2 id="특징-1"><a href="#특징-1" class="headerlink" title="특징"></a>특징</h2><ul><li>자리 수를 기준으로 차례대로 데이터를 정렬한다.</li><li>자리 수는 가장 큰 값의 자리수를 기준으로 한다.</li><li>예시 ) 가장 큰 값 : 345 (1, 10, 100의 자리)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 계수정렬 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>퀵 정렬</title>
      <link href="/08/04/20210804-til4/"/>
      <url>/08/04/20210804-til4/</url>
      
        <content type="html"><![CDATA[<h1 id="퀵-정렬-Quick-Sort"><a href="#퀵-정렬-Quick-Sort" class="headerlink" title="퀵 정렬 (Quick Sort)"></a>퀵 정렬 (Quick Sort)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>C++ Algorithm 라이브러리에서 sort()를 통해 사용할 수 있다.</li><li>피벗을 기준으로 큰 값, 작은 값을 교체한다.</li><li>완전 이진 트리와 흡사한 형태를 가진다.</li></ul><h2 id="퀵정렬을-통한-오름차순-구현"><a href="#퀵정렬을-통한-오름차순-구현" class="headerlink" title="퀵정렬을 통한 오름차순 구현"></a>퀵정렬을 통한 오름차순 구현</h2><h3 id="순서"><a href="#순서" class="headerlink" title="순서"></a>순서</h3><ul><li>피벗 : 가장 왼쪽에 위치한 값이라 가정</li><li>start : 피벗 다음에 위치한 값</li><li>end : 가장 오른쪽에 위치한 값<blockquote><ol><li>start : 앞에서부터 뒤로 이동하며 피벗보다 큰 값을 찾음</li><li>end : 뒤에서 앞으로 이동하며 피벗보다 작은 값을 찾음</li><li>start와 end가 엇갈리는 시점에서 작은 값과 피벗을 교체함</li><li>피벗을 기준으로 왼쪽, 오른쪽에서 다시 퀵정렬을 수행한다.</li></ol></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 퀵정렬 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>선택 및 삽입 정렬</title>
      <link href="/08/04/20210804-til3/"/>
      <url>/08/04/20210804-til3/</url>
      
        <content type="html"><![CDATA[<h1 id="선택-정렬-Selection-Sort"><a href="#선택-정렬-Selection-Sort" class="headerlink" title="선택 정렬 (Selection Sort)"></a>선택 정렬 (Selection Sort)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>가장 작은 것을 선택해서 앞으로 보냄</li><li>시간복잡도 : 가장 작은 데이터 선택 (N) * 앞으로 보내기 (N) = O(N^2)</li></ul><h1 id="삽입-정렬"><a href="#삽입-정렬" class="headerlink" title="삽입 정렬"></a>삽입 정렬</h1><h2 id="특징-1"><a href="#특징-1" class="headerlink" title="특징"></a>특징</h2><ul><li>각 숫자를 적절한 위치에 삽입</li><li>일반적으로 선택 정렬보다 빠르게 동작한다.</li><li>시간복잡도 : 들어갈 위치를 선택 (N) * 데이터를 선택하는 횟수 (N) = O(N^2)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 정렬 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>큐</title>
      <link href="/08/03/20210803-til2-md/"/>
      <url>/08/03/20210803-til2-md/</url>
      
        <content type="html"><![CDATA[<h1 id="큐-Queue"><a href="#큐-Queue" class="headerlink" title="큐 (Queue)"></a>큐 (Queue)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><p><img src="/image/" alt="queue"></p><blockquote><ol><li>데이터가 뒤(rear)로 들어가서 앞(front)으로 나오는 자료</li></ol><ol start="2"><li>FIFO (First In First Out)</li></ol><ol start="3"><li>스케줄링, 탐색 알고리즘 등에서 사용된다.</li></ol></blockquote><h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><h3 id="배열로-구현"><a href="#배열로-구현" class="headerlink" title="배열로 구현"></a>배열로 구현</h3><h4 id="선언"><a href="#선언" class="headerlink" title="선언"></a>선언</h4><ul><li>배열은 사전에 배열의 크기를 지정해줘야한다.</li><li>front와 rear를 선언해준다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define SIZE 10000</span><br><span class="line">#define INF 99999999</span><br><span class="line"></span><br><span class="line">int queue[SIZE];</span><br><span class="line">int front = 0;</span><br><span class="line">int rear = 0;</span><br></pre></td></tr></table></figure><h4 id="삽입"><a href="#삽입" class="headerlink" title="삽입"></a>삽입</h4><ul><li>큐는 한 쪽으로만 데이터가 들어간다.</li><li>큐의 마지막인 rear에 1을 추가하여 데이터를 삽입해준다.</li><li>배열의 크기를 초과했을 때는 큐 오버플로우를 선언해준다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void push(int data) &#123;</span><br><span class="line">   if (rear &gt;= SIZE) &#123;</span><br><span class="line">      printf(&quot;큐 오버플로우가 발생했습니다. \n&quot;);</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   queue[rear++] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="삭제"><a href="#삭제" class="headerlink" title="삭제"></a>삭제</h4><ul><li>큐는 삽입과 같이 한 쪽에서만 데이터가 나온다.</li><li>큐의 front++를 return함으로써 front를 제거한다.</li><li>큐가 비어있을 때 시도하면 언더플로우를 선언한다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void pop() &#123;</span><br><span class="line">   if (front == rear) &#123;</span><br><span class="line">      printf(&quot;큐 언더플로우가 발생했습니다. \n&quot;);</span><br><span class="line">      return -INF;</span><br><span class="line">   &#125;</span><br><span class="line">   return queue[front++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>모든 코드 확인하기</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define SIZE 10000</span><br><span class="line">#define INF 99999999</span><br><span class="line"></span><br><span class="line">int queue[SIZE];</span><br><span class="line">int front = 0;</span><br><span class="line">int rear = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void push(int data) &#123;</span><br><span class="line">   if (rear &gt;= SIZE) &#123;</span><br><span class="line">      printf(&quot;큐 오버플로우가 발생했습니다. \n&quot;);</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   queue[rear++] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pop() &#123;</span><br><span class="line">   if (front == rear) &#123;</span><br><span class="line">      printf(&quot;큐 언더플로우가 발생했습니다. \n&quot;);</span><br><span class="line">      return -INF;</span><br><span class="line">   &#125;</span><br><span class="line">   return queue[front++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show() &#123;</span><br><span class="line">   printf(&quot;---큐의 앞--- \n&quot;);</span><br><span class="line">   for (int i = front; i &lt; rear; i++) &#123;</span><br><span class="line">      printf(&quot;%d\n&quot;, queue[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;---큐의 뒤--- \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">   push(7);</span><br><span class="line">   push(5);</span><br><span class="line">   push(1);</span><br><span class="line">   pop();</span><br><span class="line">   show();</span><br><span class="line">   system(&quot;pause&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="연결리스트로-구현"><a href="#연결리스트로-구현" class="headerlink" title="연결리스트로 구현"></a>연결리스트로 구현</h3><h4 id="선언-1"><a href="#선언-1" class="headerlink" title="선언"></a>선언</h4><ul><li>data와 노드와 다음 데이터를 연결하는 next를 구조에 포함한다.</li><li>데이터가 나오는 front, 들어가는 node, 데이터 수를 담을 count를 선언한다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define INF 99999999</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">   int data;</span><br><span class="line">   struct Node* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">   Node* front;</span><br><span class="line">   Node* rear;</span><br><span class="line">   int count;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h4 id="삽입-1"><a href="#삽입-1" class="headerlink" title="삽입"></a>삽입</h4><ul><li>새로운 node를 동적메모리에 할당해준다.</li><li>node에 데이터를 담고, next는 NULL로 초기화해준다.</li><li>조건문을 통해 큐에 데이터가 없을 시 front로 선언한다.</li><li>데이터가 존재할 시 큐의 rear가 node를 가리키게 한다.</li><li>큐의 rear를 node로 지정하고, count를 추가해준다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void push(Queue* queue, int data) &#123;</span><br><span class="line">   Node* node = (Node*)malloc(sizeof(Node));</span><br><span class="line">   node-&gt;data = data;</span><br><span class="line">   node-&gt;next = NULL;</span><br><span class="line">   if (queue-&gt;count == 0) &#123;</span><br><span class="line">      queue-&gt;front = node;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      queue-&gt;rear-&gt;next = node;</span><br><span class="line">   &#125;</span><br><span class="line">   queue-&gt;rear = node;</span><br><span class="line">   queue-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="삭제-1"><a href="#삭제-1" class="headerlink" title="삭제"></a>삭제</h4><ul><li>큐에 데이터가 없을 시 실행하면 언더플로우를 선언해준다.</li><li>큐의 front를 담을 노드를 생성하고, 데이터도 담아준다.</li><li>큐의 front를 위 노드의 next로 선언한다.</li><li>기존의 front 다음의 데이터가 front가 되는 것</li><li>원래의 front를 담고 있던 node를 해제해주고, count를 감소시킨다.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void pop(Queue* queue) &#123;</span><br><span class="line">   if (queue-&gt;count == 0) &#123;</span><br><span class="line">      printf(&quot;큐 언더플로우가 발생하였습니다. \n&quot;);</span><br><span class="line">      return -INF;</span><br><span class="line">   &#125;</span><br><span class="line">   Node* node = queue-&gt;front;</span><br><span class="line">   int data = node-&gt;data;</span><br><span class="line"></span><br><span class="line">   queue-&gt;front = node-&gt;next;</span><br><span class="line">   free(node);</span><br><span class="line">   queue-&gt;count--;</span><br><span class="line">   return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>모든 코드 확인하기</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define INF 99999999</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">   int data;</span><br><span class="line">   struct Node* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">   Node* front;</span><br><span class="line">   Node* rear;</span><br><span class="line">   int count;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line">void push(Queue* queue, int data) &#123;</span><br><span class="line">   Node* node = (Node*)malloc(sizeof(Node));</span><br><span class="line">   node-&gt;data = data;</span><br><span class="line">   node-&gt;next = NULL;</span><br><span class="line">   if (queue-&gt;count == 0) &#123;</span><br><span class="line">      queue-&gt;front = node;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      queue-&gt;rear-&gt;next = node;</span><br><span class="line">   &#125;</span><br><span class="line">   queue-&gt;rear = node;</span><br><span class="line">   queue-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pop(Queue* queue) &#123;</span><br><span class="line">   if (queue-&gt;count == 0) &#123;</span><br><span class="line">      printf(&quot;큐 언더플로우가 발생하였습니다. \n&quot;);</span><br><span class="line">      return -INF;</span><br><span class="line">   &#125;</span><br><span class="line">   Node* node = queue-&gt;front;</span><br><span class="line">   int data = node-&gt;data;</span><br><span class="line"></span><br><span class="line">   queue-&gt;front = node-&gt;next;</span><br><span class="line">   free(node);</span><br><span class="line">   queue-&gt;count--;</span><br><span class="line">   return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(Queue* queue) &#123;</span><br><span class="line">   Node* cur = queue-&gt;front;</span><br><span class="line">   printf(&quot;---큐의 앞---\n&quot;);</span><br><span class="line">   while (cur != NULL) &#123;</span><br><span class="line">      printf(&quot;%d\n&quot;, cur-&gt;data);</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;---큐의 뒤---&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">   Queue queue;</span><br><span class="line">   queue.front = queue.rear = NULL;</span><br><span class="line">   queue.count = 0;</span><br><span class="line">   push(&amp;queue, 7);</span><br><span class="line">   push(&amp;queue, 5);</span><br><span class="line">   push(&amp;queue, 4);</span><br><span class="line">   pop(&amp;queue);</span><br><span class="line">   push(&amp;queue, 6);</span><br><span class="line">   pop(&amp;queue);</span><br><span class="line">   show(&amp;queue);</span><br><span class="line">   system(&quot;pause&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 큐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>연결리스트</title>
      <link href="/07/30/20210730-til1/"/>
      <url>/07/30/20210730-til1/</url>
      
        <content type="html"><![CDATA[<h1 id="연결리스트-Linked-List"><a href="#연결리스트-Linked-List" class="headerlink" title="연결리스트 (Linked List)"></a>연결리스트 (Linked List)</h1><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><blockquote><ol><li>데이터를 선형적으로 저장 및 처리한다.</li></ol><ol start="2"><li>삽입과 삭제가 많은 경우 효율적이다.</li></ol><ol start="3"><li>리스트의 중간 지점에 노드의 추가/삭제가 가능하여야 한다.</li></ol><ol start="4"><li>메모리 공간을 미리 할당하는 배열을 보완하여 공간 낭비를 감소시킨다.</li></ol></blockquote><p>✚ 배열 기반의 리스트</p><ul><li><p>장점 : 즉시 접근이 가능하다.</p></li><li><p>단점 : 삽입 삭제가 비효율적이며 메모리 공간을 미리 할당한다.</p></li></ul><h2 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h2><h3 id="단일-연결리스트"><a href="#단일-연결리스트" class="headerlink" title="단일 연결리스트"></a>단일 연결리스트</h3><p><img src="/image/single.PNG" alt="one-way-list"></p><ul><li><p>단일 연결리스트는 가장 앞의 노드를 가르키는 HEAD를 갖는다.</p></li><li><p>각 노드별로 동적 메모리를 할당하여야 하며, 각 노드를 연결시켜주어야 한다.</p></li></ul><p>####︎︎ 노드 삽입<br><img src="/image/push.PNG" alt="push"></p><ul><li><p>HEAD 다음에 노드를 삽입한다고 가정</p></li><li><p>‘HEAD의 *next’가 ‘삽입 노드의 값’을 가리키게 한다.</p></li><li><p>‘삽입 노드의 *next’가 ‘기존 노드의 값’을 가리키게 한다.</p></li></ul><h4 id="노드-삭제"><a href="#노드-삭제" class="headerlink" title="노드 삭제"></a>노드 삭제</h4><p><img src="/image/pop.PNG" alt="pop"></p><ul><li><p>HEAD 다음에 위치한 노드를 삭제한다고 가정</p></li><li><p>‘HEAD의 *next’가 ‘삭제될 노드의 다음 값’을 가리키게 한다.</p></li><li><p>삭제된 노드의 동적 메모리를 해제하여 메모리 누수를 방지한다.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 자료구조 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 자료구조 </tag>
            
            <tag> 알고리즘 </tag>
            
            <tag> 리스트 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
