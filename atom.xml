<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fintech - Backend Developer</title>
  
  <subtitle>Inwoo Jeong</subtitle>
  <link href="http://inwoo.github.io/atom.xml" rel="self"/>
  
  <link href="http://inwoo.github.io/"/>
  <updated>2022-02-24T07:35:13.945Z</updated>
  <id>http://inwoo.github.io/</id>
  
  <author>
    <name>Inwoo Jeong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 스토리지 엔진과 트랜잭션</title>
    <link href="http://inwoo.github.io/02/23/mysqlEngine/"/>
    <id>http://inwoo.github.io/02/23/mysqlEngine/</id>
    <published>2022-02-23T08:41:41.000Z</published>
    <updated>2022-02-24T07:35:13.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><!-- excerpt --><h2 id="데이터베이스-엔진이란"><a href="#데이터베이스-엔진이란" class="headerlink" title="데이터베이스 엔진이란?"></a>데이터베이스 엔진이란?</h2><p><strong>데이터베이스 엔진</strong> 혹은 <strong>스토리지 엔진</strong>은 DBMS가 데이터베이스에 CRUD 작업을 할 때 사용되는 기본 <code>소프트웨어 컴포넌트</code>입니다.</p><blockquote><p>DB에서 데이터에 <strong>어떠한 방식으로 접근, 저장</strong>할 것인지에 대한 기능을 제공</p><p><strong>스토리지 엔진의 특성에 따라서 접근 속도, 안정성, 트랙잭션 등의 기능의 차이점이 발생한다</strong></p></blockquote><p><code>데이터베이스 서버</code>, <code>데이터베이스 관리 시스템(DBMS)</code>라고도 불리기도 하는 데이터 베이스 엔진을 조작하는 방법은 2가지가 있습니다.</p><ol><li>DBMS 고유의 사용자 인터페이스 이용</li><li>포트 번호를 통한 조작</li></ol><p>대부분의 DBMS는 1번 방법(사용자 인터페이스 이용) 외에 사용자가 <strong>내장된 엔진과 상호작용</strong>을 할 수 있는 API를 가지고 있습니다.<br>또한 동일한 DB 내에 다중 저장엔진을 지원하기도 합니다.</p><details><summary>저장 엔진의 종류</summary><table><thead><tr><th>저장엔진</th><th>트랜잭션 지원 여부</th></tr></thead><tbody><tr><td>Aria</td><td>X</td></tr><tr><td>BlitzDB</td><td>X</td></tr><tr><td>Falcon</td><td>O</td></tr><tr><td>InnoDB</td><td>O</td></tr><tr><td>MyISAM</td><td>X</td></tr><tr><td>InfiniDB</td><td>X</td></tr><tr><td>TokuDB</td><td>O</td></tr><tr><td>XtraDB</td><td>O</td></tr></tbody></table></details><hr><h2 id="MySQL-구조"><a href="#MySQL-구조" class="headerlink" title="MySQL 구조"></a>MySQL 구조</h2><h3 id="MySQL-서버-MySQL-엔진-스토리지-엔진"><a href="#MySQL-서버-MySQL-엔진-스토리지-엔진" class="headerlink" title="MySQL 서버 = MySQL 엔진 + 스토리지 엔진"></a>MySQL 서버 = MySQL 엔진 + 스토리지 엔진</h3><p><code>MySQL 엔진</code>은 클라이언트의 요청을 처리하고</p><ul><li>SQL 문장 분석</li><li>최적화 등</li></ul><p><code>스토리지 엔진</code>은 실제 데이터를 스토리지에 저장, 조회하는 부분을 담당한다.</p><h4 id="MySQL-엔진"><a href="#MySQL-엔진" class="headerlink" title="MySQL 엔진"></a>MySQL 엔진</h4><ul><li>Connection Handler : 커넥션, 쿼리 요청 처리</li><li>SQL Interface : DML, DDL, View, Procedure 등 인터페이스 제공</li><li>SQL parser : syntax 검사, 쿼리 문장을 토큰 단위로 구분하여 트리 형태로 파싱</li><li>SQL Optimizer : 쿼리의 최적화 실행 담당</li><li>캐시와 버퍼 : 성능 향상을 위한 보조 저장소</li></ul><h4 id="스토리지-엔진"><a href="#스토리지-엔진" class="headerlink" title="스토리지 엔진"></a>스토리지 엔진</h4><ul><li>MySQL 엔진과 <code>plugin</code> 형태도 연동이 가능하다</li><li>Handler API를 통해 스토리지 엔진에 CRUD 요청이 가능하다.</li></ul><hr><h2 id="MySQL-스토리지-엔진의-종류-및-특징"><a href="#MySQL-스토리지-엔진의-종류-및-특징" class="headerlink" title="MySQL 스토리지 엔진의 종류 및 특징"></a>MySQL 스토리지 엔진의 종류 및 특징</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>MySQL은 데이터베이스(schema)를 <code>파일 시스템</code> 안의 <code>데이터 디렉토리</code>의 <code>하위 디렉토리</code>로 설정합니다.</p><p>테이블을 생성하게 되면 <code>테이블명.frm</code> 파일을 생성하고, 파일 내부에 테이블 정보를 저장합니다.</p><blockquote><p>Database 이름과 테이블 정의를 저장할 때 파일 시스템을 사용하므로, OS에 따라 대/소문자 구분 여부가 달라집니다.</p><p>윈도우 : 대/소문자 구분 없음</p><p>UNIX 계열 : 대/소문자를 구분한다</p></blockquote><h3 id="스토리지-엔진-1"><a href="#스토리지-엔진-1" class="headerlink" title="스토리지 엔진"></a>스토리지 엔진</h3><p><code>테이블의 정의</code>는 <code>서버</code>에서 담당하고,</p><p>테이블의 <code>데이터와 인덱스</code> 저장방식은 <code>스토리지 엔진</code>에 따라 달라집니다.</p><p><code>SHOW TABLE STATUS</code> 명령어를 통해 특정 테이블이 어떠한 스토리지 엔진을 사용하는지 확인할 수 있습니다.</p><img src="/image/tablestatus.png" class="fancybox center clear" title="Table Status"><details><summary>주요 컬럼 확인하기</summary><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>Name</td><td>테이블 이름</td></tr><tr><td>Engine</td><td>테이블에 적용된 스토리지 엔진</td></tr><tr><td>Row_format</td><td>레코드 포멧. MyISAM 테이블은 Dynamic(동적), Fixed(고정), Compressed(압축)의 형식을 취할 수 있다. Dynamic(동적) 레코드 : VARCHAR, BLOB 등 길이가 다양하다. Fixed 레코드는 CHAR 이나 INTEGER처럼 길이가 변하지 않고 고정된 칼럼으로 구성된다.</td></tr><tr><td>Rows</td><td>테이블 내 행의 개수. 비-트랜잭션 테이블에서는 정확한 값이지만, 트랜잭션 테이블에서는 주로 추정 값으로 나온다</td></tr><tr><td>Avg_row_length</td><td>행의 평균 바이트 수</td></tr><tr><td>Data_length</td><td>전체 테이블의 데이터량 (Byte)</td></tr><tr><td>Max_data_length</td><td>테이블이 가질 수 있는 최대 데이터량</td></tr><tr><td>Index_length</td><td>인덱스 데이터의 디스크 공간 소비량</td></tr><tr><td>Data_free</td><td>MyISAM 테이블에 할당되었으나 아직 사용하지 않은 공간. 이전에 삭제된 행이 남아있으며 나중에 INSERT 구문이 실행될 때 재사용될 수 있다.</td></tr><tr><td>Auto_increment</td><td>Id를 위한 다음 AUTO INCREMENT 값</td></tr><tr><td>Create_time</td><td>테이블이 처음 생성된 시간</td></tr><tr><td>Update_time</td><td>데이터가 마지막으로 갱신된 시간</td></tr><tr><td>Check_time</td><td>테이블이 <code>CHECK TABLE</code>이나 <code>myisamchk</code>를 사용하여 마지막으로 검사된 시기</td></tr><tr><td>Collation</td><td>테이블 내 캐릭터 레코드의 기본 Character Set 과 Collations</td></tr><tr><td>Checksum</td><td>테이블 전체 콘텐츠의 유효한 체크섬 값</td></tr><tr><td>Create_options</td><td>테이블 생성 시에 지정된 별도 옵션</td></tr><tr><td>Comment</td><td>이 필드는 다양한 부수 정보를 갖는다. MyISAM : 테이블이 생성되었을 때 설정된 주석을 갖는다. InnoDB 스토리지 엔진 : InnoDB 테이블 스페이스에 있는 빈 공간에 대한 정보가 여기에 나온다. 테이블이 뷰라면 이 필드에는 ‘VIEW’라는 문자가 있을 것이다.</td></tr></tbody></table></details><hr><blockquote><h3 id="InnoDB-엔진"><a href="#InnoDB-엔진" class="headerlink" title="InnoDB 엔진"></a>InnoDB 엔진</h3></blockquote><p>InnoDB 엔진은 <code>트랜잭션을 처리</code>하기 위해 고안되었다. 대부분의 케이스는 정상 종료되는 짧은 트랜잭션이 많은 상황을 처리하기 좋다.</p><ul><li>가장 많이 사용되는 스토리지 엔진 중 하나</li><li>ACID 트랜잭션 지원</li><li>성능, 장애 복구 기능</li><li>클러스터 인덱스 위에 구성되어 있다<ul><li>다른 MySQL 스토리지 엔지의 인덱스 구조와는 상이함</li><li>신속한 PK 조회 가능</li></ul></li><li>PK가 커지면 인덱스 또한 커지므로, 테이블이 여러 인덱스를 가진다면 기본키가 작은 값을 갖게 해야한다.</li></ul><details><summary>InnoDB의 특징 자세히 살펴보기</summary><blockquote><h4 id="PK에-의한-클러스터링"><a href="#PK에-의한-클러스터링" class="headerlink" title="PK에 의한 클러스터링"></a>PK에 의한 클러스터링</h4><p>모든 테이블은 기본적으로 <code>PK를 기준으로 클러스터링</code> 되어 저장된다.</p></blockquote><p>키 값 순서대로 Disk에 저장이 되고, PK에 의한 range 스캔은 빨리 처리도리 수 있다.</p><blockquote><h4 id="Lock이-필요-없는-읽기-작업"><a href="#Lock이-필요-없는-읽기-작업" class="headerlink" title="Lock이 필요 없는 읽기 작업"></a>Lock이 필요 없는 읽기 작업</h4><p>MVCC(Multi Version Concurrency Control) 기술을 통해 다른 트랜잭션이 가지고 있는 Lock 기다리지 않고 읽기 작업을 수행한다.</p></blockquote><blockquote><h4 id="ForeignKey-지원"><a href="#ForeignKey-지원" class="headerlink" title="ForeignKey 지원"></a>ForeignKey 지원</h4><p>InnoDB 스토리지 엔진 레벨에서 지원하고, <code>MyISAM</code>, <code>MEMORY</code> 테이블에서는 사용할 수 없다.</p></blockquote><blockquote><h4 id="자동-데드락-감지"><a href="#자동-데드락-감지" class="headerlink" title="자동 데드락 감지"></a>자동 데드락 감지</h4><p>그래프 기반의 데드락 체크 방식을 사용하여 <code>발생과 동시에 감지</code>된다.</p></blockquote><p>감지된 데드락은 관련 transaction 중 <code>ROLLBACK</code>이 가장 용이한 트랜잭션을 자동으로 강제 종료한다.</p><blockquote><h4 id="자동화된-장애-복구"><a href="#자동화된-장애-복구" class="headerlink" title="자동화된 장애 복구"></a>자동화된 장애 복구</h4><p>손실, 장애로부터 데이터를 보호하기 위한 매커니즘이 탑재되어 있고,<br>MySQL <code>서버가 시작될 때</code> 완료되지 못한 트랜잭션이나, 디스크에 일부만 기록된 트랜잭션 등에 대한 <code>일련의 복구작업이 자동으로 진행</code>된다.</p></blockquote><blockquote><h4 id="오라클의-아키텍처-적용"><a href="#오라클의-아키텍처-적용" class="headerlink" title="오라클의 아키텍처 적용"></a>오라클의 아키텍처 적용</h4></blockquote><ul><li>Lock을 기다리지 않고 조회를 하는 MVCC 기능</li><li>테이블 스페이스 개념 등<ul><li>Undo 데이터가 시스템 테이블 스페이스에 관리</li></ul></li></ul></details><hr><blockquote><h3 id="MyISAM-엔진"><a href="#MyISAM-엔진" class="headerlink" title="MyISAM 엔진"></a>MyISAM 엔진</h3><p>색인 순차 접근 방식(Indexed Sequential Access Method, ISAM)은 빠른 데이터 검색을 위한 파일 시스템 구조이다.</p></blockquote><h4 id="아래와-같은-유용한-기능을-제공하지만-트랜잭션이나-Row-수준의-잠금을-지원하지-않는다"><a href="#아래와-같은-유용한-기능을-제공하지만-트랜잭션이나-Row-수준의-잠금을-지원하지-않는다" class="headerlink" title="아래와 같은 유용한 기능을 제공하지만 트랜잭션이나 Row 수준의 잠금을 지원하지 않는다."></a>아래와 같은 유용한 기능을 제공하지만 트랜잭션이나 Row 수준의 잠금을 지원하지 않는다.</h4><ul><li>전문(full-text) 인덱싱 </li><li>압축</li><li>지리 관련 공간 함수 등 제공</li></ul><h4 id="Transaction을-지원하지-않기-때문에-InnoDB에-비해-심플하고-빠르지만-동시성-제어가-어렵다"><a href="#Transaction을-지원하지-않기-때문에-InnoDB에-비해-심플하고-빠르지만-동시성-제어가-어렵다" class="headerlink" title="Transaction을 지원하지 않기 때문에 InnoDB에 비해 심플하고 빠르지만, 동시성 제어가 어렵다."></a>Transaction을 지원하지 않기 때문에 InnoDB에 비해 심플하고 빠르지만, 동시성 제어가 어렵다.</h4><ul><li>Read 쿼리가 많은 DW(Data Warehousing) 환경에서 많이 사용된다.</li></ul><p>각 테이블을 데이터 파일(.MYD), 인덱스 파일(.MYI) 두 곳에 주로 저장한다. MyISAM 테이블은 정적, 동적인 행을 모두 가질 수 있으며, 테이블 정의를 토대로 하여 사용할 포맷을 결정한다.</p><details><summary>MyISAM의 특징 자세히 살펴보기</summary><blockquote><h4 id="Key-Cache"><a href="#Key-Cache" class="headerlink" title="Key Cache"></a>Key Cache</h4><p>InnoDB의 버퍼풀과 비슷한 역할을 하지만, <code>인덱스를 대상으로만 작동</code>하며,<br><code>인덱스의 디스크 쓰기 작업</code>에 대해서만 부분적으로 버퍼링 역할을 해준다.</p></blockquote><blockquote><h4 id="Lock과-동시성"><a href="#Lock과-동시성" class="headerlink" title="Lock과 동시성"></a>Lock과 동시성</h4><p>MyISAM은 행단위가 아닌 <code>테이블 전체</code>에 Lock을 건다.</p></blockquote><ul><li>읽기 동작 : 읽는 모든 테이블에 대한 공유된 읽기 권한</li><li>쓰기 동작 : 배타적 쓰기 잠금 권한</li></ul><p>SELECT 쿼리 실행 중에도 테이블에 새 행을 삽입(동시 삽입)할 수 있다.</p><blockquote><h4 id="수동-복구"><a href="#수동-복구" class="headerlink" title="수동 복구"></a>수동 복구</h4><p><code>CHECK TABLE 테이블명</code>, <code>REPAIR TABLE 테이블명</code> 명령어를 통해서 오류를 조사하고, 복구할 수 있다.</p></blockquote><p><code>myisamchk</code>(MyISAM Check) 명령어를 사용하면 서버가 오프라인일 때도 테이블을 조사하고 복구할 수 있다.</p><blockquote><h4 id="지연된-Key-쓰기"><a href="#지연된-Key-쓰기" class="headerlink" title="지연된 Key 쓰기"></a>지연된 Key 쓰기</h4><p>테이블을 생성할 때 <code>DELAY_KEY_WRITE</code>(지연된 Key 쓰기) 옵션을 ON으로 설정하면<br>해당 테이블은 <code>마지막에 변경된 데이터</code>를 Disk에 쓰지 않고, <code>메모리상의 버퍼</code>에 버퍼링한다.</p></blockquote><p>버퍼를 정리하거나, 테이블을 닫을 때 flush 해준다. 이용 빈도가 높고, 변경이 잦은 테이블의 성능 향상에 도움이 된다.</p><p>하지만 버퍼링을 하기 때문에 conflict가 발생했을 때 손상되므로 복구 작업이 필요하다.<br>    - 해결 방법<br>        - <code>myisamchk</code>를 실행하는 자동 script<br>        - 자동 복구옵션 사용 </p></details><hr><blockquote><h3 id="Memory-엔진"><a href="#Memory-엔진" class="headerlink" title="Memory 엔진"></a>Memory 엔진</h3><p>메모리에 데이터를 저장하는 엔진으로, Transaction을 지원하지 않고 table-level의 잠금을 사용한다.</p></blockquote><p>HEAP 테이블이라 불리던 메모리 테이블은 <code>변하지 않는 데이터</code>나<br><code>재시작 이후 지속되지 않는 데이터</code>에 빠르게 접근하는데 유용하다</p><ul><li>메모리를 사용하여 속도가 빠르다 (I/O 작업을 기다릴 필요가 없다)</li><li>데이터를 잃어버릴 위험이 있다</li><li>임시 테이블로 많이 사용된다</li><li>서버 재 시작 시 <ul><li>테이블 구조는 지속</li><li>데이터는 삭제</li></ul></li></ul><h4 id="사용-예시"><a href="#사용-예시" class="headerlink" title="사용 예시"></a>사용 예시</h4><p>쿼리를 처리할 때 중간 결과를 저장할 임시테이블로 주로 사용이 된다.</p><ul><li>조회용, 매핑용 테이블</li><li>주기적으로 집계되는 데이터의 결과를 캐시하는 테이블</li><li>데이터 분석 시 중간 결과 저장용 테이블</li></ul><p>MySQL은 내부적으로 <code>메모리 엔진</code>을 사용하지만,<br>중간 결과가 저장하기에 너무 커지거나, <code>text</code>, <code>blob</code>을 포함하면 <code>MyISAM 테이블로 대체</code>한다.</p><h4 id="MEMORY-TABLE-vs-TEMPORARY-TABLE"><a href="#MEMORY-TABLE-vs-TEMPORARY-TABLE" class="headerlink" title="MEMORY TABLE vs. TEMPORARY TABLE"></a>MEMORY TABLE vs. TEMPORARY TABLE</h4><ul><li>MEMORY TABLE<ul><li>메모리에 저장되는 임시 테이블</li></ul></li><li>TEMPORARY TABLE<ul><li>모든 스토리지 엔진을 사용 가능</li><li>단일 연결에만 보이고, 연결이 끝나면 사라진다.</li></ul></li></ul><blockquote><h3 id="Archive-엔진"><a href="#Archive-엔진" class="headerlink" title="Archive 엔진"></a>Archive 엔진</h3><p>저장소(archive)라는 네이밍에서 알 수 있 듯, INSERT 쿼리를 빠르게 처리할 수 있는 엔진이다.</p></blockquote><p>데이터 <code>쓰기 작업을 버퍼링</code>하고, 각 행이 삽입될 때마다 <code>zlib으로 압축</code>하여<br>MyISAM보다 디스크 입출력을 적게 일으킨다.</p><ul><li>Index를 지원하지 않는다</li><li>INSERT/REPLACE/SELECT 쿼리 지원</li><li>DELETE/UPDATE 미지원</li><li>transaction을 지원하지 않는다.</li><li>row-level locking을 사용하여, 많은 양의 로그성 데이터를 저장하고 읽는데 사용된다.</li></ul><blockquote><h3 id="CSV-엔진"><a href="#CSV-엔진" class="headerlink" title="CSV 엔진"></a>CSV 엔진</h3><p>CSV(Comma Separated Values)로 구성된 파일을 테이블로 처리하지만, 인덱스를 지원해주지 않는다.</p></blockquote><p>서버가 실행되는 동안 DB 내외로 파일을 복사하게 해준다.</p><ol><li>스프레드시트에서 csv 파일을 내보낸다.</li><li>MySQL 서버의 directory에 저장한다.</li><li>서버에서 즉시 파일을 읽을 수 있다.</li></ol><blockquote><h3 id="Federated-엔진"><a href="#Federated-엔진" class="headerlink" title="Federated 엔진"></a>Federated 엔진</h3><p>데이터를 자체 스토리지에 저장하지 않고, 각 Federated 테이블은 원격 MySQL 서버의 테이블을 참조한다.</p></blockquote><p>모든 작업을 원격 서버에 연결하여 진행한다.</p><p><strong>장점</strong></p><ul><li>기본키를 이용한 단일 행 조회</li><li>원격 서버에 실행 될 INSERT 쿼리</li></ul><p><strong>단점</strong></p><ul><li>집계 쿼리, 조인 등 다른 기본 작업의 성능이 낮다.</li></ul><blockquote><h3 id="BlackHole-엔진"><a href="#BlackHole-엔진" class="headerlink" title="BlackHole 엔진"></a>BlackHole 엔진</h3><p>저장 메커니즘을 가지고 있지 않고, INSERT 구문은 모두 버린다.</p></blockquote><p>서버는 Blackhole 테이블에 대한 쿼리를 로그에 기록하고, slave에 복제하는 등 로그에 남긴다.</p><p>복잡한 복제 구성, 감사용 로깅에 유용하게 사용된다.</p><hr><h2 id="MySQL-엔진-선택-시-고려사항"><a href="#MySQL-엔진-선택-시-고려사항" class="headerlink" title="MySQL 엔진 선택 시 고려사항"></a>MySQL 엔진 선택 시 고려사항</h2><p>설계 단에서 테이블 별로 어떠한 스토리지 엔진을 사용할 것인지 고려해야한다.<br>테이블이 어떻게 사용되고, 데이터가 어떻게 저장되는지 이해하고, 확장성 또한 고려해야한다.</p><blockquote><h3 id="트랜잭션이-필요할-때"><a href="#트랜잭션이-필요할-때" class="headerlink" title="트랜잭션이 필요할 때"></a>트랜잭션이 필요할 때</h3><p>InnoDB 엔진이 가장 안정적이다. MyISAM은 트랜잭션이 필요없는 사이트, SELECT가 메인인 업무에 적합하다.</p></blockquote><hr><h3 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h3><p><a href="https://nomadlee.com/mysql-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%A2%85%EB%A5%98-%EB%B0%8F-%ED%8A%B9%EC%A7%95/">Useful Guide</a><br><a href="https://thefif19wlsvy.tistory.com/26">FIF’s 코딩팩토리</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="Basic" scheme="http://inwoo.github.io/categories/Basic/"/>
    
    <category term="Database" scheme="http://inwoo.github.io/categories/Basic/Database/"/>
    
    
    <category term="MySQL" scheme="http://inwoo.github.io/tags/MySQL/"/>
    
    <category term="Engine" scheme="http://inwoo.github.io/tags/Engine/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 컨테이너 통신</title>
    <link href="http://inwoo.github.io/01/14/containernetwork/"/>
    <id>http://inwoo.github.io/01/14/containernetwork/</id>
    <published>2022-01-14T10:07:16.518Z</published>
    <updated>2022-01-14T11:39:59.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><!-- excerpt --><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bcXd2G/btrb3nCIJ66/ZraxAM9iewmZO54f9vZ8W0/img.png" alt="Docker"></p><h1 id="컨테이너가-통신하는-방법"><a href="#컨테이너가-통신하는-방법" class="headerlink" title="컨테이너가 통신하는 방법"></a>컨테이너가 통신하는 방법</h1><p>docker daemon이 start되면 docker0이라는 docker network interface가 생성된다.<br>    - virtual ethernet bridge : bridge를 지원해주는 network<br>    - container의 ip대역과 실제 물리 호스트 장비의 network를 연결시켜주는 bridge이다<br>    - docker0는 bridge network를 지원하기 위해서 내부적으로 NAT(network address translation)와 port forwarding 기능을 지원해준다.<br>        - <code>ip tables</code>를 통해서 지원한다.<br>    - 172.17.0.0/16 대역 안에서 docker0는 172.17.0.1 ip를 갖고 container의 gateway 역할, L2 통신 지원<br>    - container 생성 -&gt; docker 0를 통해 통신, container run 하면 172.17.0.1,2,3 순으로 가상 ip를 받고, docker0와 host 이더넷을 통해 외부로 통신한다.</p><hr><h2 id="1-컨테이너-포트-외부-노출"><a href="#1-컨테이너-포트-외부-노출" class="headerlink" title="1. 컨테이너 포트 외부 노출"></a>1. 컨테이너 포트 외부 노출</h2><p>웹 기반의 컨테이너 서비스를 동작하고 있으면 외부에서 웹 서버 컨테이너로 연결을 시켜주려면 포트포워딩이 필요하다</p><p>client는 이더넷(eth0) 인터페이스를 들어올 수 있는데, eth0를 통해 container로 접근하려면 포트포워딩이 필요하다.</p><h3 id="규칙"><a href="#규칙" class="headerlink" title="규칙"></a>규칙</h3><ul><li>docker host 백엔드 안에 iptables가 생성이되며 방화벽 rule이 저장된다.<ul><li><code>iptables -t nat -L -n -v</code>로 iptable을 확인할 수 있다.</li></ul></li><li>host의 포트번호는 중복될 수 없다.</li><li>container는 생성될 때마다 할당받는 주소가 달라지기 때문에 동일한 포트번호로 포워딩을 받을 수 있다.</li></ul><h3 id="p-hostPort-containerPort"><a href="#p-hostPort-containerPort" class="headerlink" title="-p hostPort:containerPort"></a>-p hostPort:containerPort</h3><p>코드에서 <code>-p hostPort:containerPort</code>는 hostPort로 접근 시 containerPort로 포트를 포워딩 시켜준다는 의미이다.</p><h3 id="p-containerPort"><a href="#p-containerPort" class="headerlink" title="-p containerPort"></a>-p containerPort</h3><p>추가로 <code>-p containerPort</code>와 같이 사용할 수 있는데, hostPort는 랜덤으로 배정된다</p><h3 id="P"><a href="#P" class="headerlink" title="-P"></a>-P</h3><p><code>-P</code>만 사용하면 컨테이너 내부에서 <code>Dockerfile</code> 내부에서 EXPOSE로 선언한 포트에 맞춰서 정의된다.</p><hr><h2 id="2-컨테이너-네트워크-추가"><a href="#2-컨테이너-네트워크-추가" class="headerlink" title="2. 컨테이너 네트워크 추가"></a>2. 컨테이너 네트워크 추가</h2><p>기본적으로 docker0 인터페이스 내부에 있는 network에 직접적으로 static ip를 할당할 수 없다.<br>하지만 network 대역을 바꾸거나 <strong>user-define network</strong>을 생성하여 내부에서 <strong>static ip를 할당</strong>하면 된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker network create --drive bridge \</span></span><br><span class="line"><span class="bash">--subnet 192.168.100.0/24 \</span></span><br><span class="line"><span class="bash">--gateway 102.168.100.254 \</span></span><br><span class="line"><span class="bash">mynet</span></span><br></pre></td></tr></table></figure><ul><li>driver : bridge, host, none-base 중 선택<ul><li>default = bridge</li></ul></li><li>subnet : user가 원하는 대로 할당할 수 있다.<ul><li>default : <code>172.18.x.x</code>, <code>172.19.x.x</code>와 같이 점진적으로 증가하여 할당한다.</li></ul></li><li>gateway : gateway도 임의로 할당할 수 있다.<ul><li>default : 192.168.100.1과 같이 할당된다.</li></ul></li><li>mynet : user가 설정한 network 이름</li></ul><h3 id="만들어진-network-확인"><a href="#만들어진-network-확인" class="headerlink" title="만들어진 network 확인"></a>만들어진 network 확인</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name appjs \</span><br><span class="line">--net mynet --ip 192.168.100.100 \</span><br><span class="line">-p [hostPort:containerPort] \</span><br><span class="line">[container image]</span><br></pre></td></tr></table></figure><ul><li>network : –net을 통해 user가 생성한 network을 사용할 수 있다.<ul><li>default : docker0의 network</li></ul></li><li>ip : <code>--ip</code>를 통해서 static ip를 할당할 수 있다.<ul><li>default : <code>192.168.100.1</code>, <code>192.168.100.2</code>와 같이 점진적으로 할당</li></ul></li></ul><hr><h2 id="3-컨테이너-간의-통신"><a href="#3-컨테이너-간의-통신" class="headerlink" title="3. 컨테이너 간의 통신"></a>3. 컨테이너 간의 통신</h2><p>프론트를 담당하는 컨테이너와 백을 담당하는 컨테이너 간의 통신을 통해 데이터를 주고 받을 수 있다.</p><p>MySQL(back)과 wordpress(front)를 연결해보는 예시를 진행해 볼 것이다.</p><h3 id="MYSQL-컨테이너"><a href="#MYSQL-컨테이너" class="headerlink" title="MYSQL 컨테이너"></a>MYSQL 컨테이너</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 일반 OS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name mysql -v /Users/InwooJeong/dbtest:/var/lib/mysql</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD=wordpress</span><br><span class="line">-e MYSQL_PASSWORD=wordpress mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac OS (M1)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name mysql -v /Users/InwooJeong/dbtest:/var/lib/mysql</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD=wordpress</span><br><span class="line">-e MYSQL_PASSWORD=wordpress --platform linux/amd64 mysql:5.7</span><br></pre></td></tr></table></figure><p>Volume mount를 해주고 환경변수로 password를 설정해준다.<br>    - MYSQL_ROOT_PASSWORD : DB에 접근할 때 필요한 비밀번호<br>    - MYSQL_PASSWORD : wordpress가 사용하는 비밀번호</p><h3 id="WORDPRESS-컨테이너"><a href="#WORDPRESS-컨테이너" class="headerlink" title="WORDPRESS 컨테이너"></a>WORDPRESS 컨테이너</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name wordpress --link mysql:mysql</span>  </span><br><span class="line">-e WORDPRESS_DB_PASSWORD=wordpress -p 80:80 wordpress:4</span><br></pre></td></tr></table></figure><p><code>--link</code>를 통해서 컨테이너를 연결해준다.<br>    - 콜론(:) 왼쪽 : 컨테이너 이름<br>    - 콜론(:) 오른쪽 : 유저가 원하는 이름</p><p><code>--link</code>를 통해 mysql</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://inwoo.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker - Host DB와 Container DB 연동</title>
    <link href="http://inwoo.github.io/01/14/datapersistence/"/>
    <id>http://inwoo.github.io/01/14/datapersistence/</id>
    <published>2022-01-14T07:10:34.000Z</published>
    <updated>2022-02-23T09:11:36.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><!-- excerpt --><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bcXd2G/btrb3nCIJ66/ZraxAM9iewmZO54f9vZ8W0/img.png" alt="Docker"></p><h1 id="데이터의-영구-보존"><a href="#데이터의-영구-보존" class="headerlink" title="데이터의 영구 보존"></a>데이터의 영구 보존</h1><p>Container image는 <code>Read Only</code>이다. 따라서 컨테이너에 추가되는 데이터들은 별도의 <strong>RW 레이어</strong>에 저장이 되어야한다.</p><p>Docker는 <code>Union File System</code> 혹은 <code>overlay</code>을 통해 RO와 RW 레이어의 변경 사항이 하나의 시스템인 것처럼 나타낸다. 컨테이너를 삭제하면 저장된 데이터도 함께 영구 삭제된다. 따라서 컨테이너가 만들어주는 데이터를 <code>영구적으로 보존</code> 시킬 방법을 강구해야한다.</p><p>Docker host에 directory, disk 등 저장 공간을 마련하여 데이터를 쌓아두어야한다. 이를 <strong>volume mount</strong>라고 한다.</p><p>코드로는 <code>docker run -d --name db -v /hostdisk:/var/lib/mysql</code>와 같이 <strong>-v</strong> 옵션을 사용하면 된다.</p><h2 id="volume-옵션을-통한-데이터-저장"><a href="#volume-옵션을-통한-데이터-저장" class="headerlink" title="volume 옵션을 통한 데이터 저장"></a>volume 옵션을 통한 데이터 저장</h2><p><code>-v 옵션</code>을 사용하여 volume mount를 통해 disk에 데이터를 저장하면 서비스를 삭제 후 실행, 재실행해도 데이터를 유지할 수 있다.</p><p><code>-v &lt;Host path&gt;:&lt;Container mount path&gt;</code></p><ul><li>Host의 db데이터를 container의 path에 volume mount한다.</li><li>container path의 데이터를 Host의 db에 저장하게 한다.</li><li><strong>container가 host의 데이터를 수정</strong>할 수 있는 단점이 있다.</li></ul><p><code>-v &lt;Host path&gt;:&lt;Container mount path&gt;:&lt;read write mode&gt;</code></p><ul><li><code>docker run -d -v /hostdisk:/var/www/html:ro ~</code></li><li>container은 host의 데이터에 대해 RO(Read Only) 권한을 갖는다.</li><li>default는 read write이다.</li></ul><p><code>-v &lt;Container mount path&gt;</code></p><ul><li><code>/var/lib/docker/volumes/uuid디렉토리/data</code> 경로에 uuid 디렉토리를 생성하여 자동으로 mount를 시켜준다.</li></ul><h2 id="예제-확인하기"><a href="#예제-확인하기" class="headerlink" title="예제 확인하기"></a>예제 확인하기</h2><details><summary> 1. MySQL DB data 영구 보존하기</summary><h3 id="환경"><a href="#환경" class="headerlink" title="환경"></a>환경</h3><p><code>Mac OS (M1)</code> 환경에서 <code>docker desktop</code>을 다운로드 후 <code>iterm2</code>에서 실행하였습니다.</p><h3 id="사전-설정"><a href="#사전-설정" class="headerlink" title="사전 설정"></a>사전 설정</h3><p>docker desktop - preferences - Resources - FILE SHARING에서 mount될 디렉토리를 추가한 후 진행하였습니다.</p><ul><li>/User/InwooJeong/dbtest</li></ul><h3 id="1-컨테이너-생성"><a href="#1-컨테이너-생성" class="headerlink" title="1. 컨테이너 생성"></a>1. 컨테이너 생성</h3><p>명령어에 오타가 있을 시 container가 실행하자마자 종료될 수 있습니다.</p><ul><li>docker background 실행</li><li>컨테이너 이름 : dbtest</li><li>Host DB directory : /Users/InwooJeong/dbtest</li><li>Container DB directory : /var/lib/mysql</li><li>Mysql Root password = pass</li><li>platform : linux/amd64<ul><li>M1칩 기반의 Mac Os를 사용할 때는 플랫폼을 명시적으로 설정해주어야합니다.</li></ul></li></ul><h3 id="1-Host-path-Container-path-연결"><a href="#1-Host-path-Container-path-연결" class="headerlink" title="1. Host path:Container path 연결"></a>1. Host path:Container path 연결</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name dbtest -v /Users/InwooJeong/dbtest:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=pass --platform linux/amd64 mysql:latest</span></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">위와같이 실행하면 Container는 `background` 환경에서 `mysqld` 명령어를 통해 mysql이 실행되고 있다.</span><br><span class="line">- mysqld는 mysql의 Dockerfile 내에 명령어로 입력되어 있다.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Container Path만 작성해도 데이터를 Host path에 영구적으로 저장할 수 있다.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="bash">&gt; Linux 기준으로 랜덤한 UUID를 통해 /var/lib/docker/volume/UUID/_data에 저장된다.</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 2. MySQL에 접속</span></span></span><br><span class="line">`mysql` client 명령을 통해 외부에서 접속할 수 있지만, container 내부에 들어가서 실행할 수도 있다. 아래 코드를 통해 `dbtest`라는 컨테이너에 접속해서 `/bin/bash`에 접근한다.</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">docker exec -it dbtest /bin/bash</span><br><span class="line">````</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 3. mysql 실행</span></span></span><br><span class="line"></span><br><span class="line">컨테이너 내부에 접속하였으니 `mysql`으로 접속하여 data를 생성해보려한다.</span><br><span class="line"></span><br><span class="line">현재는 **root 계정**만 존재하고 있으므로 `user(-u)는 root`, `password(-p)`는 docker run을 할 때 설정해주었던 pass로 입력하여 접속한다.</span><br><span class="line">- `-p`와 `password`인 pass를 **붙여서 작성**해주어야한다.</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">root@213kl1j23k:/# mysql -u root -ppass</span><br><span class="line">````</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 4. 데이터 생성</span></span></span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database inwoo;</span> </span><br></pre></td></tr></table></figure><p>위 코드를 통해 데이터베이스를 생성한 후 <code>Host Database Directory</code>로 설정한 /Users/InwooJeong/dbtest를 확인해보면 <code>inwoo</code> 폴더가 생성되어 있는 것을 확인할 수 있다.</p></details><details><summary>2. Host DB에 있는 서비스를 Container에 지원하기 </summary><p><code>-v &lt;host path&gt;:&lt;container mount path&gt;:&lt;read write mode&gt;</code></p><h3 id="1-제공할-웹-컨텐츠-만들기"><a href="#1-제공할-웹-컨텐츠-만들기" class="headerlink" title="1. 제공할 웹 컨텐츠 만들기"></a>1. 제공할 웹 컨텐츠 만들기</h3><p>Host의 원하는 디렉토리에 간단한 <code>index.html</code> 파일을 생성하여 저장해주었다.</p><ul><li>Host path : /Users/InwooJeong/webdata</li><li>file name : index.html</li><li>contents : <code>&lt;h1&gt;Inwoo Jeong Web Service Test&lt;/h1&gt;</code></li></ul><h3 id="2-Container-실행하기"><a href="#2-Container-실행하기" class="headerlink" title="2. Container 실행하기"></a>2. Container 실행하기</h3><ul><li>docker background 모드로 실행</li><li>container 이름 : web</li><li>포트포워딩 : 80:80</li><li>volume 설정<ul><li>host path : /Users/InwooJeong/webdata</li><li>container path : /usr/share/nginx/html</li><li>read write option : ro<ul><li>container에서 host의 서비스를 임의로 변경할 수 없도록 Read Only로 설정한다.</li></ul></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name web -p 80:80 -v /Users/InwooJeong/webdata:/usr/share/nginx/html:ro nginx:1.14</span><br></pre></td></tr></table></figure><h3 id="3-Web-접속"><a href="#3-Web-접속" class="headerlink" title="3. Web 접속"></a>3. Web 접속</h3><p><code>공인 ip:port</code> 주소로 접속하면 container를 통해 host path에 접근하여 서비스를 제공받을 수 있다. </p></details><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://inwoo.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://inwoo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - Stress Test</title>
    <link href="http://inwoo.github.io/01/14/stressTest/"/>
    <id>http://inwoo.github.io/01/14/stressTest/</id>
    <published>2022-01-13T16:30:01.000Z</published>
    <updated>2022-01-13T16:31:40.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><!-- excerpt --><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bcXd2G/btrb3nCIJ66/ZraxAM9iewmZO54f9vZ8W0/img.png" alt="Docker"></p><h2 id="부하-테스트"><a href="#부하-테스트" class="headerlink" title="부하 테스트"></a>부하 테스트</h2><p>부하 테스트 프로그램인 <code>stress</code>를 통하여 cpu와 메모리 부하테스트를 실행할 수 있다.</p><p>CPU 부하테스트</p><ul><li>특정 CPU core를 100%를 사용하도록 부하를 발생시킨다</li><li><code>stress --cpu 2</code> : 2개 cpu를 100% 사용한다.</li></ul><p>메모리 부하테스트</p><ul><li>프로세스 수와 설정한 메모리만큼의 부하를 발생시킨다.</li><li><code>stress --vm 2 --vm-bytes 150m</code> : 2개 프로세스를 150MB로 실행</li></ul><p>메모리 100m를 할당하고 90m의 부하를 발생시켰을 때는 성공적으로 작동하지만, 100m를 할당하고 150m의 부하를 주었을 때는 OOM(Out Of Memory) killer를 통해 프로세스가 바로 <strong>kill</strong>된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -m 100m --memory-swap 100m stress:latest stress --vm 1 --vm-bytes 90m -t 5s</span></span><br><span class="line">stress: info: [1] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br><span class="line">stress: info: [1] successful run completed in 5s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -m 100m --memory-swap 100m stress:latest stress --vm 1 --vm-bytes 150m -t 5s</span></span><br><span class="line">stress: info: [1] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br><span class="line">stress: FAIL: [1] (415) &lt;-- worker 9 got signal 9</span><br><span class="line">stress: WARN: [1] (417) now reaping child worker processes</span><br><span class="line">stress: FAIL: [1] (421) kill error: No such process</span><br><span class="line">stress: FAIL: [1] (451) failed run completed in 0s</span><br></pre></td></tr></table></figure><h3 id="OOM-disable"><a href="#OOM-disable" class="headerlink" title="OOM disable"></a>OOM disable</h3><p><code>--oom-kill-disable=true</code> 속성을 통해 Out Of Memory가 발생했을 때 컨테이너가 kill되는 것을 방지할 수 있다.</p><p>확인하는 방법에는 아래와 같이 2가지가 있다.</p><h4 id="1-docker-inspect"><a href="#1-docker-inspect" class="headerlink" title="1. docker inspect"></a>1. docker inspect</h4><p><code>docker inspect</code>를 통해 컨테이너 속성을 확인해보면 아래와 같다.</p><ul><li>memory는 100MB</li><li>swap-memory는 설정하지 않았기 때문에 200MB (default=memory의 2배)</li><li>OomKillDisable : true</li></ul><pre><code class="shell">$ docker run -d -m 100m --name m4 --oom-kill-disable=true nginx$ docker inspect m4<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 2. cgroup</span><br><span class="line"></span><br><span class="line">실제 resource는 `cgroup-memory-doker-containerID` 디렉토리에 설정해준다.</span><br><span class="line"></span><br><span class="line">아래 코드를 통해 확인해보면 `oom_kill_disable 1`이 설정되어있는 것을 확인할 수 있다.</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">cat /sys/fs/cgroup/memory/docker/[containerId]/memory.oom_control</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://inwoo.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://inwoo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - Resource 제어</title>
    <link href="http://inwoo.github.io/01/13/containerResource/"/>
    <id>http://inwoo.github.io/01/13/containerResource/</id>
    <published>2022-01-13T10:51:16.000Z</published>
    <updated>2022-01-14T06:20:45.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><!-- excerpt --><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bcXd2G/btrb3nCIJ66/ZraxAM9iewmZO54f9vZ8W0/img.png" alt="Docker"></p><h1 id="컨테이너-리소스-제한"><a href="#컨테이너-리소스-제한" class="headerlink" title="컨테이너 리소스 제한"></a>컨테이너 리소스 제한</h1><p>기본적으로 컨테이너는 HOST 하드웨어 리소스의 제한을 받지 않는다. 즉 컨테이너의 용량 제한을 걸어두지 않으면 HOST 하드웨어 리소스를 모두 사용할 수 있다. 따라서 <code>필요한 만큼의 리소스</code>만 할당해주어야 한다.</p><h2 id="Docker-command를-통해-제한할-수-있는-리소스"><a href="#Docker-command를-통해-제한할-수-있는-리소스" class="headerlink" title="Docker command를 통해 제한할 수 있는 리소스"></a>Docker command를 통해 제한할 수 있는 리소스</h2><p>리소스는 docker run의 옵션을 통해 설정할 수 있다.</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><code>--cpus</code> : 컨테이너에 할당할 CPU core 수를 설정한다.</p><ul><li><code>docker run -d --cpus=&quot;.5&quot; ubuntu:1.14</code></li><li>ubuntu 컨테이너가 0.5개의 코어만 사용할 수 있도록 설정한다.</li></ul><p><code>--cpuset-cpus</code> : 컨테이너가 사용할 수 있는 CPU나 코어를 할당해준다.</p><ul><li>index는 0부터 시작한다.</li><li><code>docker run -d --cpuset-cpus 0-3 ubuntu:1.14</code></li></ul><p><code>--cpu-shares</code> : CPU 비중을 상대적으로 설정한다.</p><ul><li>모든 application은 share 값을 1024로 할당한다.</li><li>2048로 설정할 시 기본값보다 2배 많은 자원을 할당받는 것이다.</li><li><code>docker run -d --cpu-shares 2048 ubuntu:1.14</code></li></ul><h3 id="CPU-예제"><a href="#CPU-예제" class="headerlink" title="CPU-예제"></a>CPU-예제</h3><p>아래와 같이 CPU share 값을 각기 다르게 설정하고 컨테이너를 실행시켜보았다. docker ps를 통해 실행 중인 컨테이너 목록을 확인하면 정상적으로 4개의 컨테이너가 실행 중인 것을 볼 수 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -c 2048 --name cload1 -d stress:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -c 1024 --name cload2 -d stress:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -c 512 --name cload3 -d stress:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -c 512 --name cload4 -d stress:latest</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">cf49f08f0e83   stress:latest   &quot;/bin/sh -c &#x27;stress …&quot;   8 seconds ago    Up 7 seconds              cload4</span><br><span class="line">28d9ff3b113d   stress:latest   &quot;/bin/sh -c &#x27;stress …&quot;   13 seconds ago   Up 11 seconds             cload3</span><br><span class="line">a73132273677   stress:latest   &quot;/bin/sh -c &#x27;stress …&quot;   22 seconds ago   Up 21 seconds             cload2</span><br><span class="line">7ce85fb5b7f4   stress:latest   &quot;/bin/sh -c &#x27;stress …&quot;   42 seconds ago   Up 41 seconds             cload1</span><br></pre></td></tr></table></figure><p><code>docker stats</code> 명령어를 통해 실시간으로 각 컨테이너들이 CPU를 얼만큼 점유하고 있는지 확인해보았다.</p><p><img src="/image/dockerstat.png" alt="docker stats"></p><p>상대적 비율이므로 2048로 설정한 <code>cload1</code>부터 해당 비율만큼 차이를 보이며 cpu를 점유하고 있는 것을 볼 수 있다.</p><hr><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>제한 단위는 b, k, m, g로 할당할 수 있다.</p><p><code>--memory [용량]</code>, <code>-m [용량]</code> : 컨테이너가 사용할 최대 메모리 양을 지정해준다.</p><ul><li><code>docker run -d -m 512m nginx:1.14</code></li><li>nginx:1.14 컨테이너는 최대 512MB를 사용할 수 있다.</li></ul><p><code>--memory-reservaion [용량]</code> : 설정한 값보다 적은 값으로 구성하는 soft 제한 값을 설정한다.</p><ul><li><code>docker run -d -m 1g --memory-reservation 500m nginx:1.14</code></li><li>최대 1GB를 사용할 수 있고, 최소 500MB를 보장받을 수 있다.</li></ul><p><code>--memory-swap [용량]</code> : 컨테이너가 사용할 스왑 메모리 영역에 대한 설정</p><ul><li>default 값은 설정한 메모리의 2배가 설정된다.</li><li><code>docker run -d -m 200m --memory-swap 300m nginx:1.14</code></li><li>최대 메모리양은 200MB이며, 300MB는 <code>최대 메모리 + 스왑 메모리</code> 이다.</li><li>위에서 스왑 메모리는 100MB이다.</li></ul><p><code>--oom-kill-disable</code> : OOM Killer가 프로세스를 kill하지 못하도록 보호한다.</p><ul><li>OOM : Out Of Memory</li><li>Linux 커널은 물리 메모리가 부족하면 OOM Killer를 동작시켜 프로세스를 종료하는 기능을 가지고 있다. 커널이 임의로 프로세스를 종료하지 못하도록 설정하는 것이다.</li></ul><h3 id="DISK-I-O-Block-I-O"><a href="#DISK-I-O-Block-I-O" class="headerlink" title="DISK I/O (Block I/O)"></a>DISK I/O (Block I/O)</h3><p><code>--blkio-weight</code>, <code>--blkio-weight-device</code> : Block IO의 Quota를 설정할 수 있다.</p><ul><li>모든 컨테이너는 동작할 때 I/O 스케줄링을 받는다.</li><li>default 값은 500이며, 100부터 1000까지 설정할 수 있다.</li><li>device는 device에 대해서만 적용할 때 사용한다.</li><li><code>docker run -it --rm --blkio-weight 100 ubuntu:latest /bin/bash</code></li></ul><p><code>--device-read-bps</code>, <code>--device-write-bps</code> : 특정 device에 대한 읽기 쓰기 작업에 제한값을 설정한다.</p><ul><li>kb, mb, gb 단위로 설정한다.</li><li>throughput과 연관이 있다.</li><li><code>docker run -it --rm --device-write-bps /dev/vda:10mb ubuntu:latest /bin/bash</code></li><li>/dev/vda에 있는 데이터를 읽고 쓸 때는 10mb로 속도를 제한하겠다.</li></ul><p><code>--device-read-iops</code>, <code>--device-write-iops</code> : 초당 속도에 대한 quota를 제한한다.</p><ul><li>IOPS는 0 이상의 정수로 표기하여야한다.</li><li><code>초당 데이터 전송량 = IOPS * 블럭크기 (단위 데이터 용량)</code> 으로 나타낸다.</li></ul><h3 id="Block-I-O-예제"><a href="#Block-I-O-예제" class="headerlink" title="Block I/O -예제"></a>Block I/O -예제</h3><p>컨테이너에서 <code>--device-write-iops</code>를 적용해서 write 속도를 다르게 제한한 후 write를 발생시켰을 때 속도를 비교해보자.</p><p><code>lslbk</code> 명령어를 통해 disk 이름을 확인한 후 실행한다.</p><ul><li>예시에서 disk 이름은 <code>xvda</code>이다.</li></ul><p>아래 예제 코드는 iops를 설정하고, ubuntu 컨테이너를 실행 후 /bin/bash 를 실행하는 코드입니다.</p><p><strong>iops를 10으로 설정했을 때</strong> : 1.01219초 가량이 소요되었으며, 초당 10.3MB를 실행하였다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm --device-write-iops /dev/xvda:10 ubuntu:latest /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 접속 후</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1M를 10개 만들 때 걸리는 시간이 출력된다</span></span><br><span class="line">dd if=/dev/zero of=file1 bs=1M count=10 oflag=direct</span><br></pre></td></tr></table></figure><p><strong>iops를 100으로 설정했을 때</strong> : 0.0412287초가 소요되었으며, 초당 254MB를 실행하였다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm --device-write-iops /dev/xvda:10 ubuntu:latest /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 접속 후</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1M를 10개 만들 때 걸리는 시간이 출력된다</span></span><br><span class="line">dd if=/dev/zero of=file1 bs=1M count=10 oflag=direct</span><br></pre></td></tr></table></figure><hr><h1 id="리소스-모니터링"><a href="#리소스-모니터링" class="headerlink" title="리소스 모니터링"></a>리소스 모니터링</h1><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><h3 id="docker-stat"><a href="#docker-stat" class="headerlink" title="docker stat"></a>docker stat</h3><p><code>docker stats [option] [container...]</code> : 실행 중인 컨테이너의 런타임 통계를 확인한다.</p><p><code>docker events</code> : 도커 호스트의 실시간 event 정보를 수집해서 출력해준다.</p><ul><li>container, image, volume, network 등 컨테이너와 관련된 event를 출력한다.</li><li><code>docker events -f container=&lt;MAME&gt;</code></li></ul><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h3 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h3><p>google에서 만든 docker 모니터링 도구이다.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://inwoo.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://inwoo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - Container 관련 명령어</title>
    <link href="http://inwoo.github.io/01/13/dockercontainer/"/>
    <id>http://inwoo.github.io/01/13/dockercontainer/</id>
    <published>2022-01-13T06:36:24.000Z</published>
    <updated>2022-01-13T10:56:35.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><!-- excerpt --><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bcXd2G/btrb3nCIJ66/ZraxAM9iewmZO54f9vZ8W0/img.png" alt="Docker"></p><h2 id="명령어"><a href="#명령어" class="headerlink" title="명령어"></a>명령어</h2><h3 id="컨테이너-이미지의-관리"><a href="#컨테이너-이미지의-관리" class="headerlink" title="컨테이너 이미지의 관리"></a>컨테이너 이미지의 관리</h3><ul><li><p><strong>이미지 검색</strong></p><ul><li>hub.docker.com에서 이미지를 찾아 보여준다.</li><li><code>docker search [option] &lt;이미지이름:태그명&gt;</code><ul><li>docker search mysql</li><li>docker search database</li></ul></li></ul></li><li><p><strong>이미지 다운로드</strong></p><ul><li>검색한 이미지를 local에 다운로드한다.</li><li><code>docker pull [option] &lt;이미지이름:태그명&gt;</code></li><li>태그를 사용하지 않으면 default 값은 latest 버전이다.</li></ul></li><li><p><strong>다운로드 받은 이미지 목록 출력</strong></p><ul><li><code>docker images</code></li><li><code>docker image ls</code></li></ul></li><li><p><strong>다운로드 받은 이미지 상세 출력</strong></p><ul><li><code>docker inspect [option] &lt;이미지이름:태그명&gt;</code></li></ul></li><li><p><strong>이미지 삭제</strong></p><ul><li><code>docker rmi [option] &lt;이미지이름:태그명&gt;</code></li></ul></li><li><p><strong>이미지를 컨테이너화 (생성)</strong></p><ul><li><code>docker create --name [name] [option] &lt;이미지이름:태그명&gt;</code></li></ul></li><li><p><strong>컨테이너 실행</strong></p><ul><li><code>docker start name</code></li><li><code>docker run --name [name] -d &lt;이리지이름:태그명&gt; </code></li><li>run 명령어는 pull, create, start를 한번에 처리해준다.<ul><li>이미지가 없으면 pull을 해주고, 있으면 해당 이미지를 컨테이너로 생성하고 실행한다.</li></ul></li></ul></li><li><p><strong>실행 중인 컨테이너 확인</strong></p><ul><li><code>docker ps</code></li></ul></li><li><p><strong>컨테이너 상세 정보</strong></p><ul><li><code>docker inspect [컨테이너 이름]</code></li><li>리소스, 프로세스 id, ip address 등</li></ul></li><li><p><strong>동작 중인 컨테이너 정지</strong></p><ul><li><code>docker stop [컨테이너 이름]</code></li></ul></li><li><p><strong>컨테이너 삭제</strong></p><ul><li><code>docker rm [컨테이너 이름]</code></li></ul></li><li><p><strong>컨테이너에서 동작 중인 프로세스</strong></p><ul><li><code>docker top [컨테이너 이름]</code></li></ul></li><li><p><strong>로그 조회</strong></p><ul><li><code>docker logs [컨테이너 이름]</code></li></ul></li><li><p><strong>명령 추가</strong></p><ul><li><code>docker exec [컨테이너 이름] [명령]</code></li></ul></li><li><p><strong>포그라운드로 실행 중인 컨테이너에 연결</strong></p><ul><li><code>docker attach [option] [컨테이너 이름]</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://inwoo.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://inwoo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - Dockerfile</title>
    <link href="http://inwoo.github.io/01/13/dockerfile/"/>
    <id>http://inwoo.github.io/01/13/dockerfile/</id>
    <published>2022-01-13T05:51:53.000Z</published>
    <updated>2022-01-13T10:56:25.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><!-- excerpt --><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bcXd2G/btrb3nCIJ66/ZraxAM9iewmZO54f9vZ8W0/img.png" alt="Docker"></p><h1 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h1><p>Container를 만들 수 있도록 도와주는 명령어의 집합이며, 파일명은 반드시 <strong>Dockerfile</strong> 이어야한다.</p><ul><li><p>쉽고, 간단하고 명확한 구문을 가진 text file이며, Top-Down으로 해석을 한다.</p></li><li><p>컨테이너 이미지를 생성할 수 있는 고유의 <code>Instruction</code>을 가진다.</p></li><li><p>대소문자를 구분하지는 않지만 가독성을 위해 <code>지시어</code>는 <code>대문자</code>로 사용한다.</p></li></ul><hr><h1 id="지시어"><a href="#지시어" class="headerlink" title="지시어"></a>지시어</h1><table><thead><tr><th align="center">지시어</th><th align="center">설명</th></tr></thead><tbody><tr><td align="center">FROM</td><td align="center">가장 먼저 작성해야하며, 운영환경(base image)을 의미한다</td></tr><tr><td align="center">MAINTAINER</td><td align="center">이미지를 생성한 사람의 이름 및 정보</td></tr><tr><td align="center">LABEL</td><td align="center">이미지에 컨테이너의 정보를 저장</td></tr><tr><td align="center">RUN</td><td align="center">빌드를 위해 base image에서 실행할 commands</td></tr><tr><td align="center">COPY</td><td align="center">빌드하는 시점에 HOST의 파일을 컨테이너로 복사한다</td></tr><tr><td align="center">ADD</td><td align="center">빌드하는 시점에 HOST의 파일(url, tar 포함)을 컨테이너로 복사한다</td></tr><tr><td align="center">WORKDIR</td><td align="center">컨테이너 빌드 시 명령이 실행될 작업 디렉터리 설정</td></tr><tr><td align="center">ENV</td><td align="center">환경변수 지정</td></tr><tr><td align="center">USER</td><td align="center">명령 및 컨테이너 실행 시 적용할 유저 설정 (root가 아닌 시스템 계정을 만들어서 실행할 수 있다)</td></tr><tr><td align="center">VOLUME</td><td align="center">컨테이너가 동작할 때 파일 또는 디렉토리를 컨데이너의 디렉토리로 마운트(데이터가 저장될 장소)</td></tr><tr><td align="center">EXPOSE</td><td align="center">컨테이너 동작 시 외부에서 사용할 포트 지정</td></tr><tr><td align="center">CMD</td><td align="center">컨테이너 동작 시 자동으로 실행할 서비스나 스크립트 지정, 동작 시 변환이 가능하다.</td></tr><tr><td align="center">ENTRYPOINT</td><td align="center">CMD와 함께 사용하면서 command 지정 시 사용, 명령어를 변환할 수 없다.</td></tr><tr><td align="center">기타</td><td align="center">CMD와 ENTRYPOINT를 같이 쓰일 때는 ENTRYPOINT에 명령어, CMD에 args, option을 넣어 사용한다</td></tr></tbody></table><hr><h1 id="빌드-및-배포"><a href="#빌드-및-배포" class="headerlink" title="빌드 및 배포"></a>빌드 및 배포</h1><h2 id="1-빌드"><a href="#1-빌드" class="headerlink" title="1. 빌드"></a>1. 빌드</h2><p>docker build -t [컨테이너이름] [build할 파일이 있는 디렉토]<br>    - <code>docker build -t hellojs:latest .</code></p><h2 id="2-로그인"><a href="#2-로그인" class="headerlink" title="2. 로그인"></a>2. 로그인</h2><p>docker login</p><h2 id="3-배포"><a href="#3-배포" class="headerlink" title="3. 배포"></a>3. 배포</h2><p>docker push [컨테이너이름]</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker - Docker Compose</title>
    <link href="http://inwoo.github.io/01/12/dockercompose/"/>
    <id>http://inwoo.github.io/01/12/dockercompose/</id>
    <published>2022-01-12T14:49:12.000Z</published>
    <updated>2022-01-13T10:59:30.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span><!-- excerpt --><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bcXd2G/btrb3nCIJ66/ZraxAM9iewmZO54f9vZ8W0/img.png" alt="Docker"></p><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><blockquote><p> Compose : 구성하다</p></blockquote><p><code>Docker Compose</code>는 <code>다중 컨테이너</code> 애플리케이션을 정의하고 공유할 수 있도록 개발된 도구입니다. compose라는 단어의 뜻에서 알 수 있듯 애플리케이션을 <code>구성하는 도구</code>로 생각하면 됩니다.</p><p><code>docker-compose.yml</code> 파일을 통해 configure을 설정하고, 단일 명령어로 서비스를 실행 및 종료할 수 있습니다.</p><p>Compose를 사용하면 <code>file</code>에서 애플리케이션의 <code>스택</code>을 정의하고, repository의 <code>root</code>에 파일을 저장하여 공유할 수 있습니다. 또한 production, staging, development, testing, CI 환경에서 모두 사용이 가능합니다.</p><hr><h2 id="Compose-파일-생성"><a href="#Compose-파일-생성" class="headerlink" title="Compose 파일 생성"></a>Compose 파일 생성</h2><ol><li><p>프로젝트의 <code>root</code> 디렉토리에 <code>docker-compose.yml</code> 파일을 생성합니다.</p></li><li><p>(version) Schema version을 정의합니다.</p><ul><li>최신 버전을 사용하는 것이 권장됩니다.</li><li><a href="https://docs.docker.com/compose/compose-file/">호환성 체크</a></li></ul></li><li><p>(services) 애플리케이션을 구성하는 서비스, 컨테이너 목록을 설정합니다.</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span>  <span class="comment"># optional since v1.27.0</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">logvolume01:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="속성"><a href="#속성" class="headerlink" title="속성"></a>속성</h3><ul><li>version : 스키마 버전</li><li>services : 하위에 애플리케이션을 구성하는 서비스 설정</li><li>app, mysql 등 : 어플리케이션, 서비스 정의 (네트워크 별칭과 동일)</li><li>image : docker image</li><li>command : 명령어 (순서가 고정된 것은 아니지만 image와 가까운 곳에 기입한다.)</li><li>ports : 포트</li><li>working_dir : 작업 디렉토리</li><li>volumes : 볼륨 매핑<ul><li><code>docker run</code>으로 실행 시 명명된 볼륨이 자동 생성되지만, compose는 개별적으로 정의해주어야 한다. </li></ul></li><li>environment : 환경 변수<ul><li>MYSQL_HOST: mysql 과 같이 key-value쌍으로 기입한다.</li></ul></li></ul><hr><h2 id="사용-방법"><a href="#사용-방법" class="headerlink" title="사용 방법"></a>사용 방법</h2><ol><li><p>이식성과 재사용성을 높일 수 있도록 Dockerfile로 환경설정을 한다..</p></li><li><p>독립된 환경에서 돌아갈 수 있도록 앱을 구성하는 서비스를 <code>docker-compose.yml</code>에 정의한다.</p></li><li><p><code>docker compose up</code>이나 <code>docker-compose up</code>을 실행하여 모든 app을 실행시킨다.</p></li></ol><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul><li><a href="https://docs.microsoft.com/ko-kr/visualstudio/docker/tutorials/use-docker-compose">Microsoft-Docker Compose 사용</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://inwoo.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://inwoo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>목표 달성형 펀세이빙 서비스 개발 - 1. 개발 프로세스 정립</title>
    <link href="http://inwoo.github.io/01/11/project1/"/>
    <id>http://inwoo.github.io/01/11/project1/</id>
    <published>2022-01-11T11:57:04.000Z</published>
    <updated>2022-01-11T12:08:56.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><p>개발 아이템 설명은 넘기고 </p><h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><h2 id="버전관리-시스템"><a href="#버전관리-시스템" class="headerlink" title="버전관리 시스템"></a>버전관리 시스템</h2><h3 id="배경과-요구-사항"><a href="#배경과-요구-사항" class="headerlink" title="배경과 요구 사항"></a>배경과 요구 사항</h3><h3 id="선택지"><a href="#선택지" class="headerlink" title="선택지"></a>선택지</h3><h3 id="의사-결정"><a href="#의사-결정" class="headerlink" title="의사 결정"></a>의사 결정</h3><h3 id="개발-과정"><a href="#개발-과정" class="headerlink" title="개발 과정"></a>개발 과정</h3>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Project" scheme="http://inwoo.github.io/categories/Project/"/>
    
    <category term="Fun-Saving" scheme="http://inwoo.github.io/categories/Project/Fun-Saving/"/>
    
    
  </entry>
  
  <entry>
    <title>일급 컬렉션 (First Class Collcetion)</title>
    <link href="http://inwoo.github.io/12/12/firstclassCollection/"/>
    <id>http://inwoo.github.io/12/12/firstclassCollection/</id>
    <published>2021-12-12T12:53:01.000Z</published>
    <updated>2021-12-12T13:34:34.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><hr><p><code>객체 지향적</code>으로, <code>리팩토링</code>하기 쉬운 코드를 위해 일급 컬렉션이 필요하다고 한다.</p><h3 id="일급-컬렉션"><a href="#일급-컬렉션" class="headerlink" title="일급 컬렉션"></a>일급 컬렉션</h3><blockquote><p>Collection을 포함한 클래스는 반드시 다른 멤버 변수가 없어야한다.</p><p>Collection은 그 자체로 wrap 되기 때문에 이와 관련된 동작은 근거지가 마련된 것이다.</p><p>Filter가 이 새로운 클래스의 일부가 되고, 스스로 함수 객체가 될 수 있다.</p><p>두 그룹을 같이 묶고, 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다.</p></blockquote><p>코드로 확인하자면 아래 코드와 같이 <code>Collection</code>을 <code>Class</code>로 <code>Wrapping</code>하고, 유일한 멤버 변수로 설정해놓은 상태를 <strong>일급 컬렉션</strong>이라고 한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRanking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; ranks;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameRanking</span><span class="params">(Map&lt;String, String&gt; ranks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ranks = ranks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="일급-컬렉션의-특징"><a href="#일급-컬렉션의-특징" class="headerlink" title="일급 컬렉션의 특징"></a>일급 컬렉션의 특징</h2><h3 id="1-비즈니스에-종속적인-자료구조"><a href="#1-비즈니스에-종속적인-자료구조" class="headerlink" title="1. 비즈니스에 종속적인 자료구조"></a>1. 비즈니스에 종속적인 자료구조</h3><p>Service Layer에서 로또 복권 게임을 만든다고 가정해보자.</p><p>로또 복권은 <code>중복되지 않는 6개의 번호</code>로 이루어져야 한다는 조건이 있다.<br>    - 이를 Service Layer에서 여러 메서드를 통해 구현을 해줄 수도 있다.</p><p>하지만 이는 협업에 있어서 <strong>가독성을 떨어트릴 수 있고</strong>, 문제가 발생할 여지가 있다.</p><p>어떻게 이를 가독성이 뛰어나고, 누구나 알아볼 수 있게 만들 수 있을까요?<br>    - 중복되지 않는 6개의 번호를 가진 자료구조</p><p>이러한 자료는 존재하지 않으므로, 이 때 <strong>일급 컬렉션</strong>을 사용하여 만들 수 있습니다.</p><h3 id="2-Collection의-불변성-보장"><a href="#2-Collection의-불변성-보장" class="headerlink" title="2. Collection의 불변성 보장"></a>2. Collection의 불변성 보장</h3><p>일급 컬렉션은 <strong>Collection의 불변을 보장</strong>한다는 특징이 있습니다.</p><p>불변임을 보장해주어야 <strong>사이드 이펙트를 최소화</strong> 시킬 수 있습니다.<br>    - Java에서 <code>final</code> 키워드를 떠올리시는 분들이 계실 거 같습니다.<br>    - final은 재할당을 막아주는 것이지 객체의 불변을 보장하지는 않습니다.</p><p>불변성은 <strong>Wrapper Class</strong>를 통한 <strong>일급 컬렉션</strong>으로 해결해주어야합니다.</p><p>내부의 객체를 <code>private final</code>로 설정하고, <code>생성자</code>와 <code>getter</code>만 public으로 설정합니다.</p><p>별도로 <code>setter</code>를 설정하지 않으면 객체에 대한 접근만 가능하고, 설정은 불가능해지며 불변을 보장할 수 있습니다.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Basic" scheme="http://inwoo.github.io/categories/Basic/"/>
    
    <category term="Java" scheme="http://inwoo.github.io/categories/Basic/Java/"/>
    
    
    <category term="일급 컬렉션" scheme="http://inwoo.github.io/tags/%EC%9D%BC%EA%B8%89-%EC%BB%AC%EB%A0%89%EC%85%98/"/>
    
  </entry>
  
  <entry>
    <title>프록시 패턴 (Proxy Pattern)</title>
    <link href="http://inwoo.github.io/12/11/proxyPattern/"/>
    <id>http://inwoo.github.io/12/11/proxyPattern/</id>
    <published>2021-12-11T09:25:00.000Z</published>
    <updated>2021-12-11T09:41:28.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><hr><h1 id="Proxy-Pattern"><a href="#Proxy-Pattern" class="headerlink" title="Proxy Pattern"></a>Proxy Pattern</h1><h2 id="1-정의"><a href="#1-정의" class="headerlink" title="1. 정의"></a>1. 정의</h2><p>객체에 대한 접근을 제어하기 위해 <code>대리자(proxy)</code>를 둔다.</p><p><code>proxy</code>를 통해 대상 객체에 접근하여, 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있고 또한 실제 객체의 기능이 반드시 필요한 시점까지 객체의 생성을 미룰 수 있다.</p><blockquote><p>10개의 method를 가지고 있는 객체가 있고 3개의 고비용 method, 나머지 7개는 다른 객체가 대신할 수 있는 가벼운 method가 있다고 가정하자.</p></blockquote><ul><li>이 때 <code>proxy를 생성</code>하여 <code>가벼운 method</code>를 처리하고, 고비용의 method가 필요한 시점에만 객체를 생성하는 것이다.</li></ul><h3 id="Proxy란-무엇인가"><a href="#Proxy란-무엇인가" class="headerlink" title="Proxy란 무엇인가?"></a>Proxy란 무엇인가?</h3><details><summary>사전적 정의</summary><ul><li><p>선거에서 자신에게 투표하는 것과 같이 다른 사람을 <code>대신하여 행동</code>하기 위해 사람에게 부여된 권한 또는 이 권한이 부여된 사람</p></li><li><p>대리 운전, 구매 대행, 대리인 등에 사용된다.</p></details></li></ul><hr><h2 id="2-장점"><a href="#2-장점" class="headerlink" title="2. 장점"></a>2. 장점</h2><ul><li><p>초기화 비용이 많이 들거나 복잡한 객체를 proxy를 통해 <code>Lazy</code>하게 처리할 수 있다.</p></li><li><p>객체의 접근에 대해 사전처리를 할 수 있다.</p></li></ul><hr><h2 id="3-단점"><a href="#3-단점" class="headerlink" title="3. 단점"></a>3. 단점</h2><ul><li>객체 생성 시 <code>proxy</code>를 거치게 되고, proxy 내부에 동기화가 필요한 경우, 성능 저하의 우려가 있다.</li></ul><hr><h2 id="4-구현"><a href="#4-구현" class="headerlink" title="4. 구현"></a>4. 구현</h2><p><img src="https://reactiveprogramming.io/books/patterns/img/patterns-articles/proxy-diagram.png" alt="UML Diagram"></p><h3 id="1-IObject"><a href="#1-IObject" class="headerlink" title="1. IObject"></a>1. IObject</h3><ul><li><code>객체</code>와 <code>proxy</code>의 추상화 객체이다.</li></ul><h3 id="2-Object"><a href="#2-Object" class="headerlink" title="2. Object"></a>2. Object</h3><ul><li>클라이언트가 실제로 접근하려는 객체</li></ul><h3 id="3-Proxy"><a href="#3-Proxy" class="headerlink" title="3. Proxy"></a>3. Proxy</h3><ul><li>Object에 접근 시 Object 앞 단에서 접근을 제어하는 proxy 객체</li></ul><hr><h2 id="5-흐름"><a href="#5-흐름" class="headerlink" title="5. 흐름"></a>5. 흐름</h2><p><img src="https://reactiveprogramming.io/books/patterns/img/patterns-articles/proxy-sequence.png" alt="Sequence Diagram"></p><ol><li>Client가 요청을 보내면 proxy를 return 해준다.</li><li>실제 객체가 필요한 요청을 보낼 때만 실제 객체가 호출되고, 나머지는 <code>proxy</code>가 처리해준다. </li></ol><hr><h2 id="6-활용"><a href="#6-활용" class="headerlink" title="6. 활용"></a>6. 활용</h2><ul><li><p>사용자가 서비스에 접근할 때 권한이 있는지 proxy를 통해 체크하고, 유효할 때만 실제 객체에 접근할 수 있도록 구성할 수 있다.</p></li><li><p>큰 이미지 파일과, 텍스트가 같이 있는 웹 페이지에 접근 시 무거운 이미지가 load 될 동안 텍스트를 먼저 제공하도록 구성한다.  </p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Design Pattern" scheme="http://inwoo.github.io/categories/Design-Pattern/"/>
    
    
    <category term="Factory Method Pattern" scheme="http://inwoo.github.io/tags/Factory-Method-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>팩토리 메서드 패턴 (Factory Method Pattern)</title>
    <link href="http://inwoo.github.io/12/11/FactoryMethod/"/>
    <id>http://inwoo.github.io/12/11/FactoryMethod/</id>
    <published>2021-12-11T08:01:58.000Z</published>
    <updated>2021-12-11T08:02:21.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><hr><h2 id="1-정의"><a href="#1-정의" class="headerlink" title="1. 정의"></a>1. 정의</h2><p>생성 패턴 중 하나로, <code>인스턴스의 생성</code>을 하위 클래스에서 위임한다.</p><p><code>new</code>를 통해 객체를 생성할 수도 있지만, <code>factory method</code>를 통해 <code>동적으로</code> 생성할 수 있다.</p><ul><li>예시) Map 등의 구조를 통해 keyword에 해당하는 객체를 생성해준다.</li></ul><p>Template method에서 생성되는 부분만 <code>abstract</code>로 설정하여 패턴을 적용할 수도 있다.</p><h2 id="2-장점"><a href="#2-장점" class="headerlink" title="2. 장점"></a>2. 장점</h2><ul><li><p><code>클라이언트</code>와 객체 <code>생성 모듈</code> 간의 결합도를 낮출 수 있다.</p></li><li><p>결합도가 낮고, 자료형이 하위 클래스에 의해 결정되기 때문에 <code>확장이 용이</code>하다.</p></li><li><p>여러 객체를 <code>동일한 형태</code>로 프로그래밍 할 수 있다.</p></li></ul><h2 id="3-단점"><a href="#3-단점" class="headerlink" title="3. 단점"></a>3. 단점</h2><ul><li><p>객체가 늘어날수록 클래스 수가 많아져 복잡도가 증가한다.</p></li><li><p>객체가 추가되면 하위 클래스를 재정의 해주어야한다.</p></li></ul><h2 id="4-구현"><a href="#4-구현" class="headerlink" title="4. 구현"></a>4. 구현</h2><p><img src="https://reactiveprogramming.io/books/patterns/img/patterns-articles/factory-method-diagram.png" alt="UML Diagram"></p><ol><li><p>IProduct: 원하는 객체를 추상화하여 생성한다 (Inteface)</p></li><li><p>Concrete Product: 객체를 생성한다.</p></li><li><p>Abstract Factory: 객체를 생성할 <code>Factory</code> 객체를 추상화하여 생성한다.</p><ul><li>Concrete Factory의 <code>default</code> 동작을 추가하기 위한 권고 사항이다.</li><li><code>Template Method Pattern</code>의 변하는 부분을 생성을 담당하는 factory에 위임하는 것이다.</li></ul></li><li><p>Concrete Factory: 분기 등을 통해 객체를 생성할 로직을 작성한다.</p></li></ol><h2 id="5-패턴의-흐름"><a href="#5-패턴의-흐름" class="headerlink" title="5. 패턴의 흐름"></a>5. 패턴의 흐름</h2><p><img src="https://reactiveprogramming.io/books/patterns/img/patterns-articles/factory-method-sequence.png" alt="Sequence Diagram"></p><ol><li><p>Client가 객체 생성 메서드를 호출한다.</p></li><li><p>Concrete Factory가 분기를 통해 알맞은 객체를 생성하여 전달한다.</p></li></ol><h2 id="6-활용"><a href="#6-활용" class="headerlink" title="6. 활용"></a>6. 활용</h2><ul><li><p>생성해야 하는 객체를 예측할 수 없을 때</p></li><li><p>동적으로 객체를 생성하고 싶을 때</p></li></ul><p>Application에 1개 이상의 DB를 연결할 때, 동적으로 필요한 DB Connection을 생성하여 전달할 수 있다.</p><ul><li>이 때 Connection을 매번하는 것은 많은 비용이 요구되므로, 상황을 고려하여 static 등으로 할당해 놓는 것이 좋을 거 같다.</li></ul><p><img src="https://reactiveprogramming.io/books/patterns/img/patterns/factory-method.png" alt="DB에 적용"></p><p>참고 : <a href="https://reactiveprogramming.io/blog/en/design-patterns/factory-method">Reactive Programming</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Design Pattern" scheme="http://inwoo.github.io/categories/Design-Pattern/"/>
    
    
    <category term="Factory Method Pattern" scheme="http://inwoo.github.io/tags/Factory-Method-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>JPA의 트랜잭션</title>
    <link href="http://inwoo.github.io/12/03/transaction/"/>
    <id>http://inwoo.github.io/12/03/transaction/</id>
    <published>2021-12-03T12:56:58.000Z</published>
    <updated>2021-12-03T12:59:34.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><hr><h1 id="트랜잭션의-특징-ACID"><a href="#트랜잭션의-특징-ACID" class="headerlink" title="트랜잭션의 특징, ACID"></a>트랜잭션의 특징, ACID</h1><h2 id="Atomicity-원자성"><a href="#Atomicity-원자성" class="headerlink" title="Atomicity(원자성)"></a>Atomicity(원자성)</h2><p>부분적인 성공을 허용하지 않고, <code>All or Nothing</code><br>실패 시 모두 실패, 성공 시 모두 성공한다.</p><h2 id="Consistency-일관성"><a href="#Consistency-일관성" class="headerlink" title="Consistency(일관성)"></a>Consistency(일관성)</h2><p>데이터의 정합성을 뜻한다</p><h2 id="Isolation-독립성"><a href="#Isolation-독립성" class="headerlink" title="Isolation(독립성)"></a>Isolation(독립성)</h2><p>트랜잭션 내의 데이터에 대해서는 다른 트랜잭션으로부터 독립적이다.</p><h2 id="Durability-지속성"><a href="#Durability-지속성" class="headerlink" title="Durability(지속성)"></a>Durability(지속성)</h2><p>데이터는 영구적으로 보관된다.</p><hr><h1 id="CheckedException"><a href="#CheckedException" class="headerlink" title="CheckedException"></a>CheckedException</h1><p><code>Exception 클래스</code>가 CheckedException이다. 명시적으로 Exception처리를 해주어야한다.</p><p><code>Transaction</code>내에서 Exception이 발생하여도 rollback되지 않고 <code>commit</code>된다.</p><ul><li>개발자가 해당 예외처리에 대한 책임을 가지게 된다.</li><li>catch 구문에서 rollback을 명시적으로 등록해주어야한다.</li></ul><h2 id="소스-코드-확인해보기"><a href="#소스-코드-확인해보기" class="headerlink" title="소스 코드 확인해보기"></a>소스 코드 확인해보기</h2><p><code>package org.springframework.transaction.interceptor</code>의 추상 클래스인 <code>TransactionAspectSupport</code>를 찾아보았다.</p><blockquote><p><code>invokeWithinTransaction()</code> 메서드를 확인해보면 아래와 같이 구성되어 있다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line"><span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// target invocation exception</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Exception이 발생하면 catch 구문에 들어가게 되고 <code>completeTransactionAfterThrowing()</code> 메서드가 실행된다.</p></blockquote><p>Transaction의 속성을 <code>rollbackOn()</code>으로 체크하게 되고, true일 시 rollback()을, 아닐 결우에는 commit을 하게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We don&#x27;t roll back on this exception.</span></span><br><span class="line"><span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rollbackOn()메서드는 <code>RuntimeException</code>과 <code>Error</code> 타입을 잡아낸다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rollbackOn</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CheckedException에서-Rollback을-하는-방법"><a href="#CheckedException에서-Rollback을-하는-방법" class="headerlink" title="CheckedException에서 Rollback을 하는 방법"></a>CheckedException에서 Rollback을 하는 방법</h2><p>@Transactional의 소스 코드를 확인해보자. (org.springframework.transaction.annotation.Transactional)</p><p>180번 라인에 <code>rollbackFor</code>라는 클래스가 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>아래와 같이 명시해주면 <code>Exception</code>클래스가 <code>rollbackOn</code>에 들어가게 되고, rollback 메서드가 수행된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackfor = Exception.class)</span></span><br></pre></td></tr></table></figure><hr><h1 id="동일한-클래스-내에서-Transactional-메서드-호출"><a href="#동일한-클래스-내에서-Transactional-메서드-호출" class="headerlink" title="동일한 클래스 내에서 @Transactional 메서드 호출"></a>동일한 클래스 내에서 @Transactional 메서드 호출</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.testTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 코드를 작성하고, <code>test()</code>를 호출하면 에러가 발생해도 @Transactional이 없는 것과 같이 rollback이 되지 않고 <code>commit</code>이 된다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/result-3.png"></p><p>이는 <code>Spring AOP</code>와 관련이 있다. Spring AOP는 프록시 기반으로 Bean <code>외부에서 메서드가 호출될 때</code> Annotation를 인식한다.</p><p>위 코드는 외부가 아닌 내부에서 호출을 하여 <code>@Transactional</code>이 동작하지 않는 것이다.</p><p>참고 : <a href="https://stackoverflow.com/questions/3423972/spring-transaction-method-call-by-the-method-within-the-same-class-does-not-wo">Spring @Transaction method call by the method within the same class, does not work?</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Basic" scheme="http://inwoo.github.io/categories/Basic/"/>
    
    <category term="JPA" scheme="http://inwoo.github.io/categories/Basic/JPA/"/>
    
    
    <category term="트랜잭션" scheme="http://inwoo.github.io/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"/>
    
  </entry>
  
  <entry>
    <title>영속성 컨텍스트 (Persistence Context)</title>
    <link href="http://inwoo.github.io/12/03/persistenceContext/"/>
    <id>http://inwoo.github.io/12/03/persistenceContext/</id>
    <published>2021-12-03T07:22:31.000Z</published>
    <updated>2021-12-03T08:14:57.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><p>일종의 JPA 컨테이너 안에서 동작하는 Entity의 Context를 관리하는 것.</p><p>Context내에서 CRUD가 일어나는데, 실제로 영속성 컨텍스트의 주체적인 역할을 하는 것은 <code>Entity Manager</code> Bean이다.</p><p>EntityManager를 <code>@Autowired</code>해서 사용할 수도 있다.</p><blockquote><p>Spring Data JPA는 EM을 사용하지 않고 쿼리를 실행할 수 있도록 도와준다.</p><p>Spring DATA JPA에서 제공하지 않는 custom query는 EntityManager를 직접받아서 처리하면 된다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EntityMangager entityMangaer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(entityMangaer.createQuery(<span class="string">&quot;select u from User u&quot;</span>).getResultList());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 실행하면 <code>userRepository.finaAll()</code>을 실행한 것과 같은 결과가 나온다.</p><hr><h1 id="1차-캐시-Id-값"><a href="#1차-캐시-Id-값" class="headerlink" title="1차 캐시 (Id 값)"></a>1차 캐시 (Id 값)</h1><p>영속성 컨텍스트 내에서 Entity를 관리하는 Entity Manager는 <code>캐시</code>를 가지고 있다.</p><blockquote><p>Entity의 Id를 작업을 수행할 때 별도로 Cache 처리를 하지 않아도, 영속성 컨텍스트에서 자동으로 Entity에 대한 Cache처리를 해주는 것이다.</p></blockquote><p>메서드에 <code>@Transactional</code>을 설정하고, 조회를 여러 번 하는 코드를 작성하면 조회는 한 번만 하지만 데이터를 계속해서 가져올 수 있다. 이는 영속성 컨텍스트에 존재하는 Entity Cache에서 가져온 것이다.</p><p><strong>메서드에 <code>@Transactional</code>을 설정을 하지 않으면 JPA 메서드는 내부적으로 <code>@Transactional</code>이 설정되어 있기 때문에, 실행할 때마다 캐시를 사용하지 않고 DB와 연동을 하게 된다.</strong></p><p>예시</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">saveAndFlush</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    S result = save(entity);</span><br><span class="line">    flush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="캐시-자료구조"><a href="#캐시-자료구조" class="headerlink" title="캐시 자료구조"></a>캐시 자료구조</h2><p><strong>1차 캐시는 Map 형태로 생성된다.</strong></p><ul><li>Key는 id</li><li>Value는 해당 Entity 가 들어있다.</li></ul><blockquote><p>Id 값으로 조회할 때 영속성 Context에 존재하는 1차 캐시에 존재하는지 체크하고, 있으면 캐시에서 가져오고, 없으면 DB 조회를 한다.</p></blockquote><hr><h2 id="DB-반영-시점"><a href="#DB-반영-시점" class="headerlink" title="DB 반영 시점"></a>DB 반영 시점</h2><ol><li><code>flush()</code> 메서드를 명시적으로 호출하는 시점</li><li><code>Transaction</code>이 끝나서 쿼리가 commit 되는 시점</li><li><code>JPQL</code> 쿼리가 실행되는 시점</li></ol><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p>영속성 Context가 존재하여 JPA는 <code>지연 쓰기</code>가 발생한다. 즉 save 하는 시점에 바로 DB에 반영되지 않는다.</p><p><code>@Transactional</code>이 존재하는 상태에서 <code>delete</code>, <code>update</code>를 실행하여도 조회만 일어나고, 이에 대한 쿼리는 발생하지 않는다.</p><p>EntityManager가 Entity의 상태를 merge하고, 최종적으로 반영해야 되는 내용에 대해서만 쿼리가 실행된다</p><p><strong>Transaction이 묶여 있지 않으면, 메서드가 실행되는 도중에 실패하게 되면 앞에 있는 쿼리는 실행되고, 실행되지 못한 쿼리는 반영되지 않는 현상이 발생한다.</strong></p><blockquote><p><code>flush()</code> 메서드를 통해 DB에 반영하는 시점을 정할 수 있다.</p></blockquote><blockquote><p><code>saveAndFlush()</code> 메서드를 사용하면 저장과 동시에 반영할 수 있다.</p></blockquote><hr><h2 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h2><h3 id="persistence-xml을-통한-설정"><a href="#persistence-xml을-통한-설정" class="headerlink" title="persistence.xml을 통한 설정"></a>persistence.xml을 통한 설정</h3><p><code>LocalContainerEntityManagerFactoryBean</code> 클래스의 <code>setPersistenceXmlLocation()</code>에 의해 <code>resources - META-INF - persistence.xml</code>로 저장 위치와 파일 이름이 고정되어 있다.</p><h3 id="application-yml을-통한-설정"><a href="#application-yml을-통한-설정" class="headerlink" title="application.yml을 통한 설정"></a>application.yml을 통한 설정</h3><p>dependency에 <code>spring-boot-starter-data-jpa</code>를 추가하면 <code>Spring Boot</code>가 Context에 대한 설정을 처리해준다.</p><p>이후에 application.yml 파일에서 설정을 할 수 있다.</p><hr>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Basic" scheme="http://inwoo.github.io/categories/Basic/"/>
    
    <category term="JPA" scheme="http://inwoo.github.io/categories/Basic/JPA/"/>
    
    
    <category term="영속성 컨텍스트" scheme="http://inwoo.github.io/tags/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>JPA Listener 에서 Repository Injection</title>
    <link href="http://inwoo.github.io/12/01/jpainjection/"/>
    <id>http://inwoo.github.io/12/01/jpainjection/</id>
    <published>2021-12-01T12:02:09.000Z</published>
    <updated>2021-12-01T12:08:35.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><hr><p>JPA를 사용하면서 Listener를 생성할 때 당연하듯 <code>Listener 클래스</code>를 <code>@Component</code>를 통해 등록하고 내부에 <code>repository</code>를 injection하여 사용하였다.</p><p><strong>테스트 결과 repository에 NPE가 발생하였고, 원인을 찾아보았다.</strong></p><p>이를 이해하기 위해서는 Bean이 생성되는 과정을 알아야한다.</p><hr><h2 id="Bean이-생성되는-과정"><a href="#Bean이-생성되는-과정" class="headerlink" title="Bean이 생성되는 과정"></a>Bean이 생성되는 과정</h2><blockquote><p>1.Application 실행<br>2.EntityManagerFactory 등록<br>3.EntityManger 생성<br>4.SimpleJpaRepository 생성<br>5.JpaRepository 생성<br>6.Listener 생성</p></blockquote><ol><li>JpaRepository를 Bean으로 등록해주는 <code>EntityManagerFactroy</code>(이하 EMF)는<br><code>Application 실행</code>시 Bean으로 등록된다.<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3></li><li>EMF는 <code>EntityManger</code>를 생성해주는 클래스이다.<ul><li>EntityManager는 SharedEntityManagerCreator의 <code>createSharedEntityManager</code> 메서드에 의해 생성이되는데 EMF가 필수이다.</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EntityManager <span class="title">createSharedEntityManager</span><span class="params">(EntityManagerFactory emf)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> createSharedEntityManager(emf, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><ol start="3"><li>JpaRepository의 부모 클래스인 <code>SimpleJpaRepository</code>는 생성될 때 <code>EntityManager</code>가 필요하다.</li></ol><hr><h4 id="Listener를-Component로-명시하여-Scan을-하게-되면-Listener를-사용하기-위해-존재하여야-하는-객체들이-먼저-등록이-되기-전에-사용하려는-꼴이다"><a href="#Listener를-Component로-명시하여-Scan을-하게-되면-Listener를-사용하기-위해-존재하여야-하는-객체들이-먼저-등록이-되기-전에-사용하려는-꼴이다" class="headerlink" title="Listener를 Component로 명시하여 Scan을 하게 되면, Listener를 사용하기 위해 존재하여야 하는 객체들이 먼저 등록이 되기 전에 사용하려는 꼴이다."></a>Listener를 Component로 명시하여 Scan을 하게 되면, Listener를 사용하기 위해 존재하여야 하는 객체들이 먼저 등록이 되기 전에 사용하려는 꼴이다.</h4><blockquote><p>할아버지가 아버지를 낳지 않았는데, 내가 태어나려고 하는 상황과 유사하다.</p></blockquote><hr><h2 id="Listener에서-Repository-Injection-하는-방법"><a href="#Listener에서-Repository-Injection-하는-방법" class="headerlink" title="Listener에서 Repository Injection 하는 방법"></a>Listener에서 Repository Injection 하는 방법</h2><h3 id="1-ApplicationContext"><a href="#1-ApplicationContext" class="headerlink" title="1. ApplicationContext"></a>1. ApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> <span class="title">Implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">BeanUtils.applicationContext = applicationContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> applicationContext.getBean(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@PreUpdate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preUpdate</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">ExampleRepository er = BeanUtils.getBean(ExampleRepository.class);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Lazy-어노테이션"><a href="#2-Lazy-어노테이션" class="headerlink" title="2. @Lazy 어노테이션"></a>2. @Lazy 어노테이션</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonEntityListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ExampleRepository exampleRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreUpdate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preUpdate</span><span class="params">(Example example)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Basic" scheme="http://inwoo.github.io/categories/Basic/"/>
    
    <category term="JPA" scheme="http://inwoo.github.io/categories/Basic/JPA/"/>
    
    
    <category term="JPA" scheme="http://inwoo.github.io/tags/JPA/"/>
    
    <category term="Repository" scheme="http://inwoo.github.io/tags/Repository/"/>
    
  </entry>
  
  <entry>
    <title>PRG(Post-Redirect-Get) 패턴</title>
    <link href="http://inwoo.github.io/11/29/PRGPattern/"/>
    <id>http://inwoo.github.io/11/29/PRGPattern/</id>
    <published>2021-11-29T06:52:26.000Z</published>
    <updated>2021-11-29T07:19:10.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><p>최근 프로젝트에 대한 회고를 진행하며 HTTP <code>POST</code> 메서드의 <code>Double-Submit</code> 이슈를 발견하였다.</p><p>POST request에 대한 response가 <code>요청 처리 결과를 반환</code>할 때, 서버는 동일한 결과를 중복으로 처리하여 보여준다.</p><p>Double-Submit을 해결할 수 있는 방법에는 <code>Spring MVC의 어노테이션 기반 해결</code>, <code>JSP의 taglib 기반 해결</code> 등이 있지만, </p><p>이를 회피할 수 있는 또 하나의 방법인 <code>PRG(POST-REDIRECT-GET) 패턴</code>에 대해서 정리해보았다.</p><blockquote><h2 id="PRG-패턴이란"><a href="#PRG-패턴이란" class="headerlink" title="PRG 패턴이란 ?"></a>PRG 패턴이란 ?</h2></blockquote><p>HTTP <code>POST 요청</code>에 대한 응답을 <code>다른 URL에 대한 GET</code>방식의 페이지로 <code>Redirect</code> 시키는 패턴이다.</p><p><code>POST 메서드</code>는 <code>NON-idempotent</code>, 즉 멱등하지 않기 때문에 재요청에 대한 대비가 되어 있어야합니다.</p><p>반대로 <code>GET 메서드</code>는 멱등하기 때문에 재요청이 와도 조회만 반복해서 될 뿐 <code>서버의 리소스</code>에는 영향을 미치진 않습니다.</p><blockquote><h2 id="Spring-MVC의-PRG-패턴"><a href="#Spring-MVC의-PRG-패턴" class="headerlink" title="Spring MVC의 PRG 패턴"></a>Spring MVC의 PRG 패턴</h2></blockquote><p><img src="https://i.stack.imgur.com/CRxzJ.png" alt="PRG Pattern 출처 : Wikipedia"></p><p><code>Post 기반</code>의 결제를 위한 uri로 접근하여 pay() 메서드에 매핑이 되면 비즈니스 로직을 처리하고, GetMapping을 하는 <code>/order</code> 로 redirect 됩니다.</p><p>이 때 POST 요청이 들어오면 브라우저는 <code>302 응답 코드</code>를 받게 되고, <code>/order</code>로 redirect 됩니다.</p><p>결제는 POST로 하였지만, 결제 후에는 GET 메서드에 매핑이 되기 때문에 새로고침을 하여도 로직은 발생하지 않고, GET 메서드만 발생하게 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 비즈니스 로직</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/order&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">order</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;order&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Basic" scheme="http://inwoo.github.io/categories/Basic/"/>
    
    <category term="Web &amp; Network" scheme="http://inwoo.github.io/categories/Basic/Web-Network/"/>
    
    
    <category term="POST" scheme="http://inwoo.github.io/tags/POST/"/>
    
    <category term="GET" scheme="http://inwoo.github.io/tags/GET/"/>
    
  </entry>
  
  <entry>
    <title>템플릿 메서드 패턴 (Template Method Pattern)</title>
    <link href="http://inwoo.github.io/11/27/TemplateMethodPattern/"/>
    <id>http://inwoo.github.io/11/27/TemplateMethodPattern/</id>
    <published>2021-11-27T09:46:41.000Z</published>
    <updated>2021-11-28T05:22:43.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><h2 id="Template-Method-Pattern-템플릿-메서드-패턴"><a href="#Template-Method-Pattern-템플릿-메서드-패턴" class="headerlink" title="Template Method Pattern (템플릿 메서드 패턴)"></a>Template Method Pattern (템플릿 메서드 패턴)</h2><p><img src="https://miro.medium.com/max/786/1*pdT0SiFTawD8j4KWkJRvdA.png" alt="Template Method"></p><h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h3><p>비슷한 형태의 프로그램의 구현에 필요한 <code>뼈대를 일반화</code>하여 제공하는 패턴입니다.</p><p>알고리즘의 <code>구조를 변경하지 않고</code> 알고리즘의 각 단계별로 수행하는 구체적이고, 변화할 수 있는 코드를 <code>재정의</code>할 수 있다.</p><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><ul><li>소스 코드상의 알고리즘에서 재정의(확장, 변경 등)가 필요한 경우 유용하다.</li><li>코드의 중복이 감소된다.</li><li>핵심 로직 관리가 유용하다.</li></ul><h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h3><ul><li>추상 클래스와 자식 클래스의 복잡성이 높아진다</li></ul><hr><p><img src="https://miro.medium.com/max/838/0*F8RVTE7IqH2-DUP7.png" alt="Template Method UML"></p><h3 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h3><blockquote><ul><li>알고리즘을 구성하는 <code>메서드 목록</code>과 그 <code>호출 순서(알고리즘)</code>을 가진 <code>템플릿 메서드</code></li><li>서브클래스가 꼭 <code>Override</code> 해야 할 <code>추상 메서드</code></li><li>서브클래스가 <code>Override</code> 해도 되는 <code>훅 메서드</code>(hook method)</li></ul></blockquote><h4 id="hook-method-필요할-시-서브-클래스에서-확장할-수-있는-기본적인-행동을-제공하는-메서드"><a href="#hook-method-필요할-시-서브-클래스에서-확장할-수-있는-기본적인-행동을-제공하는-메서드" class="headerlink" title="hook method : 필요할 시 서브 클래스에서 확장할 수 있는 기본적인 행동을 제공하는 메서드"></a>hook method : 필요할 시 서브 클래스에서 확장할 수 있는 기본적인 행동을 제공하는 메서드</h4><h3 id="고려-사항"><a href="#고려-사항" class="headerlink" title="고려 사항"></a>고려 사항</h3><ul><li>템플릿 메서드 내의 알고리즘에 해당하는 메서드를 <strong>템플릿 메서드만 사용할 수 있도록 한다.</strong><ul><li>Keyword : <code>protected</code></li></ul></li><li><code>템플릿 메소드</code>는 오버라이드 할 수 없도록 구현한다.<ul><li>Keyword : <code>final</code></li></ul></li><li>추상 메소드는 접두사를 붙여 <code>가독성</code>을 높여준다.</li></ul><h3 id="예제-코드"><a href="#예제-코드" class="headerlink" title="예제 코드"></a>예제 코드</h3><ul><li><code>공통되는 로직</code>과 <code>개별 로직의 분리</code></li><li>개별 로직 구현</li></ul><h3 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryExecuteDB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Connection conn;</span><br><span class="line">    PreparedStatement stmt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        getConnection();</span><br><span class="line">        executeQuery();</span><br><span class="line">        closeConnection(stmt, conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DB 연동</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DB가 연결되었습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DB 연결 종료</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">(PreparedStatement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DB 연결이 종료되었습니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">executeQuery</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Concrete-Class"><a href="#Concrete-Class" class="headerlink" title="Concrete Class"></a>Concrete Class</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateExecution</span> <span class="keyword">extends</span> <span class="title">QueryExecuteDB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Create Query가 실행됩니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteExecution</span> <span class="keyword">extends</span> <span class="title">QueryExecuteDB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Delete Query가 실행됩니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Design Pattern" scheme="http://inwoo.github.io/categories/Design-Pattern/"/>
    
    
    <category term="Template Method Pattern" scheme="http://inwoo.github.io/tags/Template-Method-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP, TCP, 3-way-handshaking</title>
    <link href="http://inwoo.github.io/11/18/0-interview-network2/"/>
    <id>http://inwoo.github.io/11/18/0-interview-network2/</id>
    <published>2021-11-18T05:25:00.000Z</published>
    <updated>2021-11-18T05:27:19.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><h2 id="2-TCP-IP-프로토콜을-4계층-설명하시오"><a href="#2-TCP-IP-프로토콜을-4계층-설명하시오" class="headerlink" title="2. TCP/IP 프로토콜을 4계층 설명하시오"></a>2. TCP/IP 프로토콜을 4계층 설명하시오</h2><p><img src="https://images.velog.io/images/jehjong/post/68e38b79-1117-4d48-b7c9-e04454205daa/image.png" alt="Layer"></p><p><strong>LINK 계층</strong><br>OSI 7 Layer의 물리적인 영역을 표준화 시킨 계층이다.</p><p>LAN, WAN과 같은 네트워크 표준과 관련된 <code>프로토콜을 정의</code>하며, 물리적인 주소로 MAC을 사용한다.</p><blockquote><p>프로토콜 :  Ethernet, PPP, Token Ring 등</p></blockquote><p><strong>IP 계층</strong><br>OSI 7 Layer의 네트워크 계층에 해당하며, <code>라우팅</code>을 해주는 계층이다.</p><p>IP 자체는 비-연결 지향적이며, 신뢰할 수 없는 프로토콜이다.</p><p>패킷을 전송할 때마다 불규칙적으로 라우팅해주고, 전송 중에 패킷이 손실되거나 오류가 발생할 수 있다.</p><blockquote><p>프로토콜 :  IP, ARP, RARP</p></blockquote><p><strong>TCP/UDP 계층</strong><br>OSI 7 Layer의 전송 계층에 해당하며, 포트를 통해 <code>데이터의 실제 송수신</code>을 담당하는 영역이다.</p><p>UDP는 비연결형 프로토콜이며, 연결형 프로톨인 TCP에 비해 전송 속도가 빠르다.</p><blockquote><p>프로토콜 : TCP, UDP, RTP, RTCP 등</p></blockquote><p><strong>Application 계층</strong><br>OSI 7 Layer의 응용 계층에 해당하며, <code>사용자</code>가 <code>application</code>과 <code>소통</code>할 수 있게 해준다.</p><p>Application들이 데이터를 교환하기 위해 사용되는 프로토콜을 사용한다.</p><blockquote><p>프로토콜 : FTP, HTTP, SSH, Telnet, DNS, SMTP 등</p></blockquote><h3 id="2-1-신뢰할-수-없는-IP-프로토콜을-사용할-때-패킷을-보호할-수-있는-기술"><a href="#2-1-신뢰할-수-없는-IP-프로토콜을-사용할-때-패킷을-보호할-수-있는-기술" class="headerlink" title="2-1. 신뢰할 수 없는 IP 프로토콜을 사용할 때 패킷을 보호할 수 있는 기술"></a>2-1. 신뢰할 수 없는 IP 프로토콜을 사용할 때 패킷을 보호할 수 있는 기술</h3><p>패킷을 <code>암호화</code>, <code>전자 서명</code> 등을 통해 패킷 스니핑을 당했을 때 정보가 유출되지 않게하거나,</p><p>SSH, SSL과 같은 <code>보안 프로토콜</code>을 통해 통신의 안정성을 강화할 수 있다.</p><hr><h2 id="3-TCP란"><a href="#3-TCP란" class="headerlink" title="3. TCP란 ?"></a>3. TCP란 ?</h2><p>TCP는 연결형 프로토콜로 데이터 전송 시 <code>전송 순서</code>와 <code>신뢰성</code>을 보장한다.</p><p>통신을 위한 Path를 만들어놓고, 송수신이 종료되면 연결을 끊는다.</p><p>신뢰성 보장을 위한 절차가 포함되어 UDP에 비해 속도가 느리다.</p><h3 id="3-1-서버와-클라이언트-통신-과정-함수-호출-순서"><a href="#3-1-서버와-클라이언트-통신-과정-함수-호출-순서" class="headerlink" title="3-1. 서버와 클라이언트 통신 과정 (함수 호출 순서)"></a>3-1. 서버와 클라이언트 통신 과정 (함수 호출 순서)</h3><p>서버가 연결해요청 <code>대기 큐를 생성</code>하고, <code>소켓 주소를 할당</code>하고 <code>대기</code>한다.</p><p>클라이언트가 적절한 포트를 통해 <code>연결 요청</code>을 하고,</p><p>서버에서 <code>accept</code> 하기 전까지 <code>block</code>되었다가 accpt를 하면 데이터를 송수신하게 됩니다.</p><h3 id="3-2-TCP의-Header"><a href="#3-2-TCP의-Header" class="headerlink" title="3-2. TCP의 Header"></a>3-2. TCP의 Header</h3><p>통신을 위한 <code>Source port</code>와 <code>Destination Port</code> 정보</p><p>데이터 순서 보장을 위한 <code>sequnece number</code></p><p>연결 설정 및 종료와 관련된 <code>code bits</code> 등이 있다.</p><ul><li>URG, ACK, PSH, RST, SYN, FIN</li></ul><h3 id="3-3-TCP에서-데이터-순서를-보장하는-방법"><a href="#3-3-TCP에서-데이터-순서를-보장하는-방법" class="headerlink" title="3-3. TCP에서 데이터 순서를 보장하는 방법"></a>3-3. TCP에서 데이터 순서를 보장하는 방법</h3><p>흐름제어 : 송신 측과 수신 측의 데이터 처리 속도 차이 조절</p><p>혼잡제어 : 네트워크 내 트래픽을 고려해서 패킷의 양을 설정하는 알고리즘</p><hr><h2 id="4-3-way-handshaking이란"><a href="#4-3-way-handshaking이란" class="headerlink" title="4. 3-way handshaking이란?"></a>4. 3-way handshaking이란?</h2><p>서버와 클라이언트가 TCP를 통해 연결할 때 연결 설정 과정 중 일어나는 3번의 통신</p><p>TCP 헤더에 담긴 <code>code bits</code> 중 <code>SYN</code>, <code>ACK</code>를 사용한다.</p><ul><li>SYN : 연결 요청 플래그</li><li>ACK : 응답</li></ul><ol><li><p>클라이언트에서 연결 요청을 위해 SYN(M) 패킷을 보낸다.</p></li><li><p>서버에서는 SYN(M)을 받고, 수락 시 ACK(M+1)과 SYN(N)을 보낸다.</p></li><li><p>클라이언트는 패킷을 받고, ACK(N+1)을 서버로 다시 보낸다.</p></li></ol><h3 id="4-1-4-way-handshaking이란"><a href="#4-1-4-way-handshaking이란" class="headerlink" title="4-1. 4-way handshaking이란?"></a>4-1. 4-way handshaking이란?</h3><ol><li><p>클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.</p></li><li><p>서버가 패킷을 받고, 확인 메시지로 ACK을 보낸다.</p><ul><li>데이터가 모두 보내질 때까지 TIME_OUT이 된다.</li></ul></li><li><p>데이터가 다 보내지고, 통신이 끝나면 서버에서 클라이언트로 FIN 플래그를 보낸다.</p></li><li><p>클라이언트는 FIN을 받고 ACK를 서버로 보낸다.</p></li><li><p>클라이언트는 서버로부터 아직 받지 못한 데이터가 있는 상황을 대비하여, 일정 시간동안 세션을 남겨놓고, 잉여 패킷을 기다리다가 완전 종료된다.</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Interview" scheme="http://inwoo.github.io/categories/Interview/"/>
    
    <category term="Network" scheme="http://inwoo.github.io/categories/Interview/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Security 개요</title>
    <link href="http://inwoo.github.io/11/16/springsecurity/"/>
    <id>http://inwoo.github.io/11/16/springsecurity/</id>
    <published>2021-11-16T11:20:53.000Z</published>
    <updated>2021-11-16T14:12:51.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><p><img src="https://cdn.inflearn.com/public/files/courses/324591/1a3def63-c35e-4e6a-83b6-b8d970594046/spring-security-bgd.png" alt="Spring Security"></p><h1 id="해결하려는-문제"><a href="#해결하려는-문제" class="headerlink" title="해결하려는 문제"></a>해결하려는 문제</h1><blockquote><h3 id="웹사이트의-보안"><a href="#웹사이트의-보안" class="headerlink" title="웹사이트의 보안"></a>웹사이트의 보안</h3></blockquote><p>웹 사이트에는 여러 서비스를 배포하기 위한 리소스와, 이를 사용하는 유저들의 정보가 담겨있습니다.</p><p>악의적인 접근으로 부터 이 리소스를 보호하기 위해 <code>Security Library</code>가 사용됩니다.</p><h2 id="인증-Authentication"><a href="#인증-Authentication" class="headerlink" title="인증 (Authentication)"></a>인증 (Authentication)</h2><p>모든 사용자에게 열려있는 페이지도 있지만, <code>특정 리소스</code>에 접근하거나, <code>private 사용</code>을 보장하기 위해 일반적으로 Login 하는 과정이 필요합니다. </p><p>Login은 기존에 ID와 Password를 입력하여 로그인하였으나, 최근에 생긴 페이지들에서는 <code>KAKAO</code>, <code>NAVER</code> 등을 통해 인증을 대리하는 추세입니다. </p><p>Login 후 인증을 기존에는 <code>Session</code>으로 관리하였으나, 최근에는 서비스가 확장되며 서버들을 <code>scale-out</code>을 해나가면서<br>session을 분산해서 저장하고, 동기화가 필요해졌습니다.</p><p>이를 보완하기 위해 <code>session-less</code>의 <code>token 관리</code> 방식으로 인증을 하기 시작하고 있습니다.</p><h3 id="권한-인가-Authorization"><a href="#권한-인가-Authorization" class="headerlink" title="권한, 인가 (Authorization)"></a>권한, 인가 (Authorization)</h3><p>Login을 완료한 후에 이 사용자가 가진 권한으로 어떤 일을 할 수 있는지 설정합니다. 크게는 <code>관리자(ADMIN)</code>, <code>사용자(USER)</code>로 권한을 설정합니다.</p><p>웹 서비스를 개발할 때에 권한이 있는 사용자만 <code>특정 uri</code>, <code>리소스</code>에 접근할 수 있도록 하여야합니다.</p><p>이는 <code>Spring Security Framework</code>을 통해 보다 쉽게 구현할 수 있습니다.</p><p>비즈니스 로직이 복잡해지고, annotaion으로 체크하는 것이 어려워지면 AOP 등 다양한 방법을 사용한다. 권한을 다루는 방법은 무수히 많습니다.</p><hr><h1 id="예제-코드"><a href="#예제-코드" class="headerlink" title="예제 코드"></a>예제 코드</h1><h2 id="aaplication-yml"><a href="#aaplication-yml" class="headerlink" title="aaplication.yml"></a>aaplication.yml</h2><p>Login과 권한 테스트를 위해 yml파일에 user 1명을 생성해주었습니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">user1</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">1111</span></span><br><span class="line">      <span class="attr">roles:</span> <span class="string">USER</span></span><br></pre></td></tr></table></figure><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p><strong>index</strong> : uri를 <code>/</code>로 설정하고, “홈페이지”라는 String을 return 해주는 페이지<br><img src="/image/secureindex.png" alt="Index Page"></p><p><strong>/auth</strong> : SecurityContextHolder를 통해 사용자의 권한 등 세부 사항을 return 해주는 페이지<br><img src="/image/secureauth.png" alt="/Auth Page"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;홈페이지&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/auth&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">auth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SecurityContextHolder.getContext()</span><br><span class="line">                .getAuthentication();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>@PreAuthorize 어노테이션을 사용하여 특정 권한을 가진 사람만 접근 허용</p></blockquote><p><code>SecurityMessage</code>라는 POJO를 만들어 Authentication과 String 타입을 갖는 변수들을 선언해주었습니다.</p><details><summary>SecurityMessage 코드 보기</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Authentication auth;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><code>/user</code> 에는 USER라는 권한(ROLE)을 가진 사람, <code>/admin</code>에는 ADMIN 권한을 가진 사람만 접근할 수 있도록 해주었습니다.</p><p>아직까지는 <code>application.yml</code>에서 설정한 user의 <code>roles</code>는 <code>USER</code>이지만 <code>/admin</code>에도 접근이 가능합니다.</p><p><strong>@PreAuthorize(“hasZnyAuthority(‘ROLE’)”)</strong> 을 활성화 시켜주기 위해서는 <code>WebSecurityConfigurerAdapter</code> 클래스를 extends한 클래스가 존재해야하고, 추가로 annotation을 설정해주어야 합니다..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;ROLE_USER&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityMessage <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SecurityMessage.builder()</span><br><span class="line">            .auth(SecurityContextHolder.getContext().getAuthentication())</span><br><span class="line">            .message(<span class="string">&quot;User 정보&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;ROLE_ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityMessage <span class="title">admin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SecurityMessage.builder()</span><br><span class="line">            .auth(SecurityContextHolder.getContext().getAuthentication())</span><br><span class="line">            .message(<span class="string">&quot;관리자 정보&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Config-Class"><a href="#Config-Class" class="headerlink" title="Config Class"></a>Config Class</h2><h3 id="1-PreAuthorize를-활성화시키기-위해-SecurityConfig라는-클래스를-만들어-WebSecurityConfigurerAdapter를-extends-해주었습니다"><a href="#1-PreAuthorize를-활성화시키기-위해-SecurityConfig라는-클래스를-만들어-WebSecurityConfigurerAdapter를-extends-해주었습니다" class="headerlink" title="1. @PreAuthorize를 활성화시키기 위해 SecurityConfig라는 클래스를 만들어 WebSecurityConfigurerAdapter를 extends 해주었습니다."></a>1. <code>@PreAuthorize</code>를 활성화시키기 위해 SecurityConfig라는 클래스를 만들어 <code>WebSecurityConfigurerAdapter</code>를 extends 해주었습니다.</h3><h3 id="2-EnableWebSecurity-debug-true-default-값은-false이지만-security를-debug로-실행시키기-위해-추가하였습니다"><a href="#2-EnableWebSecurity-debug-true-default-값은-false이지만-security를-debug로-실행시키기-위해-추가하였습니다" class="headerlink" title="2. @EnableWebSecurity(debug = true) : default 값은 false이지만 security를 debug로 실행시키기 위해 추가하였습니다."></a>2. @EnableWebSecurity(debug = true) : default 값은 false이지만 security를 debug로 실행시키기 위해 추가하였습니다.</h3><h3 id="3-EnableGlobalMethodSecurity-prePostEnabled-true-prePostEnabled를-true로-설정하였습니다"><a href="#3-EnableGlobalMethodSecurity-prePostEnabled-true-prePostEnabled를-true로-설정하였습니다" class="headerlink" title="3. @EnableGlobalMethodSecurity(prePostEnabled = true) : prePostEnabled를 true로 설정하였습니다."></a>3. @EnableGlobalMethodSecurity(prePostEnabled = true) : prePostEnabled를 true로 설정하였습니다.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity(debug = true)</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 활성화를 시키면 USER 권한을 가진 사용자가 <code>/admin</code>에 접근할 때 아래와 같이 403에러가 발생한다.</p><p><img src="/imgae/secure403.png" alt="권한 관련 Error"></p><h3 id="접근-테스트를-위해-WebSecurityConfigurerAdapter-를-extends한-클래스-내에서-user를-생성하여-테스트-할-수-있다"><a href="#접근-테스트를-위해-WebSecurityConfigurerAdapter-를-extends한-클래스-내에서-user를-생성하여-테스트-할-수-있다" class="headerlink" title="접근 테스트를 위해 WebSecurityConfigurerAdapter 를 extends한 클래스 내에서 user를 생성하여 테스트 할 수 있다."></a>접근 테스트를 위해 WebSecurityConfigurerAdapter 를 extends한 클래스 내에서 user를 생성하여 테스트 할 수 있다.</h3><hr><h2 id="User-Test"><a href="#User-Test" class="headerlink" title="User Test"></a>User Test</h2><p><code>WebSecurityConfigurerAdapter</code>는 <code>configure(AuthenticationManagerBuilder auth)</code> 메서드를 가지고 있는데, parameter에서도 알 수 있듯이 AuthenticationManager를 Build하여 생성할 수 있다.</p><h4 id="configure-AuthenticationManagerBuilder-auth-메서드를-override하게-되면-application-yml에서-설정한-user는-사용할-수-없다"><a href="#configure-AuthenticationManagerBuilder-auth-메서드를-override하게-되면-application-yml에서-설정한-user는-사용할-수-없다" class="headerlink" title="configure(AuthenticationManagerBuilder auth) 메서드를 override하게 되면 application.yml에서 설정한 user는 사용할 수 없다."></a>configure(AuthenticationManagerBuilder auth) 메서드를 override하게 되면 <code>application.yml</code>에서 설정한 user는 사용할 수 없다.</h4><p>아래 코드를 통해 <code>inMemoryAuthentication</code> 방식으로 user 2명을 생성하였다. </p><blockquote><p>이 때 유의할 점은 password를 등록할 때 암호화를 해주어야 한다는 것이다.</p><p>아직까지는 ADMIN 권한을 가진 user는 /admin에만, USER 권한은 /user에만 접근할 수 있다.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(User.builder()</span><br><span class="line">                    .username(<span class="string">&quot;user2&quot;</span>)</span><br><span class="line">                    .password(passwordEncoder().encode(<span class="string">&quot;2222&quot;</span>))</span><br><span class="line">                    .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">            ).withUser(User.builder()</span><br><span class="line">                    .username(<span class="string">&quot;user3&quot;</span>)</span><br><span class="line">                    .password(passwordEncoder().encode(<span class="string">&quot;3333&quot;</span>))</span><br><span class="line">                    .roles(<span class="string">&quot;ADMIN&quot;</span>))</span><br><span class="line">            ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="누구나-접근할-수-있는-페이지"><a href="#누구나-접근할-수-있는-페이지" class="headerlink" title="누구나 접근할 수 있는 페이지"></a>누구나 접근할 수 있는 페이지</h2><p>권한에 상관없이 누구나 접근할 수 있는 페이지도 <code>configure(HttpSecurity http)</code> 메서드로 설정할 수 있다.</p><p>index 페이지인 <code>/</code>를 누구나 접근할 수 있도록 설정하였다.</p><p>request를 받아, <code>/</code> 에 접근하는 요청에 대해 <code>permitAll()</code>을 통해 누구나 접근할 수 있도록 설정할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests((requests) -&gt;</span><br><span class="line">                requests.antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">        );</span><br><span class="line">        http.formLogin();</span><br><span class="line">        http.httpBasic();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Basic" scheme="http://inwoo.github.io/categories/Basic/"/>
    
    <category term="Spring Security" scheme="http://inwoo.github.io/categories/Basic/Spring-Security/"/>
    
    
    <category term="spring security" scheme="http://inwoo.github.io/tags/spring-security/"/>
    
  </entry>
  
  <entry>
    <title>Controller와 Rest-Controller의 차이점</title>
    <link href="http://inwoo.github.io/11/14/ControllerRestController/"/>
    <id>http://inwoo.github.io/11/14/ControllerRestController/</id>
    <published>2021-11-14T13:28:24.000Z</published>
    <updated>2021-11-14T14:30:01.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span><!-- excerpt --><p>Spring에서 <code>Controller</code>임을 명시하기 위해 클래스 상단에 <code>Controller</code> 혹은 <code>RestController</code> 어노테이션을 붙여준다.</p><blockquote><h4 id="이-둘의-주요-차이점은-HTTP-Response-Body가-생성되는-방식에-있다"><a href="#이-둘의-주요-차이점은-HTTP-Response-Body가-생성되는-방식에-있다" class="headerlink" title="이 둘의 주요 차이점은 HTTP Response Body가 생성되는 방식에 있다."></a>이 둘의 주요 차이점은 HTTP Response Body가 생성되는 방식에 있다.</h4><h4 id="RestController는-Controller와-ResponseBody의-조합으로-생각해도-좋다"><a href="#RestController는-Controller와-ResponseBody의-조합으로-생각해도-좋다" class="headerlink" title="RestController는 Controller와 ResponseBody의 조합으로 생각해도 좋다."></a>RestController는 Controller와 ResponseBody의 조합으로 생각해도 좋다.</h4><p>Controller : Spring MVC 모델에서 사용<br>RestController : RESTful 웹 서비스에서 사용</p></blockquote><h3 id="Spring-MVC-처리과정"><a href="#Spring-MVC-처리과정" class="headerlink" title="Spring MVC 처리과정"></a>Spring MVC 처리과정</h3><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bXvA4D/btqW4gE9bMH/TzOqxMdEnRXTAVqaLre5TK/img.png" alt="MVC"></p><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value=TYEP)</span></span><br><span class="line"><span class="meta">@Retention(value=RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller</span><br></pre></td></tr></table></figure><ul><li><code>Spring MVC</code>의 Controller는 <code>Model</code> 객체를 만들어 데이터를 담아 적절한 jsp파일 등의 <code>View</code>를 반환해주는 역할을 한다.</li></ul><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value=TYEP)</span></span><br><span class="line"><span class="meta">@Retention(value=RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController</span><br></pre></td></tr></table></figure><ul><li><p>RestController는 단순히 객체를 반환하고, 객체 데이터는 JSON, XML 등의 형식으로 HTTP 응답에 담아서 전송한다.</p></li><li><p>뷰가 아닌 Data를 반환하여 응답에 보다 유용하게 사용된다.</p></li><li><p>RestController 어노테이션에는 Controller와 ResponseBody 어노테이션이 달려있다.</p></li></ul><blockquote><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a href="https://dncjf64.tistory.com/288">기회는 찬스</a></p><p><a href="https://www.baeldung.com/spring-controller-vs-restcontroller">Baeldung Blog</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
    
    
    
    <category term="Basic" scheme="http://inwoo.github.io/categories/Basic/"/>
    
    <category term="Web &amp; Network" scheme="http://inwoo.github.io/categories/Basic/Web-Network/"/>
    
    
    <category term="Controller" scheme="http://inwoo.github.io/tags/Controller/"/>
    
  </entry>
  
</feed>
